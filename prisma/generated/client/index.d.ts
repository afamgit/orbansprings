
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bannerads
 * 
 */
export type bannerads = $Result.DefaultSelection<Prisma.$banneradsPayload>
/**
 * Model blog
 * 
 */
export type blog = $Result.DefaultSelection<Prisma.$blogPayload>
/**
 * Model contentpages
 * 
 */
export type contentpages = $Result.DefaultSelection<Prisma.$contentpagesPayload>
/**
 * Model driver_payments
 * 
 */
export type driver_payments = $Result.DefaultSelection<Prisma.$driver_paymentsPayload>
/**
 * Model faqs
 * 
 */
export type faqs = $Result.DefaultSelection<Prisma.$faqsPayload>
/**
 * Model loc_states
 * 
 */
export type loc_states = $Result.DefaultSelection<Prisma.$loc_statesPayload>
/**
 * Model media_assets
 * 
 */
export type media_assets = $Result.DefaultSelection<Prisma.$media_assetsPayload>
/**
 * Model newsletter
 * 
 */
export type newsletter = $Result.DefaultSelection<Prisma.$newsletterPayload>
/**
 * Model newsletter_body
 * 
 */
export type newsletter_body = $Result.DefaultSelection<Prisma.$newsletter_bodyPayload>
/**
 * Model paystackresponse
 * 
 */
export type paystackresponse = $Result.DefaultSelection<Prisma.$paystackresponsePayload>
/**
 * Model productcategories
 * 
 */
export type productcategories = $Result.DefaultSelection<Prisma.$productcategoriesPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model requests
 * 
 */
export type requests = $Result.DefaultSelection<Prisma.$requestsPayload>
/**
 * Model shopinfo
 * 
 */
export type shopinfo = $Result.DefaultSelection<Prisma.$shopinfoPayload>
/**
 * Model sociallinks
 * 
 */
export type sociallinks = $Result.DefaultSelection<Prisma.$sociallinksPayload>
/**
 * Model subscription
 * 
 */
export type subscription = $Result.DefaultSelection<Prisma.$subscriptionPayload>
/**
 * Model team_category
 * 
 */
export type team_category = $Result.DefaultSelection<Prisma.$team_categoryPayload>
/**
 * Model team_members
 * 
 */
export type team_members = $Result.DefaultSelection<Prisma.$team_membersPayload>
/**
 * Model testimonials
 * 
 */
export type testimonials = $Result.DefaultSelection<Prisma.$testimonialsPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model usermessages
 * 
 */
export type usermessages = $Result.DefaultSelection<Prisma.$usermessagesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model videocat
 * 
 */
export type videocat = $Result.DefaultSelection<Prisma.$videocatPayload>
/**
 * Model videos
 * 
 */
export type videos = $Result.DefaultSelection<Prisma.$videosPayload>
/**
 * Model meter_domestic_entries
 * 
 */
export type meter_domestic_entries = $Result.DefaultSelection<Prisma.$meter_domestic_entriesPayload>
/**
 * Model meter_supply_entries
 * 
 */
export type meter_supply_entries = $Result.DefaultSelection<Prisma.$meter_supply_entriesPayload>
/**
 * Model meter_tanker_entries
 * 
 */
export type meter_tanker_entries = $Result.DefaultSelection<Prisma.$meter_tanker_entriesPayload>
/**
 * Model meters
 * 
 */
export type meters = $Result.DefaultSelection<Prisma.$metersPayload>
/**
 * Model contact_messages
 * 
 */
export type contact_messages = $Result.DefaultSelection<Prisma.$contact_messagesPayload>
/**
 * Model meter_numbers
 * 
 */
export type meter_numbers = $Result.DefaultSelection<Prisma.$meter_numbersPayload>
/**
 * Model driverequests
 * 
 */
export type driverequests = $Result.DefaultSelection<Prisma.$driverequestsPayload>
/**
 * Model order_table
 * 
 */
export type order_table = $Result.DefaultSelection<Prisma.$order_tablePayload>
/**
 * Model packages
 * 
 */
export type packages = $Result.DefaultSelection<Prisma.$packagesPayload>
/**
 * Model ratings
 * 
 */
export type ratings = $Result.DefaultSelection<Prisma.$ratingsPayload>
/**
 * Model usercat
 * 
 */
export type usercat = $Result.DefaultSelection<Prisma.$usercatPayload>
/**
 * Model complaints_replies
 * 
 */
export type complaints_replies = $Result.DefaultSelection<Prisma.$complaints_repliesPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>
/**
 * Model trucks
 * 
 */
export type trucks = $Result.DefaultSelection<Prisma.$trucksPayload>
/**
 * Model area_groups
 * 
 */
export type area_groups = $Result.DefaultSelection<Prisma.$area_groupsPayload>
/**
 * Model product_prices_areas
 * 
 */
export type product_prices_areas = $Result.DefaultSelection<Prisma.$product_prices_areasPayload>
/**
 * Model articles
 * 
 */
export type articles = $Result.DefaultSelection<Prisma.$articlesPayload>
/**
 * Model subscription_plans
 * 
 */
export type subscription_plans = $Result.DefaultSelection<Prisma.$subscription_plansPayload>
/**
 * Model vendorreports
 * 
 */
export type vendorreports = $Result.DefaultSelection<Prisma.$vendorreportsPayload>
/**
 * Model water_purchases
 * 
 */
export type water_purchases = $Result.DefaultSelection<Prisma.$water_purchasesPayload>
/**
 * Model MeterReadings
 * 
 */
export type MeterReadings = $Result.DefaultSelection<Prisma.$MeterReadingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const order_table_last_update_by: {
  customer: 'customer',
  staff: 'staff',
  gateway: 'gateway',
  admin: 'admin'
};

export type order_table_last_update_by = (typeof order_table_last_update_by)[keyof typeof order_table_last_update_by]

}

export type order_table_last_update_by = $Enums.order_table_last_update_by

export const order_table_last_update_by: typeof $Enums.order_table_last_update_by

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bannerads
 * const bannerads = await prisma.bannerads.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bannerads
   * const bannerads = await prisma.bannerads.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bannerads`: Exposes CRUD operations for the **bannerads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bannerads
    * const bannerads = await prisma.bannerads.findMany()
    * ```
    */
  get bannerads(): Prisma.banneradsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.blogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentpages`: Exposes CRUD operations for the **contentpages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contentpages
    * const contentpages = await prisma.contentpages.findMany()
    * ```
    */
  get contentpages(): Prisma.contentpagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver_payments`: Exposes CRUD operations for the **driver_payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Driver_payments
    * const driver_payments = await prisma.driver_payments.findMany()
    * ```
    */
  get driver_payments(): Prisma.driver_paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faqs`: Exposes CRUD operations for the **faqs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faqs.findMany()
    * ```
    */
  get faqs(): Prisma.faqsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loc_states`: Exposes CRUD operations for the **loc_states** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loc_states
    * const loc_states = await prisma.loc_states.findMany()
    * ```
    */
  get loc_states(): Prisma.loc_statesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media_assets`: Exposes CRUD operations for the **media_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media_assets
    * const media_assets = await prisma.media_assets.findMany()
    * ```
    */
  get media_assets(): Prisma.media_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletter`: Exposes CRUD operations for the **newsletter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletters
    * const newsletters = await prisma.newsletter.findMany()
    * ```
    */
  get newsletter(): Prisma.newsletterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletter_body`: Exposes CRUD operations for the **newsletter_body** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletter_bodies
    * const newsletter_bodies = await prisma.newsletter_body.findMany()
    * ```
    */
  get newsletter_body(): Prisma.newsletter_bodyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paystackresponse`: Exposes CRUD operations for the **paystackresponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paystackresponses
    * const paystackresponses = await prisma.paystackresponse.findMany()
    * ```
    */
  get paystackresponse(): Prisma.paystackresponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productcategories`: Exposes CRUD operations for the **productcategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productcategories
    * const productcategories = await prisma.productcategories.findMany()
    * ```
    */
  get productcategories(): Prisma.productcategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requests`: Exposes CRUD operations for the **requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.requests.findMany()
    * ```
    */
  get requests(): Prisma.requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopinfo`: Exposes CRUD operations for the **shopinfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shopinfos
    * const shopinfos = await prisma.shopinfo.findMany()
    * ```
    */
  get shopinfo(): Prisma.shopinfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sociallinks`: Exposes CRUD operations for the **sociallinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sociallinks
    * const sociallinks = await prisma.sociallinks.findMany()
    * ```
    */
  get sociallinks(): Prisma.sociallinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team_category`: Exposes CRUD operations for the **team_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_categories
    * const team_categories = await prisma.team_category.findMany()
    * ```
    */
  get team_category(): Prisma.team_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team_members`: Exposes CRUD operations for the **team_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_members
    * const team_members = await prisma.team_members.findMany()
    * ```
    */
  get team_members(): Prisma.team_membersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonials`: Exposes CRUD operations for the **testimonials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonials.findMany()
    * ```
    */
  get testimonials(): Prisma.testimonialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usermessages`: Exposes CRUD operations for the **usermessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usermessages
    * const usermessages = await prisma.usermessages.findMany()
    * ```
    */
  get usermessages(): Prisma.usermessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videocat`: Exposes CRUD operations for the **videocat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videocats
    * const videocats = await prisma.videocat.findMany()
    * ```
    */
  get videocat(): Prisma.videocatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos`: Exposes CRUD operations for the **videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.videos.findMany()
    * ```
    */
  get videos(): Prisma.videosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meter_domestic_entries`: Exposes CRUD operations for the **meter_domestic_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_domestic_entries
    * const meter_domestic_entries = await prisma.meter_domestic_entries.findMany()
    * ```
    */
  get meter_domestic_entries(): Prisma.meter_domestic_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meter_supply_entries`: Exposes CRUD operations for the **meter_supply_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_supply_entries
    * const meter_supply_entries = await prisma.meter_supply_entries.findMany()
    * ```
    */
  get meter_supply_entries(): Prisma.meter_supply_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meter_tanker_entries`: Exposes CRUD operations for the **meter_tanker_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_tanker_entries
    * const meter_tanker_entries = await prisma.meter_tanker_entries.findMany()
    * ```
    */
  get meter_tanker_entries(): Prisma.meter_tanker_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meters`: Exposes CRUD operations for the **meters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meters
    * const meters = await prisma.meters.findMany()
    * ```
    */
  get meters(): Prisma.metersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact_messages`: Exposes CRUD operations for the **contact_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_messages
    * const contact_messages = await prisma.contact_messages.findMany()
    * ```
    */
  get contact_messages(): Prisma.contact_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meter_numbers`: Exposes CRUD operations for the **meter_numbers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_numbers
    * const meter_numbers = await prisma.meter_numbers.findMany()
    * ```
    */
  get meter_numbers(): Prisma.meter_numbersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverequests`: Exposes CRUD operations for the **driverequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Driverequests
    * const driverequests = await prisma.driverequests.findMany()
    * ```
    */
  get driverequests(): Prisma.driverequestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_table`: Exposes CRUD operations for the **order_table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_tables
    * const order_tables = await prisma.order_table.findMany()
    * ```
    */
  get order_table(): Prisma.order_tableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packages`: Exposes CRUD operations for the **packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.packages.findMany()
    * ```
    */
  get packages(): Prisma.packagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ratings`: Exposes CRUD operations for the **ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.ratings.findMany()
    * ```
    */
  get ratings(): Prisma.ratingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usercat`: Exposes CRUD operations for the **usercat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usercats
    * const usercats = await prisma.usercat.findMany()
    * ```
    */
  get usercat(): Prisma.usercatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaints_replies`: Exposes CRUD operations for the **complaints_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints_replies
    * const complaints_replies = await prisma.complaints_replies.findMany()
    * ```
    */
  get complaints_replies(): Prisma.complaints_repliesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trucks`: Exposes CRUD operations for the **trucks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.trucks.findMany()
    * ```
    */
  get trucks(): Prisma.trucksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area_groups`: Exposes CRUD operations for the **area_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Area_groups
    * const area_groups = await prisma.area_groups.findMany()
    * ```
    */
  get area_groups(): Prisma.area_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product_prices_areas`: Exposes CRUD operations for the **product_prices_areas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_prices_areas
    * const product_prices_areas = await prisma.product_prices_areas.findMany()
    * ```
    */
  get product_prices_areas(): Prisma.product_prices_areasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.articles`: Exposes CRUD operations for the **articles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.articles.findMany()
    * ```
    */
  get articles(): Prisma.articlesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription_plans`: Exposes CRUD operations for the **subscription_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscription_plans
    * const subscription_plans = await prisma.subscription_plans.findMany()
    * ```
    */
  get subscription_plans(): Prisma.subscription_plansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorreports`: Exposes CRUD operations for the **vendorreports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendorreports
    * const vendorreports = await prisma.vendorreports.findMany()
    * ```
    */
  get vendorreports(): Prisma.vendorreportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.water_purchases`: Exposes CRUD operations for the **water_purchases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Water_purchases
    * const water_purchases = await prisma.water_purchases.findMany()
    * ```
    */
  get water_purchases(): Prisma.water_purchasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meterReadings`: Exposes CRUD operations for the **MeterReadings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeterReadings
    * const meterReadings = await prisma.meterReadings.findMany()
    * ```
    */
  get meterReadings(): Prisma.MeterReadingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bannerads: 'bannerads',
    blog: 'blog',
    contentpages: 'contentpages',
    driver_payments: 'driver_payments',
    faqs: 'faqs',
    loc_states: 'loc_states',
    media_assets: 'media_assets',
    newsletter: 'newsletter',
    newsletter_body: 'newsletter_body',
    paystackresponse: 'paystackresponse',
    productcategories: 'productcategories',
    products: 'products',
    requests: 'requests',
    shopinfo: 'shopinfo',
    sociallinks: 'sociallinks',
    subscription: 'subscription',
    team_category: 'team_category',
    team_members: 'team_members',
    testimonials: 'testimonials',
    transactions: 'transactions',
    usermessages: 'usermessages',
    users: 'users',
    videocat: 'videocat',
    videos: 'videos',
    meter_domestic_entries: 'meter_domestic_entries',
    meter_supply_entries: 'meter_supply_entries',
    meter_tanker_entries: 'meter_tanker_entries',
    meters: 'meters',
    contact_messages: 'contact_messages',
    meter_numbers: 'meter_numbers',
    driverequests: 'driverequests',
    order_table: 'order_table',
    packages: 'packages',
    ratings: 'ratings',
    usercat: 'usercat',
    complaints_replies: 'complaints_replies',
    subscriptions: 'subscriptions',
    trucks: 'trucks',
    area_groups: 'area_groups',
    product_prices_areas: 'product_prices_areas',
    articles: 'articles',
    subscription_plans: 'subscription_plans',
    vendorreports: 'vendorreports',
    water_purchases: 'water_purchases',
    MeterReadings: 'MeterReadings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bannerads" | "blog" | "contentpages" | "driver_payments" | "faqs" | "loc_states" | "media_assets" | "newsletter" | "newsletter_body" | "paystackresponse" | "productcategories" | "products" | "requests" | "shopinfo" | "sociallinks" | "subscription" | "team_category" | "team_members" | "testimonials" | "transactions" | "usermessages" | "users" | "videocat" | "videos" | "meter_domestic_entries" | "meter_supply_entries" | "meter_tanker_entries" | "meters" | "contact_messages" | "meter_numbers" | "driverequests" | "order_table" | "packages" | "ratings" | "usercat" | "complaints_replies" | "subscriptions" | "trucks" | "area_groups" | "product_prices_areas" | "articles" | "subscription_plans" | "vendorreports" | "water_purchases" | "meterReadings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      bannerads: {
        payload: Prisma.$banneradsPayload<ExtArgs>
        fields: Prisma.banneradsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banneradsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banneradsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          findFirst: {
            args: Prisma.banneradsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banneradsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          findMany: {
            args: Prisma.banneradsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>[]
          }
          create: {
            args: Prisma.banneradsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          createMany: {
            args: Prisma.banneradsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.banneradsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          update: {
            args: Prisma.banneradsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          deleteMany: {
            args: Prisma.banneradsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.banneradsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.banneradsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banneradsPayload>
          }
          aggregate: {
            args: Prisma.BanneradsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerads>
          }
          groupBy: {
            args: Prisma.banneradsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BanneradsGroupByOutputType>[]
          }
          count: {
            args: Prisma.banneradsCountArgs<ExtArgs>
            result: $Utils.Optional<BanneradsCountAggregateOutputType> | number
          }
        }
      }
      blog: {
        payload: Prisma.$blogPayload<ExtArgs>
        fields: Prisma.blogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          findFirst: {
            args: Prisma.blogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          findMany: {
            args: Prisma.blogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>[]
          }
          create: {
            args: Prisma.blogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          createMany: {
            args: Prisma.blogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          update: {
            args: Prisma.blogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          deleteMany: {
            args: Prisma.blogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.blogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.blogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      contentpages: {
        payload: Prisma.$contentpagesPayload<ExtArgs>
        fields: Prisma.contentpagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contentpagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contentpagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          findFirst: {
            args: Prisma.contentpagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contentpagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          findMany: {
            args: Prisma.contentpagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>[]
          }
          create: {
            args: Prisma.contentpagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          createMany: {
            args: Prisma.contentpagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contentpagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          update: {
            args: Prisma.contentpagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          deleteMany: {
            args: Prisma.contentpagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contentpagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contentpagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contentpagesPayload>
          }
          aggregate: {
            args: Prisma.ContentpagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentpages>
          }
          groupBy: {
            args: Prisma.contentpagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentpagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.contentpagesCountArgs<ExtArgs>
            result: $Utils.Optional<ContentpagesCountAggregateOutputType> | number
          }
        }
      }
      driver_payments: {
        payload: Prisma.$driver_paymentsPayload<ExtArgs>
        fields: Prisma.driver_paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.driver_paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.driver_paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          findFirst: {
            args: Prisma.driver_paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.driver_paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          findMany: {
            args: Prisma.driver_paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>[]
          }
          create: {
            args: Prisma.driver_paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          createMany: {
            args: Prisma.driver_paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.driver_paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          update: {
            args: Prisma.driver_paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          deleteMany: {
            args: Prisma.driver_paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.driver_paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.driver_paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driver_paymentsPayload>
          }
          aggregate: {
            args: Prisma.Driver_paymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver_payments>
          }
          groupBy: {
            args: Prisma.driver_paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Driver_paymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.driver_paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<Driver_paymentsCountAggregateOutputType> | number
          }
        }
      }
      faqs: {
        payload: Prisma.$faqsPayload<ExtArgs>
        fields: Prisma.faqsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faqsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faqsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findFirst: {
            args: Prisma.faqsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faqsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findMany: {
            args: Prisma.faqsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>[]
          }
          create: {
            args: Prisma.faqsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          createMany: {
            args: Prisma.faqsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.faqsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          update: {
            args: Prisma.faqsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          deleteMany: {
            args: Prisma.faqsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.faqsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.faqsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          aggregate: {
            args: Prisma.FaqsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaqs>
          }
          groupBy: {
            args: Prisma.faqsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqsGroupByOutputType>[]
          }
          count: {
            args: Prisma.faqsCountArgs<ExtArgs>
            result: $Utils.Optional<FaqsCountAggregateOutputType> | number
          }
        }
      }
      loc_states: {
        payload: Prisma.$loc_statesPayload<ExtArgs>
        fields: Prisma.loc_statesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loc_statesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loc_statesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          findFirst: {
            args: Prisma.loc_statesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loc_statesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          findMany: {
            args: Prisma.loc_statesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>[]
          }
          create: {
            args: Prisma.loc_statesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          createMany: {
            args: Prisma.loc_statesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.loc_statesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          update: {
            args: Prisma.loc_statesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          deleteMany: {
            args: Prisma.loc_statesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loc_statesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loc_statesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loc_statesPayload>
          }
          aggregate: {
            args: Prisma.Loc_statesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoc_states>
          }
          groupBy: {
            args: Prisma.loc_statesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Loc_statesGroupByOutputType>[]
          }
          count: {
            args: Prisma.loc_statesCountArgs<ExtArgs>
            result: $Utils.Optional<Loc_statesCountAggregateOutputType> | number
          }
        }
      }
      media_assets: {
        payload: Prisma.$media_assetsPayload<ExtArgs>
        fields: Prisma.media_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.media_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.media_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          findFirst: {
            args: Prisma.media_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.media_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          findMany: {
            args: Prisma.media_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>[]
          }
          create: {
            args: Prisma.media_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          createMany: {
            args: Prisma.media_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.media_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          update: {
            args: Prisma.media_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          deleteMany: {
            args: Prisma.media_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.media_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.media_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$media_assetsPayload>
          }
          aggregate: {
            args: Prisma.Media_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia_assets>
          }
          groupBy: {
            args: Prisma.media_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Media_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.media_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Media_assetsCountAggregateOutputType> | number
          }
        }
      }
      newsletter: {
        payload: Prisma.$newsletterPayload<ExtArgs>
        fields: Prisma.newsletterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          findFirst: {
            args: Prisma.newsletterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          findMany: {
            args: Prisma.newsletterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>[]
          }
          create: {
            args: Prisma.newsletterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          createMany: {
            args: Prisma.newsletterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.newsletterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          update: {
            args: Prisma.newsletterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          deleteMany: {
            args: Prisma.newsletterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletterPayload>
          }
          aggregate: {
            args: Prisma.NewsletterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter>
          }
          groupBy: {
            args: Prisma.newsletterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletterCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCountAggregateOutputType> | number
          }
        }
      }
      newsletter_body: {
        payload: Prisma.$newsletter_bodyPayload<ExtArgs>
        fields: Prisma.newsletter_bodyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletter_bodyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletter_bodyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          findFirst: {
            args: Prisma.newsletter_bodyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletter_bodyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          findMany: {
            args: Prisma.newsletter_bodyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>[]
          }
          create: {
            args: Prisma.newsletter_bodyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          createMany: {
            args: Prisma.newsletter_bodyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.newsletter_bodyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          update: {
            args: Prisma.newsletter_bodyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          deleteMany: {
            args: Prisma.newsletter_bodyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletter_bodyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletter_bodyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_bodyPayload>
          }
          aggregate: {
            args: Prisma.Newsletter_bodyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter_body>
          }
          groupBy: {
            args: Prisma.newsletter_bodyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_bodyGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletter_bodyCountArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_bodyCountAggregateOutputType> | number
          }
        }
      }
      paystackresponse: {
        payload: Prisma.$paystackresponsePayload<ExtArgs>
        fields: Prisma.paystackresponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paystackresponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paystackresponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          findFirst: {
            args: Prisma.paystackresponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paystackresponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          findMany: {
            args: Prisma.paystackresponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>[]
          }
          create: {
            args: Prisma.paystackresponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          createMany: {
            args: Prisma.paystackresponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paystackresponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          update: {
            args: Prisma.paystackresponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          deleteMany: {
            args: Prisma.paystackresponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paystackresponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paystackresponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paystackresponsePayload>
          }
          aggregate: {
            args: Prisma.PaystackresponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaystackresponse>
          }
          groupBy: {
            args: Prisma.paystackresponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaystackresponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.paystackresponseCountArgs<ExtArgs>
            result: $Utils.Optional<PaystackresponseCountAggregateOutputType> | number
          }
        }
      }
      productcategories: {
        payload: Prisma.$productcategoriesPayload<ExtArgs>
        fields: Prisma.productcategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productcategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productcategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          findFirst: {
            args: Prisma.productcategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productcategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          findMany: {
            args: Prisma.productcategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>[]
          }
          create: {
            args: Prisma.productcategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          createMany: {
            args: Prisma.productcategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.productcategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          update: {
            args: Prisma.productcategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          deleteMany: {
            args: Prisma.productcategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productcategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productcategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productcategoriesPayload>
          }
          aggregate: {
            args: Prisma.ProductcategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductcategories>
          }
          groupBy: {
            args: Prisma.productcategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductcategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.productcategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<ProductcategoriesCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      requests: {
        payload: Prisma.$requestsPayload<ExtArgs>
        fields: Prisma.requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          findFirst: {
            args: Prisma.requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          findMany: {
            args: Prisma.requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>[]
          }
          create: {
            args: Prisma.requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          createMany: {
            args: Prisma.requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          update: {
            args: Prisma.requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          deleteMany: {
            args: Prisma.requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          aggregate: {
            args: Prisma.RequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequests>
          }
          groupBy: {
            args: Prisma.requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.requestsCountArgs<ExtArgs>
            result: $Utils.Optional<RequestsCountAggregateOutputType> | number
          }
        }
      }
      shopinfo: {
        payload: Prisma.$shopinfoPayload<ExtArgs>
        fields: Prisma.shopinfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shopinfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shopinfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          findFirst: {
            args: Prisma.shopinfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shopinfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          findMany: {
            args: Prisma.shopinfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>[]
          }
          create: {
            args: Prisma.shopinfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          createMany: {
            args: Prisma.shopinfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shopinfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          update: {
            args: Prisma.shopinfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          deleteMany: {
            args: Prisma.shopinfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shopinfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shopinfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shopinfoPayload>
          }
          aggregate: {
            args: Prisma.ShopinfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopinfo>
          }
          groupBy: {
            args: Prisma.shopinfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopinfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.shopinfoCountArgs<ExtArgs>
            result: $Utils.Optional<ShopinfoCountAggregateOutputType> | number
          }
        }
      }
      sociallinks: {
        payload: Prisma.$sociallinksPayload<ExtArgs>
        fields: Prisma.sociallinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sociallinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sociallinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          findFirst: {
            args: Prisma.sociallinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sociallinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          findMany: {
            args: Prisma.sociallinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>[]
          }
          create: {
            args: Prisma.sociallinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          createMany: {
            args: Prisma.sociallinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sociallinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          update: {
            args: Prisma.sociallinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          deleteMany: {
            args: Prisma.sociallinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sociallinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sociallinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sociallinksPayload>
          }
          aggregate: {
            args: Prisma.SociallinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSociallinks>
          }
          groupBy: {
            args: Prisma.sociallinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<SociallinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.sociallinksCountArgs<ExtArgs>
            result: $Utils.Optional<SociallinksCountAggregateOutputType> | number
          }
        }
      }
      subscription: {
        payload: Prisma.$subscriptionPayload<ExtArgs>
        fields: Prisma.subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findFirst: {
            args: Prisma.subscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findMany: {
            args: Prisma.subscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          create: {
            args: Prisma.subscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          createMany: {
            args: Prisma.subscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          update: {
            args: Prisma.subscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.subscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      team_category: {
        payload: Prisma.$team_categoryPayload<ExtArgs>
        fields: Prisma.team_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          findFirst: {
            args: Prisma.team_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          findMany: {
            args: Prisma.team_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>[]
          }
          create: {
            args: Prisma.team_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          createMany: {
            args: Prisma.team_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          update: {
            args: Prisma.team_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          deleteMany: {
            args: Prisma.team_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_categoryPayload>
          }
          aggregate: {
            args: Prisma.Team_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_category>
          }
          groupBy: {
            args: Prisma.team_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Team_categoryCountAggregateOutputType> | number
          }
        }
      }
      team_members: {
        payload: Prisma.$team_membersPayload<ExtArgs>
        fields: Prisma.team_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          findFirst: {
            args: Prisma.team_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          findMany: {
            args: Prisma.team_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>[]
          }
          create: {
            args: Prisma.team_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          createMany: {
            args: Prisma.team_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          update: {
            args: Prisma.team_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          deleteMany: {
            args: Prisma.team_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_membersPayload>
          }
          aggregate: {
            args: Prisma.Team_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_members>
          }
          groupBy: {
            args: Prisma.team_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.team_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Team_membersCountAggregateOutputType> | number
          }
        }
      }
      testimonials: {
        payload: Prisma.$testimonialsPayload<ExtArgs>
        fields: Prisma.testimonialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testimonialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testimonialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          findFirst: {
            args: Prisma.testimonialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testimonialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          findMany: {
            args: Prisma.testimonialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>[]
          }
          create: {
            args: Prisma.testimonialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          createMany: {
            args: Prisma.testimonialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testimonialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          update: {
            args: Prisma.testimonialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          deleteMany: {
            args: Prisma.testimonialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testimonialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testimonialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialsPayload>
          }
          aggregate: {
            args: Prisma.TestimonialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonials>
          }
          groupBy: {
            args: Prisma.testimonialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.testimonialsCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialsCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      usermessages: {
        payload: Prisma.$usermessagesPayload<ExtArgs>
        fields: Prisma.usermessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usermessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usermessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          findFirst: {
            args: Prisma.usermessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usermessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          findMany: {
            args: Prisma.usermessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>[]
          }
          create: {
            args: Prisma.usermessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          createMany: {
            args: Prisma.usermessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usermessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          update: {
            args: Prisma.usermessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          deleteMany: {
            args: Prisma.usermessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usermessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usermessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usermessagesPayload>
          }
          aggregate: {
            args: Prisma.UsermessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsermessages>
          }
          groupBy: {
            args: Prisma.usermessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsermessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usermessagesCountArgs<ExtArgs>
            result: $Utils.Optional<UsermessagesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      videocat: {
        payload: Prisma.$videocatPayload<ExtArgs>
        fields: Prisma.videocatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videocatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videocatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          findFirst: {
            args: Prisma.videocatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videocatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          findMany: {
            args: Prisma.videocatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>[]
          }
          create: {
            args: Prisma.videocatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          createMany: {
            args: Prisma.videocatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videocatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          update: {
            args: Prisma.videocatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          deleteMany: {
            args: Prisma.videocatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videocatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videocatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videocatPayload>
          }
          aggregate: {
            args: Prisma.VideocatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideocat>
          }
          groupBy: {
            args: Prisma.videocatGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideocatGroupByOutputType>[]
          }
          count: {
            args: Prisma.videocatCountArgs<ExtArgs>
            result: $Utils.Optional<VideocatCountAggregateOutputType> | number
          }
        }
      }
      videos: {
        payload: Prisma.$videosPayload<ExtArgs>
        fields: Prisma.videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findFirst: {
            args: Prisma.videosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          findMany: {
            args: Prisma.videosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>[]
          }
          create: {
            args: Prisma.videosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          createMany: {
            args: Prisma.videosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.videosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          update: {
            args: Prisma.videosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          deleteMany: {
            args: Prisma.videosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.videosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.videosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$videosPayload>
          }
          aggregate: {
            args: Prisma.VideosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos>
          }
          groupBy: {
            args: Prisma.videosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideosGroupByOutputType>[]
          }
          count: {
            args: Prisma.videosCountArgs<ExtArgs>
            result: $Utils.Optional<VideosCountAggregateOutputType> | number
          }
        }
      }
      meter_domestic_entries: {
        payload: Prisma.$meter_domestic_entriesPayload<ExtArgs>
        fields: Prisma.meter_domestic_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_domestic_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_domestic_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          findFirst: {
            args: Prisma.meter_domestic_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_domestic_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          findMany: {
            args: Prisma.meter_domestic_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>[]
          }
          create: {
            args: Prisma.meter_domestic_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          createMany: {
            args: Prisma.meter_domestic_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meter_domestic_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          update: {
            args: Prisma.meter_domestic_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          deleteMany: {
            args: Prisma.meter_domestic_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_domestic_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_domestic_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_domestic_entriesPayload>
          }
          aggregate: {
            args: Prisma.Meter_domestic_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_domestic_entries>
          }
          groupBy: {
            args: Prisma.meter_domestic_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_domestic_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_domestic_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_domestic_entriesCountAggregateOutputType> | number
          }
        }
      }
      meter_supply_entries: {
        payload: Prisma.$meter_supply_entriesPayload<ExtArgs>
        fields: Prisma.meter_supply_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_supply_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_supply_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          findFirst: {
            args: Prisma.meter_supply_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_supply_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          findMany: {
            args: Prisma.meter_supply_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>[]
          }
          create: {
            args: Prisma.meter_supply_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          createMany: {
            args: Prisma.meter_supply_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meter_supply_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          update: {
            args: Prisma.meter_supply_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          deleteMany: {
            args: Prisma.meter_supply_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_supply_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_supply_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_supply_entriesPayload>
          }
          aggregate: {
            args: Prisma.Meter_supply_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_supply_entries>
          }
          groupBy: {
            args: Prisma.meter_supply_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_supply_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_supply_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_supply_entriesCountAggregateOutputType> | number
          }
        }
      }
      meter_tanker_entries: {
        payload: Prisma.$meter_tanker_entriesPayload<ExtArgs>
        fields: Prisma.meter_tanker_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_tanker_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_tanker_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          findFirst: {
            args: Prisma.meter_tanker_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_tanker_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          findMany: {
            args: Prisma.meter_tanker_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>[]
          }
          create: {
            args: Prisma.meter_tanker_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          createMany: {
            args: Prisma.meter_tanker_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meter_tanker_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          update: {
            args: Prisma.meter_tanker_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          deleteMany: {
            args: Prisma.meter_tanker_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_tanker_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_tanker_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_tanker_entriesPayload>
          }
          aggregate: {
            args: Prisma.Meter_tanker_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_tanker_entries>
          }
          groupBy: {
            args: Prisma.meter_tanker_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_tanker_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_tanker_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_tanker_entriesCountAggregateOutputType> | number
          }
        }
      }
      meters: {
        payload: Prisma.$metersPayload<ExtArgs>
        fields: Prisma.metersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          findFirst: {
            args: Prisma.metersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          findMany: {
            args: Prisma.metersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>[]
          }
          create: {
            args: Prisma.metersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          createMany: {
            args: Prisma.metersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.metersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          update: {
            args: Prisma.metersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          deleteMany: {
            args: Prisma.metersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.metersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          aggregate: {
            args: Prisma.MetersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeters>
          }
          groupBy: {
            args: Prisma.metersGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetersGroupByOutputType>[]
          }
          count: {
            args: Prisma.metersCountArgs<ExtArgs>
            result: $Utils.Optional<MetersCountAggregateOutputType> | number
          }
        }
      }
      contact_messages: {
        payload: Prisma.$contact_messagesPayload<ExtArgs>
        fields: Prisma.contact_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contact_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contact_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          findFirst: {
            args: Prisma.contact_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contact_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          findMany: {
            args: Prisma.contact_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>[]
          }
          create: {
            args: Prisma.contact_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          createMany: {
            args: Prisma.contact_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contact_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          update: {
            args: Prisma.contact_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          deleteMany: {
            args: Prisma.contact_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contact_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contact_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          aggregate: {
            args: Prisma.Contact_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_messages>
          }
          groupBy: {
            args: Prisma.contact_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.contact_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_messagesCountAggregateOutputType> | number
          }
        }
      }
      meter_numbers: {
        payload: Prisma.$meter_numbersPayload<ExtArgs>
        fields: Prisma.meter_numbersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_numbersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_numbersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          findFirst: {
            args: Prisma.meter_numbersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_numbersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          findMany: {
            args: Prisma.meter_numbersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>[]
          }
          create: {
            args: Prisma.meter_numbersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          createMany: {
            args: Prisma.meter_numbersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meter_numbersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          update: {
            args: Prisma.meter_numbersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          deleteMany: {
            args: Prisma.meter_numbersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_numbersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_numbersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_numbersPayload>
          }
          aggregate: {
            args: Prisma.Meter_numbersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_numbers>
          }
          groupBy: {
            args: Prisma.meter_numbersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_numbersGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_numbersCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_numbersCountAggregateOutputType> | number
          }
        }
      }
      driverequests: {
        payload: Prisma.$driverequestsPayload<ExtArgs>
        fields: Prisma.driverequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.driverequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.driverequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          findFirst: {
            args: Prisma.driverequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.driverequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          findMany: {
            args: Prisma.driverequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>[]
          }
          create: {
            args: Prisma.driverequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          createMany: {
            args: Prisma.driverequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.driverequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          update: {
            args: Prisma.driverequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          deleteMany: {
            args: Prisma.driverequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.driverequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.driverequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$driverequestsPayload>
          }
          aggregate: {
            args: Prisma.DriverequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverequests>
          }
          groupBy: {
            args: Prisma.driverequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.driverequestsCountArgs<ExtArgs>
            result: $Utils.Optional<DriverequestsCountAggregateOutputType> | number
          }
        }
      }
      order_table: {
        payload: Prisma.$order_tablePayload<ExtArgs>
        fields: Prisma.order_tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_tableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_tableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          findFirst: {
            args: Prisma.order_tableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_tableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          findMany: {
            args: Prisma.order_tableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>[]
          }
          create: {
            args: Prisma.order_tableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          createMany: {
            args: Prisma.order_tableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.order_tableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          update: {
            args: Prisma.order_tableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          deleteMany: {
            args: Prisma.order_tableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_tableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.order_tableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_tablePayload>
          }
          aggregate: {
            args: Prisma.Order_tableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_table>
          }
          groupBy: {
            args: Prisma.order_tableGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_tableGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_tableCountArgs<ExtArgs>
            result: $Utils.Optional<Order_tableCountAggregateOutputType> | number
          }
        }
      }
      packages: {
        payload: Prisma.$packagesPayload<ExtArgs>
        fields: Prisma.packagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.packagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.packagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findFirst: {
            args: Prisma.packagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.packagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findMany: {
            args: Prisma.packagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          create: {
            args: Prisma.packagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          createMany: {
            args: Prisma.packagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.packagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          update: {
            args: Prisma.packagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          deleteMany: {
            args: Prisma.packagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.packagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.packagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          aggregate: {
            args: Prisma.PackagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackages>
          }
          groupBy: {
            args: Prisma.packagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.packagesCountArgs<ExtArgs>
            result: $Utils.Optional<PackagesCountAggregateOutputType> | number
          }
        }
      }
      ratings: {
        payload: Prisma.$ratingsPayload<ExtArgs>
        fields: Prisma.ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ratingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ratingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findFirst: {
            args: Prisma.ratingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ratingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findMany: {
            args: Prisma.ratingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>[]
          }
          create: {
            args: Prisma.ratingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          createMany: {
            args: Prisma.ratingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ratingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          update: {
            args: Prisma.ratingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          deleteMany: {
            args: Prisma.ratingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ratingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ratingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          aggregate: {
            args: Prisma.RatingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRatings>
          }
          groupBy: {
            args: Prisma.ratingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ratingsCountArgs<ExtArgs>
            result: $Utils.Optional<RatingsCountAggregateOutputType> | number
          }
        }
      }
      usercat: {
        payload: Prisma.$usercatPayload<ExtArgs>
        fields: Prisma.usercatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usercatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usercatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          findFirst: {
            args: Prisma.usercatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usercatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          findMany: {
            args: Prisma.usercatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>[]
          }
          create: {
            args: Prisma.usercatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          createMany: {
            args: Prisma.usercatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usercatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          update: {
            args: Prisma.usercatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          deleteMany: {
            args: Prisma.usercatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usercatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usercatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercatPayload>
          }
          aggregate: {
            args: Prisma.UsercatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsercat>
          }
          groupBy: {
            args: Prisma.usercatGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsercatGroupByOutputType>[]
          }
          count: {
            args: Prisma.usercatCountArgs<ExtArgs>
            result: $Utils.Optional<UsercatCountAggregateOutputType> | number
          }
        }
      }
      complaints_replies: {
        payload: Prisma.$complaints_repliesPayload<ExtArgs>
        fields: Prisma.complaints_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.complaints_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.complaints_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          findFirst: {
            args: Prisma.complaints_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.complaints_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          findMany: {
            args: Prisma.complaints_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>[]
          }
          create: {
            args: Prisma.complaints_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          createMany: {
            args: Prisma.complaints_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.complaints_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          update: {
            args: Prisma.complaints_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          deleteMany: {
            args: Prisma.complaints_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.complaints_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.complaints_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaints_repliesPayload>
          }
          aggregate: {
            args: Prisma.Complaints_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaints_replies>
          }
          groupBy: {
            args: Prisma.complaints_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Complaints_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.complaints_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Complaints_repliesCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      trucks: {
        payload: Prisma.$trucksPayload<ExtArgs>
        fields: Prisma.trucksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trucksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trucksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          findFirst: {
            args: Prisma.trucksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trucksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          findMany: {
            args: Prisma.trucksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>[]
          }
          create: {
            args: Prisma.trucksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          createMany: {
            args: Prisma.trucksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trucksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          update: {
            args: Prisma.trucksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          deleteMany: {
            args: Prisma.trucksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trucksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trucksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trucksPayload>
          }
          aggregate: {
            args: Prisma.TrucksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrucks>
          }
          groupBy: {
            args: Prisma.trucksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrucksGroupByOutputType>[]
          }
          count: {
            args: Prisma.trucksCountArgs<ExtArgs>
            result: $Utils.Optional<TrucksCountAggregateOutputType> | number
          }
        }
      }
      area_groups: {
        payload: Prisma.$area_groupsPayload<ExtArgs>
        fields: Prisma.area_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.area_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.area_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          findFirst: {
            args: Prisma.area_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.area_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          findMany: {
            args: Prisma.area_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>[]
          }
          create: {
            args: Prisma.area_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          createMany: {
            args: Prisma.area_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.area_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          update: {
            args: Prisma.area_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          deleteMany: {
            args: Prisma.area_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.area_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.area_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$area_groupsPayload>
          }
          aggregate: {
            args: Prisma.Area_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea_groups>
          }
          groupBy: {
            args: Prisma.area_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Area_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.area_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Area_groupsCountAggregateOutputType> | number
          }
        }
      }
      product_prices_areas: {
        payload: Prisma.$product_prices_areasPayload<ExtArgs>
        fields: Prisma.product_prices_areasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_prices_areasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_prices_areasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          findFirst: {
            args: Prisma.product_prices_areasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_prices_areasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          findMany: {
            args: Prisma.product_prices_areasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>[]
          }
          create: {
            args: Prisma.product_prices_areasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          createMany: {
            args: Prisma.product_prices_areasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.product_prices_areasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          update: {
            args: Prisma.product_prices_areasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          deleteMany: {
            args: Prisma.product_prices_areasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.product_prices_areasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.product_prices_areasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_prices_areasPayload>
          }
          aggregate: {
            args: Prisma.Product_prices_areasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct_prices_areas>
          }
          groupBy: {
            args: Prisma.product_prices_areasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Product_prices_areasGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_prices_areasCountArgs<ExtArgs>
            result: $Utils.Optional<Product_prices_areasCountAggregateOutputType> | number
          }
        }
      }
      articles: {
        payload: Prisma.$articlesPayload<ExtArgs>
        fields: Prisma.articlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.articlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.articlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          findFirst: {
            args: Prisma.articlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.articlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          findMany: {
            args: Prisma.articlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>[]
          }
          create: {
            args: Prisma.articlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          createMany: {
            args: Prisma.articlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.articlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          update: {
            args: Prisma.articlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          deleteMany: {
            args: Prisma.articlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.articlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.articlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlesPayload>
          }
          aggregate: {
            args: Prisma.ArticlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticles>
          }
          groupBy: {
            args: Prisma.articlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.articlesCountArgs<ExtArgs>
            result: $Utils.Optional<ArticlesCountAggregateOutputType> | number
          }
        }
      }
      subscription_plans: {
        payload: Prisma.$subscription_plansPayload<ExtArgs>
        fields: Prisma.subscription_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscription_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscription_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          findFirst: {
            args: Prisma.subscription_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscription_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          findMany: {
            args: Prisma.subscription_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>[]
          }
          create: {
            args: Prisma.subscription_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          createMany: {
            args: Prisma.subscription_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscription_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          update: {
            args: Prisma.subscription_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          deleteMany: {
            args: Prisma.subscription_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscription_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscription_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscription_plansPayload>
          }
          aggregate: {
            args: Prisma.Subscription_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription_plans>
          }
          groupBy: {
            args: Prisma.subscription_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Subscription_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscription_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Subscription_plansCountAggregateOutputType> | number
          }
        }
      }
      vendorreports: {
        payload: Prisma.$vendorreportsPayload<ExtArgs>
        fields: Prisma.vendorreportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vendorreportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vendorreportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          findFirst: {
            args: Prisma.vendorreportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vendorreportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          findMany: {
            args: Prisma.vendorreportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>[]
          }
          create: {
            args: Prisma.vendorreportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          createMany: {
            args: Prisma.vendorreportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vendorreportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          update: {
            args: Prisma.vendorreportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          deleteMany: {
            args: Prisma.vendorreportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vendorreportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vendorreportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vendorreportsPayload>
          }
          aggregate: {
            args: Prisma.VendorreportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorreports>
          }
          groupBy: {
            args: Prisma.vendorreportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorreportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.vendorreportsCountArgs<ExtArgs>
            result: $Utils.Optional<VendorreportsCountAggregateOutputType> | number
          }
        }
      }
      water_purchases: {
        payload: Prisma.$water_purchasesPayload<ExtArgs>
        fields: Prisma.water_purchasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.water_purchasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.water_purchasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          findFirst: {
            args: Prisma.water_purchasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.water_purchasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          findMany: {
            args: Prisma.water_purchasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>[]
          }
          create: {
            args: Prisma.water_purchasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          createMany: {
            args: Prisma.water_purchasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.water_purchasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          update: {
            args: Prisma.water_purchasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          deleteMany: {
            args: Prisma.water_purchasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.water_purchasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.water_purchasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$water_purchasesPayload>
          }
          aggregate: {
            args: Prisma.Water_purchasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWater_purchases>
          }
          groupBy: {
            args: Prisma.water_purchasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Water_purchasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.water_purchasesCountArgs<ExtArgs>
            result: $Utils.Optional<Water_purchasesCountAggregateOutputType> | number
          }
        }
      }
      MeterReadings: {
        payload: Prisma.$MeterReadingsPayload<ExtArgs>
        fields: Prisma.MeterReadingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeterReadingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeterReadingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          findFirst: {
            args: Prisma.MeterReadingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeterReadingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          findMany: {
            args: Prisma.MeterReadingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>[]
          }
          create: {
            args: Prisma.MeterReadingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          createMany: {
            args: Prisma.MeterReadingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeterReadingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          update: {
            args: Prisma.MeterReadingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          deleteMany: {
            args: Prisma.MeterReadingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeterReadingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeterReadingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeterReadingsPayload>
          }
          aggregate: {
            args: Prisma.MeterReadingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeterReadings>
          }
          groupBy: {
            args: Prisma.MeterReadingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeterReadingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeterReadingsCountArgs<ExtArgs>
            result: $Utils.Optional<MeterReadingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    bannerads?: banneradsOmit
    blog?: blogOmit
    contentpages?: contentpagesOmit
    driver_payments?: driver_paymentsOmit
    faqs?: faqsOmit
    loc_states?: loc_statesOmit
    media_assets?: media_assetsOmit
    newsletter?: newsletterOmit
    newsletter_body?: newsletter_bodyOmit
    paystackresponse?: paystackresponseOmit
    productcategories?: productcategoriesOmit
    products?: productsOmit
    requests?: requestsOmit
    shopinfo?: shopinfoOmit
    sociallinks?: sociallinksOmit
    subscription?: subscriptionOmit
    team_category?: team_categoryOmit
    team_members?: team_membersOmit
    testimonials?: testimonialsOmit
    transactions?: transactionsOmit
    usermessages?: usermessagesOmit
    users?: usersOmit
    videocat?: videocatOmit
    videos?: videosOmit
    meter_domestic_entries?: meter_domestic_entriesOmit
    meter_supply_entries?: meter_supply_entriesOmit
    meter_tanker_entries?: meter_tanker_entriesOmit
    meters?: metersOmit
    contact_messages?: contact_messagesOmit
    meter_numbers?: meter_numbersOmit
    driverequests?: driverequestsOmit
    order_table?: order_tableOmit
    packages?: packagesOmit
    ratings?: ratingsOmit
    usercat?: usercatOmit
    complaints_replies?: complaints_repliesOmit
    subscriptions?: subscriptionsOmit
    trucks?: trucksOmit
    area_groups?: area_groupsOmit
    product_prices_areas?: product_prices_areasOmit
    articles?: articlesOmit
    subscription_plans?: subscription_plansOmit
    vendorreports?: vendorreportsOmit
    water_purchases?: water_purchasesOmit
    meterReadings?: MeterReadingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    first_meter_readings: number
    afternoon_meter_readings: number
    last_meter_readings: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    first_meter_readings?: boolean | UsersCountOutputTypeCountFirst_meter_readingsArgs
    afternoon_meter_readings?: boolean | UsersCountOutputTypeCountAfternoon_meter_readingsArgs
    last_meter_readings?: boolean | UsersCountOutputTypeCountLast_meter_readingsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFirst_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterReadingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAfternoon_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterReadingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLast_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterReadingsWhereInput
  }


  /**
   * Count Type MetersCountOutputType
   */

  export type MetersCountOutputType = {
    meter_readings: number
  }

  export type MetersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meter_readings?: boolean | MetersCountOutputTypeCountMeter_readingsArgs
  }

  // Custom InputTypes
  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetersCountOutputType
     */
    select?: MetersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountMeter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterReadingsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model bannerads
   */

  export type AggregateBannerads = {
    _count: BanneradsCountAggregateOutputType | null
    _avg: BanneradsAvgAggregateOutputType | null
    _sum: BanneradsSumAggregateOutputType | null
    _min: BanneradsMinAggregateOutputType | null
    _max: BanneradsMaxAggregateOutputType | null
  }

  export type BanneradsAvgAggregateOutputType = {
    id_ad: number | null
    banner_rank: number | null
    visible_ad: number | null
    paid: number | null
    amount: Decimal | null
    views_ad: number | null
    clicks_ad: number | null
  }

  export type BanneradsSumAggregateOutputType = {
    id_ad: number | null
    banner_rank: number | null
    visible_ad: number | null
    paid: number | null
    amount: Decimal | null
    views_ad: number | null
    clicks_ad: number | null
  }

  export type BanneradsMinAggregateOutputType = {
    id_ad: number | null
    title_ad: string | null
    descr_ad: string | null
    adcode: string | null
    file_ad: string | null
    topfile_ad: string | null
    url_ad: string | null
    banner_rank: number | null
    addedon_ad: Date | null
    startdate_ad: Date | null
    enddate_ad: Date | null
    daysno_ad: string | null
    width_ad: string | null
    height_ad: string | null
    position_ad: string | null
    banner_status: string | null
    visible_ad: number | null
    userid_ad: string | null
    username_ad: string | null
    paid: number | null
    amount: Decimal | null
    datepaid: Date | null
    remark: string | null
    views_ad: number | null
    clicks_ad: number | null
  }

  export type BanneradsMaxAggregateOutputType = {
    id_ad: number | null
    title_ad: string | null
    descr_ad: string | null
    adcode: string | null
    file_ad: string | null
    topfile_ad: string | null
    url_ad: string | null
    banner_rank: number | null
    addedon_ad: Date | null
    startdate_ad: Date | null
    enddate_ad: Date | null
    daysno_ad: string | null
    width_ad: string | null
    height_ad: string | null
    position_ad: string | null
    banner_status: string | null
    visible_ad: number | null
    userid_ad: string | null
    username_ad: string | null
    paid: number | null
    amount: Decimal | null
    datepaid: Date | null
    remark: string | null
    views_ad: number | null
    clicks_ad: number | null
  }

  export type BanneradsCountAggregateOutputType = {
    id_ad: number
    title_ad: number
    descr_ad: number
    adcode: number
    file_ad: number
    topfile_ad: number
    url_ad: number
    banner_rank: number
    addedon_ad: number
    startdate_ad: number
    enddate_ad: number
    daysno_ad: number
    width_ad: number
    height_ad: number
    position_ad: number
    banner_status: number
    visible_ad: number
    userid_ad: number
    username_ad: number
    paid: number
    amount: number
    datepaid: number
    remark: number
    views_ad: number
    clicks_ad: number
    _all: number
  }


  export type BanneradsAvgAggregateInputType = {
    id_ad?: true
    banner_rank?: true
    visible_ad?: true
    paid?: true
    amount?: true
    views_ad?: true
    clicks_ad?: true
  }

  export type BanneradsSumAggregateInputType = {
    id_ad?: true
    banner_rank?: true
    visible_ad?: true
    paid?: true
    amount?: true
    views_ad?: true
    clicks_ad?: true
  }

  export type BanneradsMinAggregateInputType = {
    id_ad?: true
    title_ad?: true
    descr_ad?: true
    adcode?: true
    file_ad?: true
    topfile_ad?: true
    url_ad?: true
    banner_rank?: true
    addedon_ad?: true
    startdate_ad?: true
    enddate_ad?: true
    daysno_ad?: true
    width_ad?: true
    height_ad?: true
    position_ad?: true
    banner_status?: true
    visible_ad?: true
    userid_ad?: true
    username_ad?: true
    paid?: true
    amount?: true
    datepaid?: true
    remark?: true
    views_ad?: true
    clicks_ad?: true
  }

  export type BanneradsMaxAggregateInputType = {
    id_ad?: true
    title_ad?: true
    descr_ad?: true
    adcode?: true
    file_ad?: true
    topfile_ad?: true
    url_ad?: true
    banner_rank?: true
    addedon_ad?: true
    startdate_ad?: true
    enddate_ad?: true
    daysno_ad?: true
    width_ad?: true
    height_ad?: true
    position_ad?: true
    banner_status?: true
    visible_ad?: true
    userid_ad?: true
    username_ad?: true
    paid?: true
    amount?: true
    datepaid?: true
    remark?: true
    views_ad?: true
    clicks_ad?: true
  }

  export type BanneradsCountAggregateInputType = {
    id_ad?: true
    title_ad?: true
    descr_ad?: true
    adcode?: true
    file_ad?: true
    topfile_ad?: true
    url_ad?: true
    banner_rank?: true
    addedon_ad?: true
    startdate_ad?: true
    enddate_ad?: true
    daysno_ad?: true
    width_ad?: true
    height_ad?: true
    position_ad?: true
    banner_status?: true
    visible_ad?: true
    userid_ad?: true
    username_ad?: true
    paid?: true
    amount?: true
    datepaid?: true
    remark?: true
    views_ad?: true
    clicks_ad?: true
    _all?: true
  }

  export type BanneradsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bannerads to aggregate.
     */
    where?: banneradsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bannerads to fetch.
     */
    orderBy?: banneradsOrderByWithRelationInput | banneradsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banneradsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bannerads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bannerads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bannerads
    **/
    _count?: true | BanneradsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanneradsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanneradsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanneradsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanneradsMaxAggregateInputType
  }

  export type GetBanneradsAggregateType<T extends BanneradsAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerads[P]>
      : GetScalarType<T[P], AggregateBannerads[P]>
  }




  export type banneradsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banneradsWhereInput
    orderBy?: banneradsOrderByWithAggregationInput | banneradsOrderByWithAggregationInput[]
    by: BanneradsScalarFieldEnum[] | BanneradsScalarFieldEnum
    having?: banneradsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanneradsCountAggregateInputType | true
    _avg?: BanneradsAvgAggregateInputType
    _sum?: BanneradsSumAggregateInputType
    _min?: BanneradsMinAggregateInputType
    _max?: BanneradsMaxAggregateInputType
  }

  export type BanneradsGroupByOutputType = {
    id_ad: number
    title_ad: string
    descr_ad: string
    adcode: string
    file_ad: string
    topfile_ad: string | null
    url_ad: string
    banner_rank: number
    addedon_ad: Date
    startdate_ad: Date
    enddate_ad: Date
    daysno_ad: string
    width_ad: string | null
    height_ad: string | null
    position_ad: string
    banner_status: string
    visible_ad: number
    userid_ad: string
    username_ad: string
    paid: number
    amount: Decimal | null
    datepaid: Date | null
    remark: string | null
    views_ad: number
    clicks_ad: number
    _count: BanneradsCountAggregateOutputType | null
    _avg: BanneradsAvgAggregateOutputType | null
    _sum: BanneradsSumAggregateOutputType | null
    _min: BanneradsMinAggregateOutputType | null
    _max: BanneradsMaxAggregateOutputType | null
  }

  type GetBanneradsGroupByPayload<T extends banneradsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanneradsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanneradsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanneradsGroupByOutputType[P]>
            : GetScalarType<T[P], BanneradsGroupByOutputType[P]>
        }
      >
    >


  export type banneradsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ad?: boolean
    title_ad?: boolean
    descr_ad?: boolean
    adcode?: boolean
    file_ad?: boolean
    topfile_ad?: boolean
    url_ad?: boolean
    banner_rank?: boolean
    addedon_ad?: boolean
    startdate_ad?: boolean
    enddate_ad?: boolean
    daysno_ad?: boolean
    width_ad?: boolean
    height_ad?: boolean
    position_ad?: boolean
    banner_status?: boolean
    visible_ad?: boolean
    userid_ad?: boolean
    username_ad?: boolean
    paid?: boolean
    amount?: boolean
    datepaid?: boolean
    remark?: boolean
    views_ad?: boolean
    clicks_ad?: boolean
  }, ExtArgs["result"]["bannerads"]>



  export type banneradsSelectScalar = {
    id_ad?: boolean
    title_ad?: boolean
    descr_ad?: boolean
    adcode?: boolean
    file_ad?: boolean
    topfile_ad?: boolean
    url_ad?: boolean
    banner_rank?: boolean
    addedon_ad?: boolean
    startdate_ad?: boolean
    enddate_ad?: boolean
    daysno_ad?: boolean
    width_ad?: boolean
    height_ad?: boolean
    position_ad?: boolean
    banner_status?: boolean
    visible_ad?: boolean
    userid_ad?: boolean
    username_ad?: boolean
    paid?: boolean
    amount?: boolean
    datepaid?: boolean
    remark?: boolean
    views_ad?: boolean
    clicks_ad?: boolean
  }

  export type banneradsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_ad" | "title_ad" | "descr_ad" | "adcode" | "file_ad" | "topfile_ad" | "url_ad" | "banner_rank" | "addedon_ad" | "startdate_ad" | "enddate_ad" | "daysno_ad" | "width_ad" | "height_ad" | "position_ad" | "banner_status" | "visible_ad" | "userid_ad" | "username_ad" | "paid" | "amount" | "datepaid" | "remark" | "views_ad" | "clicks_ad", ExtArgs["result"]["bannerads"]>

  export type $banneradsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bannerads"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_ad: number
      title_ad: string
      descr_ad: string
      adcode: string
      file_ad: string
      topfile_ad: string | null
      url_ad: string
      banner_rank: number
      addedon_ad: Date
      startdate_ad: Date
      enddate_ad: Date
      daysno_ad: string
      width_ad: string | null
      height_ad: string | null
      position_ad: string
      banner_status: string
      visible_ad: number
      userid_ad: string
      username_ad: string
      paid: number
      amount: Prisma.Decimal | null
      datepaid: Date | null
      remark: string | null
      views_ad: number
      clicks_ad: number
    }, ExtArgs["result"]["bannerads"]>
    composites: {}
  }

  type banneradsGetPayload<S extends boolean | null | undefined | banneradsDefaultArgs> = $Result.GetResult<Prisma.$banneradsPayload, S>

  type banneradsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<banneradsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BanneradsCountAggregateInputType | true
    }

  export interface banneradsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bannerads'], meta: { name: 'bannerads' } }
    /**
     * Find zero or one Bannerads that matches the filter.
     * @param {banneradsFindUniqueArgs} args - Arguments to find a Bannerads
     * @example
     * // Get one Bannerads
     * const bannerads = await prisma.bannerads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends banneradsFindUniqueArgs>(args: SelectSubset<T, banneradsFindUniqueArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bannerads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {banneradsFindUniqueOrThrowArgs} args - Arguments to find a Bannerads
     * @example
     * // Get one Bannerads
     * const bannerads = await prisma.bannerads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends banneradsFindUniqueOrThrowArgs>(args: SelectSubset<T, banneradsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bannerads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsFindFirstArgs} args - Arguments to find a Bannerads
     * @example
     * // Get one Bannerads
     * const bannerads = await prisma.bannerads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends banneradsFindFirstArgs>(args?: SelectSubset<T, banneradsFindFirstArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bannerads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsFindFirstOrThrowArgs} args - Arguments to find a Bannerads
     * @example
     * // Get one Bannerads
     * const bannerads = await prisma.bannerads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends banneradsFindFirstOrThrowArgs>(args?: SelectSubset<T, banneradsFindFirstOrThrowArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bannerads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bannerads
     * const bannerads = await prisma.bannerads.findMany()
     * 
     * // Get first 10 Bannerads
     * const bannerads = await prisma.bannerads.findMany({ take: 10 })
     * 
     * // Only select the `id_ad`
     * const banneradsWithId_adOnly = await prisma.bannerads.findMany({ select: { id_ad: true } })
     * 
     */
    findMany<T extends banneradsFindManyArgs>(args?: SelectSubset<T, banneradsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bannerads.
     * @param {banneradsCreateArgs} args - Arguments to create a Bannerads.
     * @example
     * // Create one Bannerads
     * const Bannerads = await prisma.bannerads.create({
     *   data: {
     *     // ... data to create a Bannerads
     *   }
     * })
     * 
     */
    create<T extends banneradsCreateArgs>(args: SelectSubset<T, banneradsCreateArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bannerads.
     * @param {banneradsCreateManyArgs} args - Arguments to create many Bannerads.
     * @example
     * // Create many Bannerads
     * const bannerads = await prisma.bannerads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends banneradsCreateManyArgs>(args?: SelectSubset<T, banneradsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bannerads.
     * @param {banneradsDeleteArgs} args - Arguments to delete one Bannerads.
     * @example
     * // Delete one Bannerads
     * const Bannerads = await prisma.bannerads.delete({
     *   where: {
     *     // ... filter to delete one Bannerads
     *   }
     * })
     * 
     */
    delete<T extends banneradsDeleteArgs>(args: SelectSubset<T, banneradsDeleteArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bannerads.
     * @param {banneradsUpdateArgs} args - Arguments to update one Bannerads.
     * @example
     * // Update one Bannerads
     * const bannerads = await prisma.bannerads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends banneradsUpdateArgs>(args: SelectSubset<T, banneradsUpdateArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bannerads.
     * @param {banneradsDeleteManyArgs} args - Arguments to filter Bannerads to delete.
     * @example
     * // Delete a few Bannerads
     * const { count } = await prisma.bannerads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends banneradsDeleteManyArgs>(args?: SelectSubset<T, banneradsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bannerads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bannerads
     * const bannerads = await prisma.bannerads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends banneradsUpdateManyArgs>(args: SelectSubset<T, banneradsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bannerads.
     * @param {banneradsUpsertArgs} args - Arguments to update or create a Bannerads.
     * @example
     * // Update or create a Bannerads
     * const bannerads = await prisma.bannerads.upsert({
     *   create: {
     *     // ... data to create a Bannerads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bannerads we want to update
     *   }
     * })
     */
    upsert<T extends banneradsUpsertArgs>(args: SelectSubset<T, banneradsUpsertArgs<ExtArgs>>): Prisma__banneradsClient<$Result.GetResult<Prisma.$banneradsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bannerads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsCountArgs} args - Arguments to filter Bannerads to count.
     * @example
     * // Count the number of Bannerads
     * const count = await prisma.bannerads.count({
     *   where: {
     *     // ... the filter for the Bannerads we want to count
     *   }
     * })
    **/
    count<T extends banneradsCountArgs>(
      args?: Subset<T, banneradsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanneradsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bannerads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanneradsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanneradsAggregateArgs>(args: Subset<T, BanneradsAggregateArgs>): Prisma.PrismaPromise<GetBanneradsAggregateType<T>>

    /**
     * Group by Bannerads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banneradsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banneradsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banneradsGroupByArgs['orderBy'] }
        : { orderBy?: banneradsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banneradsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanneradsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bannerads model
   */
  readonly fields: banneradsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bannerads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banneradsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bannerads model
   */
  interface banneradsFieldRefs {
    readonly id_ad: FieldRef<"bannerads", 'Int'>
    readonly title_ad: FieldRef<"bannerads", 'String'>
    readonly descr_ad: FieldRef<"bannerads", 'String'>
    readonly adcode: FieldRef<"bannerads", 'String'>
    readonly file_ad: FieldRef<"bannerads", 'String'>
    readonly topfile_ad: FieldRef<"bannerads", 'String'>
    readonly url_ad: FieldRef<"bannerads", 'String'>
    readonly banner_rank: FieldRef<"bannerads", 'Int'>
    readonly addedon_ad: FieldRef<"bannerads", 'DateTime'>
    readonly startdate_ad: FieldRef<"bannerads", 'DateTime'>
    readonly enddate_ad: FieldRef<"bannerads", 'DateTime'>
    readonly daysno_ad: FieldRef<"bannerads", 'String'>
    readonly width_ad: FieldRef<"bannerads", 'String'>
    readonly height_ad: FieldRef<"bannerads", 'String'>
    readonly position_ad: FieldRef<"bannerads", 'String'>
    readonly banner_status: FieldRef<"bannerads", 'String'>
    readonly visible_ad: FieldRef<"bannerads", 'Int'>
    readonly userid_ad: FieldRef<"bannerads", 'String'>
    readonly username_ad: FieldRef<"bannerads", 'String'>
    readonly paid: FieldRef<"bannerads", 'Int'>
    readonly amount: FieldRef<"bannerads", 'Decimal'>
    readonly datepaid: FieldRef<"bannerads", 'DateTime'>
    readonly remark: FieldRef<"bannerads", 'String'>
    readonly views_ad: FieldRef<"bannerads", 'Int'>
    readonly clicks_ad: FieldRef<"bannerads", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bannerads findUnique
   */
  export type banneradsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter, which bannerads to fetch.
     */
    where: banneradsWhereUniqueInput
  }

  /**
   * bannerads findUniqueOrThrow
   */
  export type banneradsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter, which bannerads to fetch.
     */
    where: banneradsWhereUniqueInput
  }

  /**
   * bannerads findFirst
   */
  export type banneradsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter, which bannerads to fetch.
     */
    where?: banneradsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bannerads to fetch.
     */
    orderBy?: banneradsOrderByWithRelationInput | banneradsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bannerads.
     */
    cursor?: banneradsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bannerads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bannerads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bannerads.
     */
    distinct?: BanneradsScalarFieldEnum | BanneradsScalarFieldEnum[]
  }

  /**
   * bannerads findFirstOrThrow
   */
  export type banneradsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter, which bannerads to fetch.
     */
    where?: banneradsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bannerads to fetch.
     */
    orderBy?: banneradsOrderByWithRelationInput | banneradsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bannerads.
     */
    cursor?: banneradsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bannerads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bannerads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bannerads.
     */
    distinct?: BanneradsScalarFieldEnum | BanneradsScalarFieldEnum[]
  }

  /**
   * bannerads findMany
   */
  export type banneradsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter, which bannerads to fetch.
     */
    where?: banneradsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bannerads to fetch.
     */
    orderBy?: banneradsOrderByWithRelationInput | banneradsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bannerads.
     */
    cursor?: banneradsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bannerads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bannerads.
     */
    skip?: number
    distinct?: BanneradsScalarFieldEnum | BanneradsScalarFieldEnum[]
  }

  /**
   * bannerads create
   */
  export type banneradsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * The data needed to create a bannerads.
     */
    data: XOR<banneradsCreateInput, banneradsUncheckedCreateInput>
  }

  /**
   * bannerads createMany
   */
  export type banneradsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bannerads.
     */
    data: banneradsCreateManyInput | banneradsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bannerads update
   */
  export type banneradsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * The data needed to update a bannerads.
     */
    data: XOR<banneradsUpdateInput, banneradsUncheckedUpdateInput>
    /**
     * Choose, which bannerads to update.
     */
    where: banneradsWhereUniqueInput
  }

  /**
   * bannerads updateMany
   */
  export type banneradsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bannerads.
     */
    data: XOR<banneradsUpdateManyMutationInput, banneradsUncheckedUpdateManyInput>
    /**
     * Filter which bannerads to update
     */
    where?: banneradsWhereInput
    /**
     * Limit how many bannerads to update.
     */
    limit?: number
  }

  /**
   * bannerads upsert
   */
  export type banneradsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * The filter to search for the bannerads to update in case it exists.
     */
    where: banneradsWhereUniqueInput
    /**
     * In case the bannerads found by the `where` argument doesn't exist, create a new bannerads with this data.
     */
    create: XOR<banneradsCreateInput, banneradsUncheckedCreateInput>
    /**
     * In case the bannerads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banneradsUpdateInput, banneradsUncheckedUpdateInput>
  }

  /**
   * bannerads delete
   */
  export type banneradsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
    /**
     * Filter which bannerads to delete.
     */
    where: banneradsWhereUniqueInput
  }

  /**
   * bannerads deleteMany
   */
  export type banneradsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bannerads to delete
     */
    where?: banneradsWhereInput
    /**
     * Limit how many bannerads to delete.
     */
    limit?: number
  }

  /**
   * bannerads without action
   */
  export type banneradsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bannerads
     */
    select?: banneradsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bannerads
     */
    omit?: banneradsOmit<ExtArgs> | null
  }


  /**
   * Model blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    artid: number | null
    views: number | null
    homepage: number | null
  }

  export type BlogSumAggregateOutputType = {
    artid: number | null
    views: number | null
    homepage: number | null
  }

  export type BlogMinAggregateOutputType = {
    artid: number | null
    artcategory: string | null
    title: string | null
    titleslug: string | null
    brief: string | null
    fullcontent: string | null
    artphoto: string | null
    artphotocaption: string | null
    author: string | null
    artsource: string | null
    artsource_url: string | null
    published_date: Date | null
    artstatus: string | null
    nstatus: string | null
    views: number | null
    artsubmit: Date | null
    artusername: string | null
    youtube_embed: string | null
    vidurl: string | null
    homepage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    artid: number | null
    artcategory: string | null
    title: string | null
    titleslug: string | null
    brief: string | null
    fullcontent: string | null
    artphoto: string | null
    artphotocaption: string | null
    author: string | null
    artsource: string | null
    artsource_url: string | null
    published_date: Date | null
    artstatus: string | null
    nstatus: string | null
    views: number | null
    artsubmit: Date | null
    artusername: string | null
    youtube_embed: string | null
    vidurl: string | null
    homepage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    artid: number
    artcategory: number
    title: number
    titleslug: number
    brief: number
    fullcontent: number
    artphoto: number
    artphotocaption: number
    author: number
    artsource: number
    artsource_url: number
    published_date: number
    artstatus: number
    nstatus: number
    views: number
    artsubmit: number
    artusername: number
    youtube_embed: number
    vidurl: number
    homepage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    artid?: true
    views?: true
    homepage?: true
  }

  export type BlogSumAggregateInputType = {
    artid?: true
    views?: true
    homepage?: true
  }

  export type BlogMinAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    brief?: true
    fullcontent?: true
    artphoto?: true
    artphotocaption?: true
    author?: true
    artsource?: true
    artsource_url?: true
    published_date?: true
    artstatus?: true
    nstatus?: true
    views?: true
    artsubmit?: true
    artusername?: true
    youtube_embed?: true
    vidurl?: true
    homepage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    brief?: true
    fullcontent?: true
    artphoto?: true
    artphotocaption?: true
    author?: true
    artsource?: true
    artsource_url?: true
    published_date?: true
    artstatus?: true
    nstatus?: true
    views?: true
    artsubmit?: true
    artusername?: true
    youtube_embed?: true
    vidurl?: true
    homepage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    brief?: true
    fullcontent?: true
    artphoto?: true
    artphotocaption?: true
    author?: true
    artsource?: true
    artsource_url?: true
    published_date?: true
    artstatus?: true
    nstatus?: true
    views?: true
    artsubmit?: true
    artusername?: true
    youtube_embed?: true
    vidurl?: true
    homepage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blog to aggregate.
     */
    where?: blogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogOrderByWithRelationInput | blogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type blogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogWhereInput
    orderBy?: blogOrderByWithAggregationInput | blogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: blogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    artid: number
    artcategory: string
    title: string
    titleslug: string
    brief: string
    fullcontent: string
    artphoto: string | null
    artphotocaption: string
    author: string | null
    artsource: string | null
    artsource_url: string | null
    published_date: Date
    artstatus: string
    nstatus: string
    views: number
    artsubmit: Date
    artusername: string
    youtube_embed: string | null
    vidurl: string
    homepage: number
    createdAt: Date
    updatedAt: Date
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends blogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type blogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artid?: boolean
    artcategory?: boolean
    title?: boolean
    titleslug?: boolean
    brief?: boolean
    fullcontent?: boolean
    artphoto?: boolean
    artphotocaption?: boolean
    author?: boolean
    artsource?: boolean
    artsource_url?: boolean
    published_date?: boolean
    artstatus?: boolean
    nstatus?: boolean
    views?: boolean
    artsubmit?: boolean
    artusername?: boolean
    youtube_embed?: boolean
    vidurl?: boolean
    homepage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blog"]>



  export type blogSelectScalar = {
    artid?: boolean
    artcategory?: boolean
    title?: boolean
    titleslug?: boolean
    brief?: boolean
    fullcontent?: boolean
    artphoto?: boolean
    artphotocaption?: boolean
    author?: boolean
    artsource?: boolean
    artsource_url?: boolean
    published_date?: boolean
    artstatus?: boolean
    nstatus?: boolean
    views?: boolean
    artsubmit?: boolean
    artusername?: boolean
    youtube_embed?: boolean
    vidurl?: boolean
    homepage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type blogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"artid" | "artcategory" | "title" | "titleslug" | "brief" | "fullcontent" | "artphoto" | "artphotocaption" | "author" | "artsource" | "artsource_url" | "published_date" | "artstatus" | "nstatus" | "views" | "artsubmit" | "artusername" | "youtube_embed" | "vidurl" | "homepage" | "createdAt" | "updatedAt", ExtArgs["result"]["blog"]>

  export type $blogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      artid: number
      artcategory: string
      title: string
      titleslug: string
      brief: string
      fullcontent: string
      artphoto: string | null
      artphotocaption: string
      author: string | null
      artsource: string | null
      artsource_url: string | null
      published_date: Date
      artstatus: string
      nstatus: string
      views: number
      artsubmit: Date
      artusername: string
      youtube_embed: string | null
      vidurl: string
      homepage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type blogGetPayload<S extends boolean | null | undefined | blogDefaultArgs> = $Result.GetResult<Prisma.$blogPayload, S>

  type blogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface blogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blog'], meta: { name: 'blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {blogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blogFindUniqueArgs>(args: SelectSubset<T, blogFindUniqueArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blogFindUniqueOrThrowArgs>(args: SelectSubset<T, blogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blogFindFirstArgs>(args?: SelectSubset<T, blogFindFirstArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blogFindFirstOrThrowArgs>(args?: SelectSubset<T, blogFindFirstOrThrowArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `artid`
     * const blogWithArtidOnly = await prisma.blog.findMany({ select: { artid: true } })
     * 
     */
    findMany<T extends blogFindManyArgs>(args?: SelectSubset<T, blogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {blogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends blogCreateArgs>(args: SelectSubset<T, blogCreateArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {blogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blogCreateManyArgs>(args?: SelectSubset<T, blogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {blogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends blogDeleteArgs>(args: SelectSubset<T, blogDeleteArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {blogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blogUpdateArgs>(args: SelectSubset<T, blogUpdateArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {blogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blogDeleteManyArgs>(args?: SelectSubset<T, blogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blogUpdateManyArgs>(args: SelectSubset<T, blogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {blogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends blogUpsertArgs>(args: SelectSubset<T, blogUpsertArgs<ExtArgs>>): Prisma__blogClient<$Result.GetResult<Prisma.$blogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogCountArgs>(
      args?: Subset<T, blogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blogGroupByArgs['orderBy'] }
        : { orderBy?: blogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blog model
   */
  readonly fields: blogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blog model
   */
  interface blogFieldRefs {
    readonly artid: FieldRef<"blog", 'Int'>
    readonly artcategory: FieldRef<"blog", 'String'>
    readonly title: FieldRef<"blog", 'String'>
    readonly titleslug: FieldRef<"blog", 'String'>
    readonly brief: FieldRef<"blog", 'String'>
    readonly fullcontent: FieldRef<"blog", 'String'>
    readonly artphoto: FieldRef<"blog", 'String'>
    readonly artphotocaption: FieldRef<"blog", 'String'>
    readonly author: FieldRef<"blog", 'String'>
    readonly artsource: FieldRef<"blog", 'String'>
    readonly artsource_url: FieldRef<"blog", 'String'>
    readonly published_date: FieldRef<"blog", 'DateTime'>
    readonly artstatus: FieldRef<"blog", 'String'>
    readonly nstatus: FieldRef<"blog", 'String'>
    readonly views: FieldRef<"blog", 'Int'>
    readonly artsubmit: FieldRef<"blog", 'DateTime'>
    readonly artusername: FieldRef<"blog", 'String'>
    readonly youtube_embed: FieldRef<"blog", 'String'>
    readonly vidurl: FieldRef<"blog", 'String'>
    readonly homepage: FieldRef<"blog", 'Int'>
    readonly createdAt: FieldRef<"blog", 'DateTime'>
    readonly updatedAt: FieldRef<"blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * blog findUnique
   */
  export type blogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter, which blog to fetch.
     */
    where: blogWhereUniqueInput
  }

  /**
   * blog findUniqueOrThrow
   */
  export type blogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter, which blog to fetch.
     */
    where: blogWhereUniqueInput
  }

  /**
   * blog findFirst
   */
  export type blogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter, which blog to fetch.
     */
    where?: blogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogOrderByWithRelationInput | blogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * blog findFirstOrThrow
   */
  export type blogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter, which blog to fetch.
     */
    where?: blogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogOrderByWithRelationInput | blogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * blog findMany
   */
  export type blogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogOrderByWithRelationInput | blogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     */
    cursor?: blogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * blog create
   */
  export type blogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * The data needed to create a blog.
     */
    data: XOR<blogCreateInput, blogUncheckedCreateInput>
  }

  /**
   * blog createMany
   */
  export type blogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blogs.
     */
    data: blogCreateManyInput | blogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blog update
   */
  export type blogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * The data needed to update a blog.
     */
    data: XOR<blogUpdateInput, blogUncheckedUpdateInput>
    /**
     * Choose, which blog to update.
     */
    where: blogWhereUniqueInput
  }

  /**
   * blog updateMany
   */
  export type blogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blogs.
     */
    data: XOR<blogUpdateManyMutationInput, blogUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogWhereInput
    /**
     * Limit how many blogs to update.
     */
    limit?: number
  }

  /**
   * blog upsert
   */
  export type blogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * The filter to search for the blog to update in case it exists.
     */
    where: blogWhereUniqueInput
    /**
     * In case the blog found by the `where` argument doesn't exist, create a new blog with this data.
     */
    create: XOR<blogCreateInput, blogUncheckedCreateInput>
    /**
     * In case the blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogUpdateInput, blogUncheckedUpdateInput>
  }

  /**
   * blog delete
   */
  export type blogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
    /**
     * Filter which blog to delete.
     */
    where: blogWhereUniqueInput
  }

  /**
   * blog deleteMany
   */
  export type blogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to delete
     */
    where?: blogWhereInput
    /**
     * Limit how many blogs to delete.
     */
    limit?: number
  }

  /**
   * blog without action
   */
  export type blogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blog
     */
    select?: blogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blog
     */
    omit?: blogOmit<ExtArgs> | null
  }


  /**
   * Model contentpages
   */

  export type AggregateContentpages = {
    _count: ContentpagesCountAggregateOutputType | null
    _avg: ContentpagesAvgAggregateOutputType | null
    _sum: ContentpagesSumAggregateOutputType | null
    _min: ContentpagesMinAggregateOutputType | null
    _max: ContentpagesMaxAggregateOutputType | null
  }

  export type ContentpagesAvgAggregateOutputType = {
    cpageid: number | null
  }

  export type ContentpagesSumAggregateOutputType = {
    cpageid: number | null
  }

  export type ContentpagesMinAggregateOutputType = {
    cpageid: number | null
    cpagename: string | null
    cpagecontent: string | null
    cpagephoto: string | null
    cpagesbanner: string | null
    cpagemenu: string | null
    cpagelinkname: string | null
    cpage_postedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentpagesMaxAggregateOutputType = {
    cpageid: number | null
    cpagename: string | null
    cpagecontent: string | null
    cpagephoto: string | null
    cpagesbanner: string | null
    cpagemenu: string | null
    cpagelinkname: string | null
    cpage_postedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentpagesCountAggregateOutputType = {
    cpageid: number
    cpagename: number
    cpagecontent: number
    cpagephoto: number
    cpagesbanner: number
    cpagemenu: number
    cpagelinkname: number
    cpage_postedby: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentpagesAvgAggregateInputType = {
    cpageid?: true
  }

  export type ContentpagesSumAggregateInputType = {
    cpageid?: true
  }

  export type ContentpagesMinAggregateInputType = {
    cpageid?: true
    cpagename?: true
    cpagecontent?: true
    cpagephoto?: true
    cpagesbanner?: true
    cpagemenu?: true
    cpagelinkname?: true
    cpage_postedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentpagesMaxAggregateInputType = {
    cpageid?: true
    cpagename?: true
    cpagecontent?: true
    cpagephoto?: true
    cpagesbanner?: true
    cpagemenu?: true
    cpagelinkname?: true
    cpage_postedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentpagesCountAggregateInputType = {
    cpageid?: true
    cpagename?: true
    cpagecontent?: true
    cpagephoto?: true
    cpagesbanner?: true
    cpagemenu?: true
    cpagelinkname?: true
    cpage_postedby?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentpagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contentpages to aggregate.
     */
    where?: contentpagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contentpages to fetch.
     */
    orderBy?: contentpagesOrderByWithRelationInput | contentpagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contentpagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contentpages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contentpages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contentpages
    **/
    _count?: true | ContentpagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentpagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentpagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentpagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentpagesMaxAggregateInputType
  }

  export type GetContentpagesAggregateType<T extends ContentpagesAggregateArgs> = {
        [P in keyof T & keyof AggregateContentpages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentpages[P]>
      : GetScalarType<T[P], AggregateContentpages[P]>
  }




  export type contentpagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contentpagesWhereInput
    orderBy?: contentpagesOrderByWithAggregationInput | contentpagesOrderByWithAggregationInput[]
    by: ContentpagesScalarFieldEnum[] | ContentpagesScalarFieldEnum
    having?: contentpagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentpagesCountAggregateInputType | true
    _avg?: ContentpagesAvgAggregateInputType
    _sum?: ContentpagesSumAggregateInputType
    _min?: ContentpagesMinAggregateInputType
    _max?: ContentpagesMaxAggregateInputType
  }

  export type ContentpagesGroupByOutputType = {
    cpageid: number
    cpagename: string
    cpagecontent: string
    cpagephoto: string | null
    cpagesbanner: string | null
    cpagemenu: string
    cpagelinkname: string
    cpage_postedby: string
    createdAt: Date
    updatedAt: Date
    _count: ContentpagesCountAggregateOutputType | null
    _avg: ContentpagesAvgAggregateOutputType | null
    _sum: ContentpagesSumAggregateOutputType | null
    _min: ContentpagesMinAggregateOutputType | null
    _max: ContentpagesMaxAggregateOutputType | null
  }

  type GetContentpagesGroupByPayload<T extends contentpagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentpagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentpagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentpagesGroupByOutputType[P]>
            : GetScalarType<T[P], ContentpagesGroupByOutputType[P]>
        }
      >
    >


  export type contentpagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpageid?: boolean
    cpagename?: boolean
    cpagecontent?: boolean
    cpagephoto?: boolean
    cpagesbanner?: boolean
    cpagemenu?: boolean
    cpagelinkname?: boolean
    cpage_postedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contentpages"]>



  export type contentpagesSelectScalar = {
    cpageid?: boolean
    cpagename?: boolean
    cpagecontent?: boolean
    cpagephoto?: boolean
    cpagesbanner?: boolean
    cpagemenu?: boolean
    cpagelinkname?: boolean
    cpage_postedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type contentpagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cpageid" | "cpagename" | "cpagecontent" | "cpagephoto" | "cpagesbanner" | "cpagemenu" | "cpagelinkname" | "cpage_postedby" | "createdAt" | "updatedAt", ExtArgs["result"]["contentpages"]>

  export type $contentpagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contentpages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cpageid: number
      cpagename: string
      cpagecontent: string
      cpagephoto: string | null
      cpagesbanner: string | null
      cpagemenu: string
      cpagelinkname: string
      cpage_postedby: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentpages"]>
    composites: {}
  }

  type contentpagesGetPayload<S extends boolean | null | undefined | contentpagesDefaultArgs> = $Result.GetResult<Prisma.$contentpagesPayload, S>

  type contentpagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contentpagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentpagesCountAggregateInputType | true
    }

  export interface contentpagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contentpages'], meta: { name: 'contentpages' } }
    /**
     * Find zero or one Contentpages that matches the filter.
     * @param {contentpagesFindUniqueArgs} args - Arguments to find a Contentpages
     * @example
     * // Get one Contentpages
     * const contentpages = await prisma.contentpages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contentpagesFindUniqueArgs>(args: SelectSubset<T, contentpagesFindUniqueArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contentpages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contentpagesFindUniqueOrThrowArgs} args - Arguments to find a Contentpages
     * @example
     * // Get one Contentpages
     * const contentpages = await prisma.contentpages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contentpagesFindUniqueOrThrowArgs>(args: SelectSubset<T, contentpagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contentpages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesFindFirstArgs} args - Arguments to find a Contentpages
     * @example
     * // Get one Contentpages
     * const contentpages = await prisma.contentpages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contentpagesFindFirstArgs>(args?: SelectSubset<T, contentpagesFindFirstArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contentpages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesFindFirstOrThrowArgs} args - Arguments to find a Contentpages
     * @example
     * // Get one Contentpages
     * const contentpages = await prisma.contentpages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contentpagesFindFirstOrThrowArgs>(args?: SelectSubset<T, contentpagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contentpages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contentpages
     * const contentpages = await prisma.contentpages.findMany()
     * 
     * // Get first 10 Contentpages
     * const contentpages = await prisma.contentpages.findMany({ take: 10 })
     * 
     * // Only select the `cpageid`
     * const contentpagesWithCpageidOnly = await prisma.contentpages.findMany({ select: { cpageid: true } })
     * 
     */
    findMany<T extends contentpagesFindManyArgs>(args?: SelectSubset<T, contentpagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contentpages.
     * @param {contentpagesCreateArgs} args - Arguments to create a Contentpages.
     * @example
     * // Create one Contentpages
     * const Contentpages = await prisma.contentpages.create({
     *   data: {
     *     // ... data to create a Contentpages
     *   }
     * })
     * 
     */
    create<T extends contentpagesCreateArgs>(args: SelectSubset<T, contentpagesCreateArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contentpages.
     * @param {contentpagesCreateManyArgs} args - Arguments to create many Contentpages.
     * @example
     * // Create many Contentpages
     * const contentpages = await prisma.contentpages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contentpagesCreateManyArgs>(args?: SelectSubset<T, contentpagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contentpages.
     * @param {contentpagesDeleteArgs} args - Arguments to delete one Contentpages.
     * @example
     * // Delete one Contentpages
     * const Contentpages = await prisma.contentpages.delete({
     *   where: {
     *     // ... filter to delete one Contentpages
     *   }
     * })
     * 
     */
    delete<T extends contentpagesDeleteArgs>(args: SelectSubset<T, contentpagesDeleteArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contentpages.
     * @param {contentpagesUpdateArgs} args - Arguments to update one Contentpages.
     * @example
     * // Update one Contentpages
     * const contentpages = await prisma.contentpages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contentpagesUpdateArgs>(args: SelectSubset<T, contentpagesUpdateArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contentpages.
     * @param {contentpagesDeleteManyArgs} args - Arguments to filter Contentpages to delete.
     * @example
     * // Delete a few Contentpages
     * const { count } = await prisma.contentpages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contentpagesDeleteManyArgs>(args?: SelectSubset<T, contentpagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contentpages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contentpages
     * const contentpages = await prisma.contentpages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contentpagesUpdateManyArgs>(args: SelectSubset<T, contentpagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contentpages.
     * @param {contentpagesUpsertArgs} args - Arguments to update or create a Contentpages.
     * @example
     * // Update or create a Contentpages
     * const contentpages = await prisma.contentpages.upsert({
     *   create: {
     *     // ... data to create a Contentpages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contentpages we want to update
     *   }
     * })
     */
    upsert<T extends contentpagesUpsertArgs>(args: SelectSubset<T, contentpagesUpsertArgs<ExtArgs>>): Prisma__contentpagesClient<$Result.GetResult<Prisma.$contentpagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contentpages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesCountArgs} args - Arguments to filter Contentpages to count.
     * @example
     * // Count the number of Contentpages
     * const count = await prisma.contentpages.count({
     *   where: {
     *     // ... the filter for the Contentpages we want to count
     *   }
     * })
    **/
    count<T extends contentpagesCountArgs>(
      args?: Subset<T, contentpagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentpagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contentpages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentpagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentpagesAggregateArgs>(args: Subset<T, ContentpagesAggregateArgs>): Prisma.PrismaPromise<GetContentpagesAggregateType<T>>

    /**
     * Group by Contentpages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contentpagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contentpagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contentpagesGroupByArgs['orderBy'] }
        : { orderBy?: contentpagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contentpagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentpagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contentpages model
   */
  readonly fields: contentpagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contentpages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contentpagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contentpages model
   */
  interface contentpagesFieldRefs {
    readonly cpageid: FieldRef<"contentpages", 'Int'>
    readonly cpagename: FieldRef<"contentpages", 'String'>
    readonly cpagecontent: FieldRef<"contentpages", 'String'>
    readonly cpagephoto: FieldRef<"contentpages", 'String'>
    readonly cpagesbanner: FieldRef<"contentpages", 'String'>
    readonly cpagemenu: FieldRef<"contentpages", 'String'>
    readonly cpagelinkname: FieldRef<"contentpages", 'String'>
    readonly cpage_postedby: FieldRef<"contentpages", 'String'>
    readonly createdAt: FieldRef<"contentpages", 'DateTime'>
    readonly updatedAt: FieldRef<"contentpages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contentpages findUnique
   */
  export type contentpagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter, which contentpages to fetch.
     */
    where: contentpagesWhereUniqueInput
  }

  /**
   * contentpages findUniqueOrThrow
   */
  export type contentpagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter, which contentpages to fetch.
     */
    where: contentpagesWhereUniqueInput
  }

  /**
   * contentpages findFirst
   */
  export type contentpagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter, which contentpages to fetch.
     */
    where?: contentpagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contentpages to fetch.
     */
    orderBy?: contentpagesOrderByWithRelationInput | contentpagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contentpages.
     */
    cursor?: contentpagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contentpages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contentpages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contentpages.
     */
    distinct?: ContentpagesScalarFieldEnum | ContentpagesScalarFieldEnum[]
  }

  /**
   * contentpages findFirstOrThrow
   */
  export type contentpagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter, which contentpages to fetch.
     */
    where?: contentpagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contentpages to fetch.
     */
    orderBy?: contentpagesOrderByWithRelationInput | contentpagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contentpages.
     */
    cursor?: contentpagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contentpages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contentpages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contentpages.
     */
    distinct?: ContentpagesScalarFieldEnum | ContentpagesScalarFieldEnum[]
  }

  /**
   * contentpages findMany
   */
  export type contentpagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter, which contentpages to fetch.
     */
    where?: contentpagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contentpages to fetch.
     */
    orderBy?: contentpagesOrderByWithRelationInput | contentpagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contentpages.
     */
    cursor?: contentpagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contentpages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contentpages.
     */
    skip?: number
    distinct?: ContentpagesScalarFieldEnum | ContentpagesScalarFieldEnum[]
  }

  /**
   * contentpages create
   */
  export type contentpagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * The data needed to create a contentpages.
     */
    data: XOR<contentpagesCreateInput, contentpagesUncheckedCreateInput>
  }

  /**
   * contentpages createMany
   */
  export type contentpagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contentpages.
     */
    data: contentpagesCreateManyInput | contentpagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contentpages update
   */
  export type contentpagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * The data needed to update a contentpages.
     */
    data: XOR<contentpagesUpdateInput, contentpagesUncheckedUpdateInput>
    /**
     * Choose, which contentpages to update.
     */
    where: contentpagesWhereUniqueInput
  }

  /**
   * contentpages updateMany
   */
  export type contentpagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contentpages.
     */
    data: XOR<contentpagesUpdateManyMutationInput, contentpagesUncheckedUpdateManyInput>
    /**
     * Filter which contentpages to update
     */
    where?: contentpagesWhereInput
    /**
     * Limit how many contentpages to update.
     */
    limit?: number
  }

  /**
   * contentpages upsert
   */
  export type contentpagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * The filter to search for the contentpages to update in case it exists.
     */
    where: contentpagesWhereUniqueInput
    /**
     * In case the contentpages found by the `where` argument doesn't exist, create a new contentpages with this data.
     */
    create: XOR<contentpagesCreateInput, contentpagesUncheckedCreateInput>
    /**
     * In case the contentpages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contentpagesUpdateInput, contentpagesUncheckedUpdateInput>
  }

  /**
   * contentpages delete
   */
  export type contentpagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
    /**
     * Filter which contentpages to delete.
     */
    where: contentpagesWhereUniqueInput
  }

  /**
   * contentpages deleteMany
   */
  export type contentpagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contentpages to delete
     */
    where?: contentpagesWhereInput
    /**
     * Limit how many contentpages to delete.
     */
    limit?: number
  }

  /**
   * contentpages without action
   */
  export type contentpagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contentpages
     */
    select?: contentpagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contentpages
     */
    omit?: contentpagesOmit<ExtArgs> | null
  }


  /**
   * Model driver_payments
   */

  export type AggregateDriver_payments = {
    _count: Driver_paymentsCountAggregateOutputType | null
    _avg: Driver_paymentsAvgAggregateOutputType | null
    _sum: Driver_paymentsSumAggregateOutputType | null
    _min: Driver_paymentsMinAggregateOutputType | null
    _max: Driver_paymentsMaxAggregateOutputType | null
  }

  export type Driver_paymentsAvgAggregateOutputType = {
    dpayid: number | null
    dpaydriver: number | null
    dpayoutstanding: number | null
  }

  export type Driver_paymentsSumAggregateOutputType = {
    dpayid: number | null
    dpaydriver: number | null
    dpayoutstanding: number | null
  }

  export type Driver_paymentsMinAggregateOutputType = {
    dpayid: number | null
    dpayref: string | null
    dpaydriver: number | null
    dpayoutstanding: number | null
    dpaypaystackref: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Driver_paymentsMaxAggregateOutputType = {
    dpayid: number | null
    dpayref: string | null
    dpaydriver: number | null
    dpayoutstanding: number | null
    dpaypaystackref: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Driver_paymentsCountAggregateOutputType = {
    dpayid: number
    dpayref: number
    dpaydriver: number
    dpayoutstanding: number
    dpaypaystackref: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Driver_paymentsAvgAggregateInputType = {
    dpayid?: true
    dpaydriver?: true
    dpayoutstanding?: true
  }

  export type Driver_paymentsSumAggregateInputType = {
    dpayid?: true
    dpaydriver?: true
    dpayoutstanding?: true
  }

  export type Driver_paymentsMinAggregateInputType = {
    dpayid?: true
    dpayref?: true
    dpaydriver?: true
    dpayoutstanding?: true
    dpaypaystackref?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Driver_paymentsMaxAggregateInputType = {
    dpayid?: true
    dpayref?: true
    dpaydriver?: true
    dpayoutstanding?: true
    dpaypaystackref?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Driver_paymentsCountAggregateInputType = {
    dpayid?: true
    dpayref?: true
    dpaydriver?: true
    dpayoutstanding?: true
    dpaypaystackref?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Driver_paymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which driver_payments to aggregate.
     */
    where?: driver_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driver_payments to fetch.
     */
    orderBy?: driver_paymentsOrderByWithRelationInput | driver_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driver_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driver_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driver_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned driver_payments
    **/
    _count?: true | Driver_paymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Driver_paymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Driver_paymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Driver_paymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Driver_paymentsMaxAggregateInputType
  }

  export type GetDriver_paymentsAggregateType<T extends Driver_paymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver_payments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver_payments[P]>
      : GetScalarType<T[P], AggregateDriver_payments[P]>
  }




  export type driver_paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: driver_paymentsWhereInput
    orderBy?: driver_paymentsOrderByWithAggregationInput | driver_paymentsOrderByWithAggregationInput[]
    by: Driver_paymentsScalarFieldEnum[] | Driver_paymentsScalarFieldEnum
    having?: driver_paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Driver_paymentsCountAggregateInputType | true
    _avg?: Driver_paymentsAvgAggregateInputType
    _sum?: Driver_paymentsSumAggregateInputType
    _min?: Driver_paymentsMinAggregateInputType
    _max?: Driver_paymentsMaxAggregateInputType
  }

  export type Driver_paymentsGroupByOutputType = {
    dpayid: number
    dpayref: string
    dpaydriver: number
    dpayoutstanding: number
    dpaypaystackref: string
    createdAt: Date
    updatedAt: Date
    _count: Driver_paymentsCountAggregateOutputType | null
    _avg: Driver_paymentsAvgAggregateOutputType | null
    _sum: Driver_paymentsSumAggregateOutputType | null
    _min: Driver_paymentsMinAggregateOutputType | null
    _max: Driver_paymentsMaxAggregateOutputType | null
  }

  type GetDriver_paymentsGroupByPayload<T extends driver_paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Driver_paymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Driver_paymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Driver_paymentsGroupByOutputType[P]>
            : GetScalarType<T[P], Driver_paymentsGroupByOutputType[P]>
        }
      >
    >


  export type driver_paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dpayid?: boolean
    dpayref?: boolean
    dpaydriver?: boolean
    dpayoutstanding?: boolean
    dpaypaystackref?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["driver_payments"]>



  export type driver_paymentsSelectScalar = {
    dpayid?: boolean
    dpayref?: boolean
    dpaydriver?: boolean
    dpayoutstanding?: boolean
    dpaypaystackref?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type driver_paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dpayid" | "dpayref" | "dpaydriver" | "dpayoutstanding" | "dpaypaystackref" | "createdAt" | "updatedAt", ExtArgs["result"]["driver_payments"]>

  export type $driver_paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "driver_payments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      dpayid: number
      dpayref: string
      dpaydriver: number
      dpayoutstanding: number
      dpaypaystackref: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driver_payments"]>
    composites: {}
  }

  type driver_paymentsGetPayload<S extends boolean | null | undefined | driver_paymentsDefaultArgs> = $Result.GetResult<Prisma.$driver_paymentsPayload, S>

  type driver_paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<driver_paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Driver_paymentsCountAggregateInputType | true
    }

  export interface driver_paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['driver_payments'], meta: { name: 'driver_payments' } }
    /**
     * Find zero or one Driver_payments that matches the filter.
     * @param {driver_paymentsFindUniqueArgs} args - Arguments to find a Driver_payments
     * @example
     * // Get one Driver_payments
     * const driver_payments = await prisma.driver_payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends driver_paymentsFindUniqueArgs>(args: SelectSubset<T, driver_paymentsFindUniqueArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver_payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {driver_paymentsFindUniqueOrThrowArgs} args - Arguments to find a Driver_payments
     * @example
     * // Get one Driver_payments
     * const driver_payments = await prisma.driver_payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends driver_paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, driver_paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsFindFirstArgs} args - Arguments to find a Driver_payments
     * @example
     * // Get one Driver_payments
     * const driver_payments = await prisma.driver_payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends driver_paymentsFindFirstArgs>(args?: SelectSubset<T, driver_paymentsFindFirstArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver_payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsFindFirstOrThrowArgs} args - Arguments to find a Driver_payments
     * @example
     * // Get one Driver_payments
     * const driver_payments = await prisma.driver_payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends driver_paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, driver_paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Driver_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Driver_payments
     * const driver_payments = await prisma.driver_payments.findMany()
     * 
     * // Get first 10 Driver_payments
     * const driver_payments = await prisma.driver_payments.findMany({ take: 10 })
     * 
     * // Only select the `dpayid`
     * const driver_paymentsWithDpayidOnly = await prisma.driver_payments.findMany({ select: { dpayid: true } })
     * 
     */
    findMany<T extends driver_paymentsFindManyArgs>(args?: SelectSubset<T, driver_paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver_payments.
     * @param {driver_paymentsCreateArgs} args - Arguments to create a Driver_payments.
     * @example
     * // Create one Driver_payments
     * const Driver_payments = await prisma.driver_payments.create({
     *   data: {
     *     // ... data to create a Driver_payments
     *   }
     * })
     * 
     */
    create<T extends driver_paymentsCreateArgs>(args: SelectSubset<T, driver_paymentsCreateArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Driver_payments.
     * @param {driver_paymentsCreateManyArgs} args - Arguments to create many Driver_payments.
     * @example
     * // Create many Driver_payments
     * const driver_payments = await prisma.driver_payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends driver_paymentsCreateManyArgs>(args?: SelectSubset<T, driver_paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Driver_payments.
     * @param {driver_paymentsDeleteArgs} args - Arguments to delete one Driver_payments.
     * @example
     * // Delete one Driver_payments
     * const Driver_payments = await prisma.driver_payments.delete({
     *   where: {
     *     // ... filter to delete one Driver_payments
     *   }
     * })
     * 
     */
    delete<T extends driver_paymentsDeleteArgs>(args: SelectSubset<T, driver_paymentsDeleteArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver_payments.
     * @param {driver_paymentsUpdateArgs} args - Arguments to update one Driver_payments.
     * @example
     * // Update one Driver_payments
     * const driver_payments = await prisma.driver_payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends driver_paymentsUpdateArgs>(args: SelectSubset<T, driver_paymentsUpdateArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Driver_payments.
     * @param {driver_paymentsDeleteManyArgs} args - Arguments to filter Driver_payments to delete.
     * @example
     * // Delete a few Driver_payments
     * const { count } = await prisma.driver_payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends driver_paymentsDeleteManyArgs>(args?: SelectSubset<T, driver_paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Driver_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Driver_payments
     * const driver_payments = await prisma.driver_payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends driver_paymentsUpdateManyArgs>(args: SelectSubset<T, driver_paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver_payments.
     * @param {driver_paymentsUpsertArgs} args - Arguments to update or create a Driver_payments.
     * @example
     * // Update or create a Driver_payments
     * const driver_payments = await prisma.driver_payments.upsert({
     *   create: {
     *     // ... data to create a Driver_payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver_payments we want to update
     *   }
     * })
     */
    upsert<T extends driver_paymentsUpsertArgs>(args: SelectSubset<T, driver_paymentsUpsertArgs<ExtArgs>>): Prisma__driver_paymentsClient<$Result.GetResult<Prisma.$driver_paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Driver_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsCountArgs} args - Arguments to filter Driver_payments to count.
     * @example
     * // Count the number of Driver_payments
     * const count = await prisma.driver_payments.count({
     *   where: {
     *     // ... the filter for the Driver_payments we want to count
     *   }
     * })
    **/
    count<T extends driver_paymentsCountArgs>(
      args?: Subset<T, driver_paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Driver_paymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Driver_paymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Driver_paymentsAggregateArgs>(args: Subset<T, Driver_paymentsAggregateArgs>): Prisma.PrismaPromise<GetDriver_paymentsAggregateType<T>>

    /**
     * Group by Driver_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driver_paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends driver_paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: driver_paymentsGroupByArgs['orderBy'] }
        : { orderBy?: driver_paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, driver_paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriver_paymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the driver_payments model
   */
  readonly fields: driver_paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for driver_payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__driver_paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the driver_payments model
   */
  interface driver_paymentsFieldRefs {
    readonly dpayid: FieldRef<"driver_payments", 'Int'>
    readonly dpayref: FieldRef<"driver_payments", 'String'>
    readonly dpaydriver: FieldRef<"driver_payments", 'Int'>
    readonly dpayoutstanding: FieldRef<"driver_payments", 'Float'>
    readonly dpaypaystackref: FieldRef<"driver_payments", 'String'>
    readonly createdAt: FieldRef<"driver_payments", 'DateTime'>
    readonly updatedAt: FieldRef<"driver_payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * driver_payments findUnique
   */
  export type driver_paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter, which driver_payments to fetch.
     */
    where: driver_paymentsWhereUniqueInput
  }

  /**
   * driver_payments findUniqueOrThrow
   */
  export type driver_paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter, which driver_payments to fetch.
     */
    where: driver_paymentsWhereUniqueInput
  }

  /**
   * driver_payments findFirst
   */
  export type driver_paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter, which driver_payments to fetch.
     */
    where?: driver_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driver_payments to fetch.
     */
    orderBy?: driver_paymentsOrderByWithRelationInput | driver_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for driver_payments.
     */
    cursor?: driver_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driver_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driver_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of driver_payments.
     */
    distinct?: Driver_paymentsScalarFieldEnum | Driver_paymentsScalarFieldEnum[]
  }

  /**
   * driver_payments findFirstOrThrow
   */
  export type driver_paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter, which driver_payments to fetch.
     */
    where?: driver_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driver_payments to fetch.
     */
    orderBy?: driver_paymentsOrderByWithRelationInput | driver_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for driver_payments.
     */
    cursor?: driver_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driver_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driver_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of driver_payments.
     */
    distinct?: Driver_paymentsScalarFieldEnum | Driver_paymentsScalarFieldEnum[]
  }

  /**
   * driver_payments findMany
   */
  export type driver_paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter, which driver_payments to fetch.
     */
    where?: driver_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driver_payments to fetch.
     */
    orderBy?: driver_paymentsOrderByWithRelationInput | driver_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing driver_payments.
     */
    cursor?: driver_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driver_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driver_payments.
     */
    skip?: number
    distinct?: Driver_paymentsScalarFieldEnum | Driver_paymentsScalarFieldEnum[]
  }

  /**
   * driver_payments create
   */
  export type driver_paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * The data needed to create a driver_payments.
     */
    data: XOR<driver_paymentsCreateInput, driver_paymentsUncheckedCreateInput>
  }

  /**
   * driver_payments createMany
   */
  export type driver_paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many driver_payments.
     */
    data: driver_paymentsCreateManyInput | driver_paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * driver_payments update
   */
  export type driver_paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * The data needed to update a driver_payments.
     */
    data: XOR<driver_paymentsUpdateInput, driver_paymentsUncheckedUpdateInput>
    /**
     * Choose, which driver_payments to update.
     */
    where: driver_paymentsWhereUniqueInput
  }

  /**
   * driver_payments updateMany
   */
  export type driver_paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update driver_payments.
     */
    data: XOR<driver_paymentsUpdateManyMutationInput, driver_paymentsUncheckedUpdateManyInput>
    /**
     * Filter which driver_payments to update
     */
    where?: driver_paymentsWhereInput
    /**
     * Limit how many driver_payments to update.
     */
    limit?: number
  }

  /**
   * driver_payments upsert
   */
  export type driver_paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * The filter to search for the driver_payments to update in case it exists.
     */
    where: driver_paymentsWhereUniqueInput
    /**
     * In case the driver_payments found by the `where` argument doesn't exist, create a new driver_payments with this data.
     */
    create: XOR<driver_paymentsCreateInput, driver_paymentsUncheckedCreateInput>
    /**
     * In case the driver_payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driver_paymentsUpdateInput, driver_paymentsUncheckedUpdateInput>
  }

  /**
   * driver_payments delete
   */
  export type driver_paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
    /**
     * Filter which driver_payments to delete.
     */
    where: driver_paymentsWhereUniqueInput
  }

  /**
   * driver_payments deleteMany
   */
  export type driver_paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which driver_payments to delete
     */
    where?: driver_paymentsWhereInput
    /**
     * Limit how many driver_payments to delete.
     */
    limit?: number
  }

  /**
   * driver_payments without action
   */
  export type driver_paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driver_payments
     */
    select?: driver_paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driver_payments
     */
    omit?: driver_paymentsOmit<ExtArgs> | null
  }


  /**
   * Model faqs
   */

  export type AggregateFaqs = {
    _count: FaqsCountAggregateOutputType | null
    _avg: FaqsAvgAggregateOutputType | null
    _sum: FaqsSumAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  export type FaqsAvgAggregateOutputType = {
    faqid: number | null
  }

  export type FaqsSumAggregateOutputType = {
    faqid: number | null
  }

  export type FaqsMinAggregateOutputType = {
    faqid: number | null
    faqcat: string | null
    faqquestion: string | null
    faqanswer: string | null
    faqslug: string | null
    faqpostedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsMaxAggregateOutputType = {
    faqid: number | null
    faqcat: string | null
    faqquestion: string | null
    faqanswer: string | null
    faqslug: string | null
    faqpostedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsCountAggregateOutputType = {
    faqid: number
    faqcat: number
    faqquestion: number
    faqanswer: number
    faqslug: number
    faqpostedby: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FaqsAvgAggregateInputType = {
    faqid?: true
  }

  export type FaqsSumAggregateInputType = {
    faqid?: true
  }

  export type FaqsMinAggregateInputType = {
    faqid?: true
    faqcat?: true
    faqquestion?: true
    faqanswer?: true
    faqslug?: true
    faqpostedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsMaxAggregateInputType = {
    faqid?: true
    faqcat?: true
    faqquestion?: true
    faqanswer?: true
    faqslug?: true
    faqpostedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsCountAggregateInputType = {
    faqid?: true
    faqcat?: true
    faqquestion?: true
    faqanswer?: true
    faqslug?: true
    faqpostedby?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FaqsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to aggregate.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqsMaxAggregateInputType
  }

  export type GetFaqsAggregateType<T extends FaqsAggregateArgs> = {
        [P in keyof T & keyof AggregateFaqs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaqs[P]>
      : GetScalarType<T[P], AggregateFaqs[P]>
  }




  export type faqsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqsWhereInput
    orderBy?: faqsOrderByWithAggregationInput | faqsOrderByWithAggregationInput[]
    by: FaqsScalarFieldEnum[] | FaqsScalarFieldEnum
    having?: faqsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqsCountAggregateInputType | true
    _avg?: FaqsAvgAggregateInputType
    _sum?: FaqsSumAggregateInputType
    _min?: FaqsMinAggregateInputType
    _max?: FaqsMaxAggregateInputType
  }

  export type FaqsGroupByOutputType = {
    faqid: number
    faqcat: string
    faqquestion: string
    faqanswer: string
    faqslug: string
    faqpostedby: string
    createdAt: Date
    updatedAt: Date
    _count: FaqsCountAggregateOutputType | null
    _avg: FaqsAvgAggregateOutputType | null
    _sum: FaqsSumAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  type GetFaqsGroupByPayload<T extends faqsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqsGroupByOutputType[P]>
            : GetScalarType<T[P], FaqsGroupByOutputType[P]>
        }
      >
    >


  export type faqsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    faqid?: boolean
    faqcat?: boolean
    faqquestion?: boolean
    faqanswer?: boolean
    faqslug?: boolean
    faqpostedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faqs"]>



  export type faqsSelectScalar = {
    faqid?: boolean
    faqcat?: boolean
    faqquestion?: boolean
    faqanswer?: boolean
    faqslug?: boolean
    faqpostedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type faqsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"faqid" | "faqcat" | "faqquestion" | "faqanswer" | "faqslug" | "faqpostedby" | "createdAt" | "updatedAt", ExtArgs["result"]["faqs"]>

  export type $faqsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faqs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      faqid: number
      faqcat: string
      faqquestion: string
      faqanswer: string
      faqslug: string
      faqpostedby: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faqs"]>
    composites: {}
  }

  type faqsGetPayload<S extends boolean | null | undefined | faqsDefaultArgs> = $Result.GetResult<Prisma.$faqsPayload, S>

  type faqsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<faqsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqsCountAggregateInputType | true
    }

  export interface faqsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faqs'], meta: { name: 'faqs' } }
    /**
     * Find zero or one Faqs that matches the filter.
     * @param {faqsFindUniqueArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faqsFindUniqueArgs>(args: SelectSubset<T, faqsFindUniqueArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faqs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faqsFindUniqueOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faqsFindUniqueOrThrowArgs>(args: SelectSubset<T, faqsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faqsFindFirstArgs>(args?: SelectSubset<T, faqsFindFirstArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faqsFindFirstOrThrowArgs>(args?: SelectSubset<T, faqsFindFirstOrThrowArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faqs.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faqs.findMany({ take: 10 })
     * 
     * // Only select the `faqid`
     * const faqsWithFaqidOnly = await prisma.faqs.findMany({ select: { faqid: true } })
     * 
     */
    findMany<T extends faqsFindManyArgs>(args?: SelectSubset<T, faqsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faqs.
     * @param {faqsCreateArgs} args - Arguments to create a Faqs.
     * @example
     * // Create one Faqs
     * const Faqs = await prisma.faqs.create({
     *   data: {
     *     // ... data to create a Faqs
     *   }
     * })
     * 
     */
    create<T extends faqsCreateArgs>(args: SelectSubset<T, faqsCreateArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {faqsCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faqs = await prisma.faqs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends faqsCreateManyArgs>(args?: SelectSubset<T, faqsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faqs.
     * @param {faqsDeleteArgs} args - Arguments to delete one Faqs.
     * @example
     * // Delete one Faqs
     * const Faqs = await prisma.faqs.delete({
     *   where: {
     *     // ... filter to delete one Faqs
     *   }
     * })
     * 
     */
    delete<T extends faqsDeleteArgs>(args: SelectSubset<T, faqsDeleteArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faqs.
     * @param {faqsUpdateArgs} args - Arguments to update one Faqs.
     * @example
     * // Update one Faqs
     * const faqs = await prisma.faqs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends faqsUpdateArgs>(args: SelectSubset<T, faqsUpdateArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {faqsDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faqs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends faqsDeleteManyArgs>(args?: SelectSubset<T, faqsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faqs = await prisma.faqs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends faqsUpdateManyArgs>(args: SelectSubset<T, faqsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faqs.
     * @param {faqsUpsertArgs} args - Arguments to update or create a Faqs.
     * @example
     * // Update or create a Faqs
     * const faqs = await prisma.faqs.upsert({
     *   create: {
     *     // ... data to create a Faqs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faqs we want to update
     *   }
     * })
     */
    upsert<T extends faqsUpsertArgs>(args: SelectSubset<T, faqsUpsertArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faqs.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqsCountArgs>(
      args?: Subset<T, faqsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqsAggregateArgs>(args: Subset<T, FaqsAggregateArgs>): Prisma.PrismaPromise<GetFaqsAggregateType<T>>

    /**
     * Group by Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faqsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faqsGroupByArgs['orderBy'] }
        : { orderBy?: faqsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faqsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faqs model
   */
  readonly fields: faqsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faqs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faqsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faqs model
   */
  interface faqsFieldRefs {
    readonly faqid: FieldRef<"faqs", 'Int'>
    readonly faqcat: FieldRef<"faqs", 'String'>
    readonly faqquestion: FieldRef<"faqs", 'String'>
    readonly faqanswer: FieldRef<"faqs", 'String'>
    readonly faqslug: FieldRef<"faqs", 'String'>
    readonly faqpostedby: FieldRef<"faqs", 'String'>
    readonly createdAt: FieldRef<"faqs", 'DateTime'>
    readonly updatedAt: FieldRef<"faqs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * faqs findUnique
   */
  export type faqsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs findUniqueOrThrow
   */
  export type faqsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs findFirst
   */
  export type faqsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs findFirstOrThrow
   */
  export type faqsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs findMany
   */
  export type faqsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs create
   */
  export type faqsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data needed to create a faqs.
     */
    data: XOR<faqsCreateInput, faqsUncheckedCreateInput>
  }

  /**
   * faqs createMany
   */
  export type faqsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faqs.
     */
    data: faqsCreateManyInput | faqsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faqs update
   */
  export type faqsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data needed to update a faqs.
     */
    data: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
    /**
     * Choose, which faqs to update.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs updateMany
   */
  export type faqsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faqs.
     */
    data: XOR<faqsUpdateManyMutationInput, faqsUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqsWhereInput
    /**
     * Limit how many faqs to update.
     */
    limit?: number
  }

  /**
   * faqs upsert
   */
  export type faqsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The filter to search for the faqs to update in case it exists.
     */
    where: faqsWhereUniqueInput
    /**
     * In case the faqs found by the `where` argument doesn't exist, create a new faqs with this data.
     */
    create: XOR<faqsCreateInput, faqsUncheckedCreateInput>
    /**
     * In case the faqs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
  }

  /**
   * faqs delete
   */
  export type faqsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter which faqs to delete.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs deleteMany
   */
  export type faqsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to delete
     */
    where?: faqsWhereInput
    /**
     * Limit how many faqs to delete.
     */
    limit?: number
  }

  /**
   * faqs without action
   */
  export type faqsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
  }


  /**
   * Model loc_states
   */

  export type AggregateLoc_states = {
    _count: Loc_statesCountAggregateOutputType | null
    _avg: Loc_statesAvgAggregateOutputType | null
    _sum: Loc_statesSumAggregateOutputType | null
    _min: Loc_statesMinAggregateOutputType | null
    _max: Loc_statesMaxAggregateOutputType | null
  }

  export type Loc_statesAvgAggregateOutputType = {
    stateid: number | null
  }

  export type Loc_statesSumAggregateOutputType = {
    stateid: number | null
  }

  export type Loc_statesMinAggregateOutputType = {
    stateid: number | null
    state: string | null
  }

  export type Loc_statesMaxAggregateOutputType = {
    stateid: number | null
    state: string | null
  }

  export type Loc_statesCountAggregateOutputType = {
    stateid: number
    state: number
    _all: number
  }


  export type Loc_statesAvgAggregateInputType = {
    stateid?: true
  }

  export type Loc_statesSumAggregateInputType = {
    stateid?: true
  }

  export type Loc_statesMinAggregateInputType = {
    stateid?: true
    state?: true
  }

  export type Loc_statesMaxAggregateInputType = {
    stateid?: true
    state?: true
  }

  export type Loc_statesCountAggregateInputType = {
    stateid?: true
    state?: true
    _all?: true
  }

  export type Loc_statesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loc_states to aggregate.
     */
    where?: loc_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loc_states to fetch.
     */
    orderBy?: loc_statesOrderByWithRelationInput | loc_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loc_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loc_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loc_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loc_states
    **/
    _count?: true | Loc_statesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Loc_statesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Loc_statesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Loc_statesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Loc_statesMaxAggregateInputType
  }

  export type GetLoc_statesAggregateType<T extends Loc_statesAggregateArgs> = {
        [P in keyof T & keyof AggregateLoc_states]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoc_states[P]>
      : GetScalarType<T[P], AggregateLoc_states[P]>
  }




  export type loc_statesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loc_statesWhereInput
    orderBy?: loc_statesOrderByWithAggregationInput | loc_statesOrderByWithAggregationInput[]
    by: Loc_statesScalarFieldEnum[] | Loc_statesScalarFieldEnum
    having?: loc_statesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Loc_statesCountAggregateInputType | true
    _avg?: Loc_statesAvgAggregateInputType
    _sum?: Loc_statesSumAggregateInputType
    _min?: Loc_statesMinAggregateInputType
    _max?: Loc_statesMaxAggregateInputType
  }

  export type Loc_statesGroupByOutputType = {
    stateid: number
    state: string
    _count: Loc_statesCountAggregateOutputType | null
    _avg: Loc_statesAvgAggregateOutputType | null
    _sum: Loc_statesSumAggregateOutputType | null
    _min: Loc_statesMinAggregateOutputType | null
    _max: Loc_statesMaxAggregateOutputType | null
  }

  type GetLoc_statesGroupByPayload<T extends loc_statesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Loc_statesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Loc_statesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Loc_statesGroupByOutputType[P]>
            : GetScalarType<T[P], Loc_statesGroupByOutputType[P]>
        }
      >
    >


  export type loc_statesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stateid?: boolean
    state?: boolean
  }, ExtArgs["result"]["loc_states"]>



  export type loc_statesSelectScalar = {
    stateid?: boolean
    state?: boolean
  }

  export type loc_statesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stateid" | "state", ExtArgs["result"]["loc_states"]>

  export type $loc_statesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "loc_states"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      stateid: number
      state: string
    }, ExtArgs["result"]["loc_states"]>
    composites: {}
  }

  type loc_statesGetPayload<S extends boolean | null | undefined | loc_statesDefaultArgs> = $Result.GetResult<Prisma.$loc_statesPayload, S>

  type loc_statesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loc_statesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Loc_statesCountAggregateInputType | true
    }

  export interface loc_statesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['loc_states'], meta: { name: 'loc_states' } }
    /**
     * Find zero or one Loc_states that matches the filter.
     * @param {loc_statesFindUniqueArgs} args - Arguments to find a Loc_states
     * @example
     * // Get one Loc_states
     * const loc_states = await prisma.loc_states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loc_statesFindUniqueArgs>(args: SelectSubset<T, loc_statesFindUniqueArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loc_states that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loc_statesFindUniqueOrThrowArgs} args - Arguments to find a Loc_states
     * @example
     * // Get one Loc_states
     * const loc_states = await prisma.loc_states.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loc_statesFindUniqueOrThrowArgs>(args: SelectSubset<T, loc_statesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loc_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesFindFirstArgs} args - Arguments to find a Loc_states
     * @example
     * // Get one Loc_states
     * const loc_states = await prisma.loc_states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loc_statesFindFirstArgs>(args?: SelectSubset<T, loc_statesFindFirstArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loc_states that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesFindFirstOrThrowArgs} args - Arguments to find a Loc_states
     * @example
     * // Get one Loc_states
     * const loc_states = await prisma.loc_states.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loc_statesFindFirstOrThrowArgs>(args?: SelectSubset<T, loc_statesFindFirstOrThrowArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loc_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loc_states
     * const loc_states = await prisma.loc_states.findMany()
     * 
     * // Get first 10 Loc_states
     * const loc_states = await prisma.loc_states.findMany({ take: 10 })
     * 
     * // Only select the `stateid`
     * const loc_statesWithStateidOnly = await prisma.loc_states.findMany({ select: { stateid: true } })
     * 
     */
    findMany<T extends loc_statesFindManyArgs>(args?: SelectSubset<T, loc_statesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loc_states.
     * @param {loc_statesCreateArgs} args - Arguments to create a Loc_states.
     * @example
     * // Create one Loc_states
     * const Loc_states = await prisma.loc_states.create({
     *   data: {
     *     // ... data to create a Loc_states
     *   }
     * })
     * 
     */
    create<T extends loc_statesCreateArgs>(args: SelectSubset<T, loc_statesCreateArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loc_states.
     * @param {loc_statesCreateManyArgs} args - Arguments to create many Loc_states.
     * @example
     * // Create many Loc_states
     * const loc_states = await prisma.loc_states.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loc_statesCreateManyArgs>(args?: SelectSubset<T, loc_statesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Loc_states.
     * @param {loc_statesDeleteArgs} args - Arguments to delete one Loc_states.
     * @example
     * // Delete one Loc_states
     * const Loc_states = await prisma.loc_states.delete({
     *   where: {
     *     // ... filter to delete one Loc_states
     *   }
     * })
     * 
     */
    delete<T extends loc_statesDeleteArgs>(args: SelectSubset<T, loc_statesDeleteArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loc_states.
     * @param {loc_statesUpdateArgs} args - Arguments to update one Loc_states.
     * @example
     * // Update one Loc_states
     * const loc_states = await prisma.loc_states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loc_statesUpdateArgs>(args: SelectSubset<T, loc_statesUpdateArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loc_states.
     * @param {loc_statesDeleteManyArgs} args - Arguments to filter Loc_states to delete.
     * @example
     * // Delete a few Loc_states
     * const { count } = await prisma.loc_states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loc_statesDeleteManyArgs>(args?: SelectSubset<T, loc_statesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loc_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loc_states
     * const loc_states = await prisma.loc_states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loc_statesUpdateManyArgs>(args: SelectSubset<T, loc_statesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loc_states.
     * @param {loc_statesUpsertArgs} args - Arguments to update or create a Loc_states.
     * @example
     * // Update or create a Loc_states
     * const loc_states = await prisma.loc_states.upsert({
     *   create: {
     *     // ... data to create a Loc_states
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loc_states we want to update
     *   }
     * })
     */
    upsert<T extends loc_statesUpsertArgs>(args: SelectSubset<T, loc_statesUpsertArgs<ExtArgs>>): Prisma__loc_statesClient<$Result.GetResult<Prisma.$loc_statesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loc_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesCountArgs} args - Arguments to filter Loc_states to count.
     * @example
     * // Count the number of Loc_states
     * const count = await prisma.loc_states.count({
     *   where: {
     *     // ... the filter for the Loc_states we want to count
     *   }
     * })
    **/
    count<T extends loc_statesCountArgs>(
      args?: Subset<T, loc_statesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Loc_statesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loc_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Loc_statesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Loc_statesAggregateArgs>(args: Subset<T, Loc_statesAggregateArgs>): Prisma.PrismaPromise<GetLoc_statesAggregateType<T>>

    /**
     * Group by Loc_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loc_statesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loc_statesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loc_statesGroupByArgs['orderBy'] }
        : { orderBy?: loc_statesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loc_statesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoc_statesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the loc_states model
   */
  readonly fields: loc_statesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for loc_states.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loc_statesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the loc_states model
   */
  interface loc_statesFieldRefs {
    readonly stateid: FieldRef<"loc_states", 'Int'>
    readonly state: FieldRef<"loc_states", 'String'>
  }
    

  // Custom InputTypes
  /**
   * loc_states findUnique
   */
  export type loc_statesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter, which loc_states to fetch.
     */
    where: loc_statesWhereUniqueInput
  }

  /**
   * loc_states findUniqueOrThrow
   */
  export type loc_statesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter, which loc_states to fetch.
     */
    where: loc_statesWhereUniqueInput
  }

  /**
   * loc_states findFirst
   */
  export type loc_statesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter, which loc_states to fetch.
     */
    where?: loc_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loc_states to fetch.
     */
    orderBy?: loc_statesOrderByWithRelationInput | loc_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loc_states.
     */
    cursor?: loc_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loc_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loc_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loc_states.
     */
    distinct?: Loc_statesScalarFieldEnum | Loc_statesScalarFieldEnum[]
  }

  /**
   * loc_states findFirstOrThrow
   */
  export type loc_statesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter, which loc_states to fetch.
     */
    where?: loc_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loc_states to fetch.
     */
    orderBy?: loc_statesOrderByWithRelationInput | loc_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loc_states.
     */
    cursor?: loc_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loc_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loc_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loc_states.
     */
    distinct?: Loc_statesScalarFieldEnum | Loc_statesScalarFieldEnum[]
  }

  /**
   * loc_states findMany
   */
  export type loc_statesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter, which loc_states to fetch.
     */
    where?: loc_statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loc_states to fetch.
     */
    orderBy?: loc_statesOrderByWithRelationInput | loc_statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loc_states.
     */
    cursor?: loc_statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loc_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loc_states.
     */
    skip?: number
    distinct?: Loc_statesScalarFieldEnum | Loc_statesScalarFieldEnum[]
  }

  /**
   * loc_states create
   */
  export type loc_statesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * The data needed to create a loc_states.
     */
    data: XOR<loc_statesCreateInput, loc_statesUncheckedCreateInput>
  }

  /**
   * loc_states createMany
   */
  export type loc_statesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loc_states.
     */
    data: loc_statesCreateManyInput | loc_statesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loc_states update
   */
  export type loc_statesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * The data needed to update a loc_states.
     */
    data: XOR<loc_statesUpdateInput, loc_statesUncheckedUpdateInput>
    /**
     * Choose, which loc_states to update.
     */
    where: loc_statesWhereUniqueInput
  }

  /**
   * loc_states updateMany
   */
  export type loc_statesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loc_states.
     */
    data: XOR<loc_statesUpdateManyMutationInput, loc_statesUncheckedUpdateManyInput>
    /**
     * Filter which loc_states to update
     */
    where?: loc_statesWhereInput
    /**
     * Limit how many loc_states to update.
     */
    limit?: number
  }

  /**
   * loc_states upsert
   */
  export type loc_statesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * The filter to search for the loc_states to update in case it exists.
     */
    where: loc_statesWhereUniqueInput
    /**
     * In case the loc_states found by the `where` argument doesn't exist, create a new loc_states with this data.
     */
    create: XOR<loc_statesCreateInput, loc_statesUncheckedCreateInput>
    /**
     * In case the loc_states was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loc_statesUpdateInput, loc_statesUncheckedUpdateInput>
  }

  /**
   * loc_states delete
   */
  export type loc_statesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
    /**
     * Filter which loc_states to delete.
     */
    where: loc_statesWhereUniqueInput
  }

  /**
   * loc_states deleteMany
   */
  export type loc_statesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loc_states to delete
     */
    where?: loc_statesWhereInput
    /**
     * Limit how many loc_states to delete.
     */
    limit?: number
  }

  /**
   * loc_states without action
   */
  export type loc_statesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loc_states
     */
    select?: loc_statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loc_states
     */
    omit?: loc_statesOmit<ExtArgs> | null
  }


  /**
   * Model media_assets
   */

  export type AggregateMedia_assets = {
    _count: Media_assetsCountAggregateOutputType | null
    _avg: Media_assetsAvgAggregateOutputType | null
    _sum: Media_assetsSumAggregateOutputType | null
    _min: Media_assetsMinAggregateOutputType | null
    _max: Media_assetsMaxAggregateOutputType | null
  }

  export type Media_assetsAvgAggregateOutputType = {
    massetid: number | null
  }

  export type Media_assetsSumAggregateOutputType = {
    massetid: number | null
  }

  export type Media_assetsMinAggregateOutputType = {
    massetid: number | null
    masset: string | null
    massetdate: Date | null
  }

  export type Media_assetsMaxAggregateOutputType = {
    massetid: number | null
    masset: string | null
    massetdate: Date | null
  }

  export type Media_assetsCountAggregateOutputType = {
    massetid: number
    masset: number
    massetdate: number
    _all: number
  }


  export type Media_assetsAvgAggregateInputType = {
    massetid?: true
  }

  export type Media_assetsSumAggregateInputType = {
    massetid?: true
  }

  export type Media_assetsMinAggregateInputType = {
    massetid?: true
    masset?: true
    massetdate?: true
  }

  export type Media_assetsMaxAggregateInputType = {
    massetid?: true
    masset?: true
    massetdate?: true
  }

  export type Media_assetsCountAggregateInputType = {
    massetid?: true
    masset?: true
    massetdate?: true
    _all?: true
  }

  export type Media_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which media_assets to aggregate.
     */
    where?: media_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_assets to fetch.
     */
    orderBy?: media_assetsOrderByWithRelationInput | media_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: media_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned media_assets
    **/
    _count?: true | Media_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Media_assetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Media_assetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Media_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Media_assetsMaxAggregateInputType
  }

  export type GetMedia_assetsAggregateType<T extends Media_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia_assets[P]>
      : GetScalarType<T[P], AggregateMedia_assets[P]>
  }




  export type media_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: media_assetsWhereInput
    orderBy?: media_assetsOrderByWithAggregationInput | media_assetsOrderByWithAggregationInput[]
    by: Media_assetsScalarFieldEnum[] | Media_assetsScalarFieldEnum
    having?: media_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Media_assetsCountAggregateInputType | true
    _avg?: Media_assetsAvgAggregateInputType
    _sum?: Media_assetsSumAggregateInputType
    _min?: Media_assetsMinAggregateInputType
    _max?: Media_assetsMaxAggregateInputType
  }

  export type Media_assetsGroupByOutputType = {
    massetid: number
    masset: string
    massetdate: Date
    _count: Media_assetsCountAggregateOutputType | null
    _avg: Media_assetsAvgAggregateOutputType | null
    _sum: Media_assetsSumAggregateOutputType | null
    _min: Media_assetsMinAggregateOutputType | null
    _max: Media_assetsMaxAggregateOutputType | null
  }

  type GetMedia_assetsGroupByPayload<T extends media_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Media_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Media_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Media_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Media_assetsGroupByOutputType[P]>
        }
      >
    >


  export type media_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    massetid?: boolean
    masset?: boolean
    massetdate?: boolean
  }, ExtArgs["result"]["media_assets"]>



  export type media_assetsSelectScalar = {
    massetid?: boolean
    masset?: boolean
    massetdate?: boolean
  }

  export type media_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"massetid" | "masset" | "massetdate", ExtArgs["result"]["media_assets"]>

  export type $media_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "media_assets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      massetid: number
      masset: string
      massetdate: Date
    }, ExtArgs["result"]["media_assets"]>
    composites: {}
  }

  type media_assetsGetPayload<S extends boolean | null | undefined | media_assetsDefaultArgs> = $Result.GetResult<Prisma.$media_assetsPayload, S>

  type media_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<media_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Media_assetsCountAggregateInputType | true
    }

  export interface media_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['media_assets'], meta: { name: 'media_assets' } }
    /**
     * Find zero or one Media_assets that matches the filter.
     * @param {media_assetsFindUniqueArgs} args - Arguments to find a Media_assets
     * @example
     * // Get one Media_assets
     * const media_assets = await prisma.media_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends media_assetsFindUniqueArgs>(args: SelectSubset<T, media_assetsFindUniqueArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {media_assetsFindUniqueOrThrowArgs} args - Arguments to find a Media_assets
     * @example
     * // Get one Media_assets
     * const media_assets = await prisma.media_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends media_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, media_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsFindFirstArgs} args - Arguments to find a Media_assets
     * @example
     * // Get one Media_assets
     * const media_assets = await prisma.media_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends media_assetsFindFirstArgs>(args?: SelectSubset<T, media_assetsFindFirstArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsFindFirstOrThrowArgs} args - Arguments to find a Media_assets
     * @example
     * // Get one Media_assets
     * const media_assets = await prisma.media_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends media_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, media_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media_assets
     * const media_assets = await prisma.media_assets.findMany()
     * 
     * // Get first 10 Media_assets
     * const media_assets = await prisma.media_assets.findMany({ take: 10 })
     * 
     * // Only select the `massetid`
     * const media_assetsWithMassetidOnly = await prisma.media_assets.findMany({ select: { massetid: true } })
     * 
     */
    findMany<T extends media_assetsFindManyArgs>(args?: SelectSubset<T, media_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media_assets.
     * @param {media_assetsCreateArgs} args - Arguments to create a Media_assets.
     * @example
     * // Create one Media_assets
     * const Media_assets = await prisma.media_assets.create({
     *   data: {
     *     // ... data to create a Media_assets
     *   }
     * })
     * 
     */
    create<T extends media_assetsCreateArgs>(args: SelectSubset<T, media_assetsCreateArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media_assets.
     * @param {media_assetsCreateManyArgs} args - Arguments to create many Media_assets.
     * @example
     * // Create many Media_assets
     * const media_assets = await prisma.media_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends media_assetsCreateManyArgs>(args?: SelectSubset<T, media_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media_assets.
     * @param {media_assetsDeleteArgs} args - Arguments to delete one Media_assets.
     * @example
     * // Delete one Media_assets
     * const Media_assets = await prisma.media_assets.delete({
     *   where: {
     *     // ... filter to delete one Media_assets
     *   }
     * })
     * 
     */
    delete<T extends media_assetsDeleteArgs>(args: SelectSubset<T, media_assetsDeleteArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media_assets.
     * @param {media_assetsUpdateArgs} args - Arguments to update one Media_assets.
     * @example
     * // Update one Media_assets
     * const media_assets = await prisma.media_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends media_assetsUpdateArgs>(args: SelectSubset<T, media_assetsUpdateArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media_assets.
     * @param {media_assetsDeleteManyArgs} args - Arguments to filter Media_assets to delete.
     * @example
     * // Delete a few Media_assets
     * const { count } = await prisma.media_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends media_assetsDeleteManyArgs>(args?: SelectSubset<T, media_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media_assets
     * const media_assets = await prisma.media_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends media_assetsUpdateManyArgs>(args: SelectSubset<T, media_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media_assets.
     * @param {media_assetsUpsertArgs} args - Arguments to update or create a Media_assets.
     * @example
     * // Update or create a Media_assets
     * const media_assets = await prisma.media_assets.upsert({
     *   create: {
     *     // ... data to create a Media_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media_assets we want to update
     *   }
     * })
     */
    upsert<T extends media_assetsUpsertArgs>(args: SelectSubset<T, media_assetsUpsertArgs<ExtArgs>>): Prisma__media_assetsClient<$Result.GetResult<Prisma.$media_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsCountArgs} args - Arguments to filter Media_assets to count.
     * @example
     * // Count the number of Media_assets
     * const count = await prisma.media_assets.count({
     *   where: {
     *     // ... the filter for the Media_assets we want to count
     *   }
     * })
    **/
    count<T extends media_assetsCountArgs>(
      args?: Subset<T, media_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Media_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Media_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Media_assetsAggregateArgs>(args: Subset<T, Media_assetsAggregateArgs>): Prisma.PrismaPromise<GetMedia_assetsAggregateType<T>>

    /**
     * Group by Media_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {media_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends media_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: media_assetsGroupByArgs['orderBy'] }
        : { orderBy?: media_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, media_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedia_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the media_assets model
   */
  readonly fields: media_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for media_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__media_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the media_assets model
   */
  interface media_assetsFieldRefs {
    readonly massetid: FieldRef<"media_assets", 'Int'>
    readonly masset: FieldRef<"media_assets", 'String'>
    readonly massetdate: FieldRef<"media_assets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * media_assets findUnique
   */
  export type media_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter, which media_assets to fetch.
     */
    where: media_assetsWhereUniqueInput
  }

  /**
   * media_assets findUniqueOrThrow
   */
  export type media_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter, which media_assets to fetch.
     */
    where: media_assetsWhereUniqueInput
  }

  /**
   * media_assets findFirst
   */
  export type media_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter, which media_assets to fetch.
     */
    where?: media_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_assets to fetch.
     */
    orderBy?: media_assetsOrderByWithRelationInput | media_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media_assets.
     */
    cursor?: media_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media_assets.
     */
    distinct?: Media_assetsScalarFieldEnum | Media_assetsScalarFieldEnum[]
  }

  /**
   * media_assets findFirstOrThrow
   */
  export type media_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter, which media_assets to fetch.
     */
    where?: media_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_assets to fetch.
     */
    orderBy?: media_assetsOrderByWithRelationInput | media_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for media_assets.
     */
    cursor?: media_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of media_assets.
     */
    distinct?: Media_assetsScalarFieldEnum | Media_assetsScalarFieldEnum[]
  }

  /**
   * media_assets findMany
   */
  export type media_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter, which media_assets to fetch.
     */
    where?: media_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of media_assets to fetch.
     */
    orderBy?: media_assetsOrderByWithRelationInput | media_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing media_assets.
     */
    cursor?: media_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` media_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` media_assets.
     */
    skip?: number
    distinct?: Media_assetsScalarFieldEnum | Media_assetsScalarFieldEnum[]
  }

  /**
   * media_assets create
   */
  export type media_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * The data needed to create a media_assets.
     */
    data: XOR<media_assetsCreateInput, media_assetsUncheckedCreateInput>
  }

  /**
   * media_assets createMany
   */
  export type media_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many media_assets.
     */
    data: media_assetsCreateManyInput | media_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * media_assets update
   */
  export type media_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * The data needed to update a media_assets.
     */
    data: XOR<media_assetsUpdateInput, media_assetsUncheckedUpdateInput>
    /**
     * Choose, which media_assets to update.
     */
    where: media_assetsWhereUniqueInput
  }

  /**
   * media_assets updateMany
   */
  export type media_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update media_assets.
     */
    data: XOR<media_assetsUpdateManyMutationInput, media_assetsUncheckedUpdateManyInput>
    /**
     * Filter which media_assets to update
     */
    where?: media_assetsWhereInput
    /**
     * Limit how many media_assets to update.
     */
    limit?: number
  }

  /**
   * media_assets upsert
   */
  export type media_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * The filter to search for the media_assets to update in case it exists.
     */
    where: media_assetsWhereUniqueInput
    /**
     * In case the media_assets found by the `where` argument doesn't exist, create a new media_assets with this data.
     */
    create: XOR<media_assetsCreateInput, media_assetsUncheckedCreateInput>
    /**
     * In case the media_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<media_assetsUpdateInput, media_assetsUncheckedUpdateInput>
  }

  /**
   * media_assets delete
   */
  export type media_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
    /**
     * Filter which media_assets to delete.
     */
    where: media_assetsWhereUniqueInput
  }

  /**
   * media_assets deleteMany
   */
  export type media_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which media_assets to delete
     */
    where?: media_assetsWhereInput
    /**
     * Limit how many media_assets to delete.
     */
    limit?: number
  }

  /**
   * media_assets without action
   */
  export type media_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the media_assets
     */
    select?: media_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the media_assets
     */
    omit?: media_assetsOmit<ExtArgs> | null
  }


  /**
   * Model newsletter
   */

  export type AggregateNewsletter = {
    _count: NewsletterCountAggregateOutputType | null
    _avg: NewsletterAvgAggregateOutputType | null
    _sum: NewsletterSumAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  export type NewsletterAvgAggregateOutputType = {
    nlid: number | null
    nlstatus: number | null
    nl_received: number | null
    nl_id: number | null
  }

  export type NewsletterSumAggregateOutputType = {
    nlid: number | null
    nlstatus: number | null
    nl_received: number | null
    nl_id: number | null
  }

  export type NewsletterMinAggregateOutputType = {
    nlid: number | null
    nlname: string | null
    nlemail: string | null
    nlstatus: number | null
    nl_received: number | null
    nl_id: number | null
  }

  export type NewsletterMaxAggregateOutputType = {
    nlid: number | null
    nlname: string | null
    nlemail: string | null
    nlstatus: number | null
    nl_received: number | null
    nl_id: number | null
  }

  export type NewsletterCountAggregateOutputType = {
    nlid: number
    nlname: number
    nlemail: number
    nlstatus: number
    nl_received: number
    nl_id: number
    _all: number
  }


  export type NewsletterAvgAggregateInputType = {
    nlid?: true
    nlstatus?: true
    nl_received?: true
    nl_id?: true
  }

  export type NewsletterSumAggregateInputType = {
    nlid?: true
    nlstatus?: true
    nl_received?: true
    nl_id?: true
  }

  export type NewsletterMinAggregateInputType = {
    nlid?: true
    nlname?: true
    nlemail?: true
    nlstatus?: true
    nl_received?: true
    nl_id?: true
  }

  export type NewsletterMaxAggregateInputType = {
    nlid?: true
    nlname?: true
    nlemail?: true
    nlstatus?: true
    nl_received?: true
    nl_id?: true
  }

  export type NewsletterCountAggregateInputType = {
    nlid?: true
    nlname?: true
    nlemail?: true
    nlstatus?: true
    nl_received?: true
    nl_id?: true
    _all?: true
  }

  export type NewsletterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter to aggregate.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletters
    **/
    _count?: true | NewsletterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsletterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsletterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterMaxAggregateInputType
  }

  export type GetNewsletterAggregateType<T extends NewsletterAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter[P]>
      : GetScalarType<T[P], AggregateNewsletter[P]>
  }




  export type newsletterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletterWhereInput
    orderBy?: newsletterOrderByWithAggregationInput | newsletterOrderByWithAggregationInput[]
    by: NewsletterScalarFieldEnum[] | NewsletterScalarFieldEnum
    having?: newsletterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterCountAggregateInputType | true
    _avg?: NewsletterAvgAggregateInputType
    _sum?: NewsletterSumAggregateInputType
    _min?: NewsletterMinAggregateInputType
    _max?: NewsletterMaxAggregateInputType
  }

  export type NewsletterGroupByOutputType = {
    nlid: number
    nlname: string
    nlemail: string
    nlstatus: number
    nl_received: number
    nl_id: number
    _count: NewsletterCountAggregateOutputType | null
    _avg: NewsletterAvgAggregateOutputType | null
    _sum: NewsletterSumAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  type GetNewsletterGroupByPayload<T extends newsletterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
        }
      >
    >


  export type newsletterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nlid?: boolean
    nlname?: boolean
    nlemail?: boolean
    nlstatus?: boolean
    nl_received?: boolean
    nl_id?: boolean
  }, ExtArgs["result"]["newsletter"]>



  export type newsletterSelectScalar = {
    nlid?: boolean
    nlname?: boolean
    nlemail?: boolean
    nlstatus?: boolean
    nl_received?: boolean
    nl_id?: boolean
  }

  export type newsletterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nlid" | "nlname" | "nlemail" | "nlstatus" | "nl_received" | "nl_id", ExtArgs["result"]["newsletter"]>

  export type $newsletterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      nlid: number
      nlname: string
      nlemail: string
      nlstatus: number
      nl_received: number
      nl_id: number
    }, ExtArgs["result"]["newsletter"]>
    composites: {}
  }

  type newsletterGetPayload<S extends boolean | null | undefined | newsletterDefaultArgs> = $Result.GetResult<Prisma.$newsletterPayload, S>

  type newsletterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<newsletterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterCountAggregateInputType | true
    }

  export interface newsletterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter'], meta: { name: 'newsletter' } }
    /**
     * Find zero or one Newsletter that matches the filter.
     * @param {newsletterFindUniqueArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletterFindUniqueArgs>(args: SelectSubset<T, newsletterFindUniqueArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Newsletter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {newsletterFindUniqueOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletterFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindFirstArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletterFindFirstArgs>(args?: SelectSubset<T, newsletterFindFirstArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindFirstOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletterFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletterFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Newsletters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletters
     * const newsletters = await prisma.newsletter.findMany()
     * 
     * // Get first 10 Newsletters
     * const newsletters = await prisma.newsletter.findMany({ take: 10 })
     * 
     * // Only select the `nlid`
     * const newsletterWithNlidOnly = await prisma.newsletter.findMany({ select: { nlid: true } })
     * 
     */
    findMany<T extends newsletterFindManyArgs>(args?: SelectSubset<T, newsletterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Newsletter.
     * @param {newsletterCreateArgs} args - Arguments to create a Newsletter.
     * @example
     * // Create one Newsletter
     * const Newsletter = await prisma.newsletter.create({
     *   data: {
     *     // ... data to create a Newsletter
     *   }
     * })
     * 
     */
    create<T extends newsletterCreateArgs>(args: SelectSubset<T, newsletterCreateArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Newsletters.
     * @param {newsletterCreateManyArgs} args - Arguments to create many Newsletters.
     * @example
     * // Create many Newsletters
     * const newsletter = await prisma.newsletter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletterCreateManyArgs>(args?: SelectSubset<T, newsletterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newsletter.
     * @param {newsletterDeleteArgs} args - Arguments to delete one Newsletter.
     * @example
     * // Delete one Newsletter
     * const Newsletter = await prisma.newsletter.delete({
     *   where: {
     *     // ... filter to delete one Newsletter
     *   }
     * })
     * 
     */
    delete<T extends newsletterDeleteArgs>(args: SelectSubset<T, newsletterDeleteArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Newsletter.
     * @param {newsletterUpdateArgs} args - Arguments to update one Newsletter.
     * @example
     * // Update one Newsletter
     * const newsletter = await prisma.newsletter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletterUpdateArgs>(args: SelectSubset<T, newsletterUpdateArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Newsletters.
     * @param {newsletterDeleteManyArgs} args - Arguments to filter Newsletters to delete.
     * @example
     * // Delete a few Newsletters
     * const { count } = await prisma.newsletter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletterDeleteManyArgs>(args?: SelectSubset<T, newsletterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletters
     * const newsletter = await prisma.newsletter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletterUpdateManyArgs>(args: SelectSubset<T, newsletterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter.
     * @param {newsletterUpsertArgs} args - Arguments to update or create a Newsletter.
     * @example
     * // Update or create a Newsletter
     * const newsletter = await prisma.newsletter.upsert({
     *   create: {
     *     // ... data to create a Newsletter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter we want to update
     *   }
     * })
     */
    upsert<T extends newsletterUpsertArgs>(args: SelectSubset<T, newsletterUpsertArgs<ExtArgs>>): Prisma__newsletterClient<$Result.GetResult<Prisma.$newsletterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterCountArgs} args - Arguments to filter Newsletters to count.
     * @example
     * // Count the number of Newsletters
     * const count = await prisma.newsletter.count({
     *   where: {
     *     // ... the filter for the Newsletters we want to count
     *   }
     * })
    **/
    count<T extends newsletterCountArgs>(
      args?: Subset<T, newsletterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterAggregateArgs>(args: Subset<T, NewsletterAggregateArgs>): Prisma.PrismaPromise<GetNewsletterAggregateType<T>>

    /**
     * Group by Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletterGroupByArgs['orderBy'] }
        : { orderBy?: newsletterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter model
   */
  readonly fields: newsletterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter model
   */
  interface newsletterFieldRefs {
    readonly nlid: FieldRef<"newsletter", 'Int'>
    readonly nlname: FieldRef<"newsletter", 'String'>
    readonly nlemail: FieldRef<"newsletter", 'String'>
    readonly nlstatus: FieldRef<"newsletter", 'Int'>
    readonly nl_received: FieldRef<"newsletter", 'Int'>
    readonly nl_id: FieldRef<"newsletter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * newsletter findUnique
   */
  export type newsletterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter findUniqueOrThrow
   */
  export type newsletterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter findFirst
   */
  export type newsletterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter findFirstOrThrow
   */
  export type newsletterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter, which newsletter to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter findMany
   */
  export type newsletterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter, which newsletters to fetch.
     */
    where?: newsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletters to fetch.
     */
    orderBy?: newsletterOrderByWithRelationInput | newsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletters.
     */
    cursor?: newsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletters.
     */
    skip?: number
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * newsletter create
   */
  export type newsletterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * The data needed to create a newsletter.
     */
    data: XOR<newsletterCreateInput, newsletterUncheckedCreateInput>
  }

  /**
   * newsletter createMany
   */
  export type newsletterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletters.
     */
    data: newsletterCreateManyInput | newsletterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter update
   */
  export type newsletterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * The data needed to update a newsletter.
     */
    data: XOR<newsletterUpdateInput, newsletterUncheckedUpdateInput>
    /**
     * Choose, which newsletter to update.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter updateMany
   */
  export type newsletterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletters.
     */
    data: XOR<newsletterUpdateManyMutationInput, newsletterUncheckedUpdateManyInput>
    /**
     * Filter which newsletters to update
     */
    where?: newsletterWhereInput
    /**
     * Limit how many newsletters to update.
     */
    limit?: number
  }

  /**
   * newsletter upsert
   */
  export type newsletterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * The filter to search for the newsletter to update in case it exists.
     */
    where: newsletterWhereUniqueInput
    /**
     * In case the newsletter found by the `where` argument doesn't exist, create a new newsletter with this data.
     */
    create: XOR<newsletterCreateInput, newsletterUncheckedCreateInput>
    /**
     * In case the newsletter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletterUpdateInput, newsletterUncheckedUpdateInput>
  }

  /**
   * newsletter delete
   */
  export type newsletterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
    /**
     * Filter which newsletter to delete.
     */
    where: newsletterWhereUniqueInput
  }

  /**
   * newsletter deleteMany
   */
  export type newsletterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletters to delete
     */
    where?: newsletterWhereInput
    /**
     * Limit how many newsletters to delete.
     */
    limit?: number
  }

  /**
   * newsletter without action
   */
  export type newsletterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter
     */
    select?: newsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter
     */
    omit?: newsletterOmit<ExtArgs> | null
  }


  /**
   * Model newsletter_body
   */

  export type AggregateNewsletter_body = {
    _count: Newsletter_bodyCountAggregateOutputType | null
    _avg: Newsletter_bodyAvgAggregateOutputType | null
    _sum: Newsletter_bodySumAggregateOutputType | null
    _min: Newsletter_bodyMinAggregateOutputType | null
    _max: Newsletter_bodyMaxAggregateOutputType | null
  }

  export type Newsletter_bodyAvgAggregateOutputType = {
    nlb_id: number | null
  }

  export type Newsletter_bodySumAggregateOutputType = {
    nlb_id: number | null
  }

  export type Newsletter_bodyMinAggregateOutputType = {
    nlb_id: number | null
    nlb_title: string | null
    nlb_story: string | null
    nlb_finished: string | null
    nlb_postedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Newsletter_bodyMaxAggregateOutputType = {
    nlb_id: number | null
    nlb_title: string | null
    nlb_story: string | null
    nlb_finished: string | null
    nlb_postedby: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Newsletter_bodyCountAggregateOutputType = {
    nlb_id: number
    nlb_title: number
    nlb_story: number
    nlb_finished: number
    nlb_postedby: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Newsletter_bodyAvgAggregateInputType = {
    nlb_id?: true
  }

  export type Newsletter_bodySumAggregateInputType = {
    nlb_id?: true
  }

  export type Newsletter_bodyMinAggregateInputType = {
    nlb_id?: true
    nlb_title?: true
    nlb_story?: true
    nlb_finished?: true
    nlb_postedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Newsletter_bodyMaxAggregateInputType = {
    nlb_id?: true
    nlb_title?: true
    nlb_story?: true
    nlb_finished?: true
    nlb_postedby?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Newsletter_bodyCountAggregateInputType = {
    nlb_id?: true
    nlb_title?: true
    nlb_story?: true
    nlb_finished?: true
    nlb_postedby?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Newsletter_bodyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_body to aggregate.
     */
    where?: newsletter_bodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_bodies to fetch.
     */
    orderBy?: newsletter_bodyOrderByWithRelationInput | newsletter_bodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletter_bodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletter_bodies
    **/
    _count?: true | Newsletter_bodyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Newsletter_bodyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Newsletter_bodySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Newsletter_bodyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Newsletter_bodyMaxAggregateInputType
  }

  export type GetNewsletter_bodyAggregateType<T extends Newsletter_bodyAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter_body]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter_body[P]>
      : GetScalarType<T[P], AggregateNewsletter_body[P]>
  }




  export type newsletter_bodyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_bodyWhereInput
    orderBy?: newsletter_bodyOrderByWithAggregationInput | newsletter_bodyOrderByWithAggregationInput[]
    by: Newsletter_bodyScalarFieldEnum[] | Newsletter_bodyScalarFieldEnum
    having?: newsletter_bodyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Newsletter_bodyCountAggregateInputType | true
    _avg?: Newsletter_bodyAvgAggregateInputType
    _sum?: Newsletter_bodySumAggregateInputType
    _min?: Newsletter_bodyMinAggregateInputType
    _max?: Newsletter_bodyMaxAggregateInputType
  }

  export type Newsletter_bodyGroupByOutputType = {
    nlb_id: number
    nlb_title: string
    nlb_story: string
    nlb_finished: string
    nlb_postedby: string
    createdAt: Date
    updatedAt: Date | null
    _count: Newsletter_bodyCountAggregateOutputType | null
    _avg: Newsletter_bodyAvgAggregateOutputType | null
    _sum: Newsletter_bodySumAggregateOutputType | null
    _min: Newsletter_bodyMinAggregateOutputType | null
    _max: Newsletter_bodyMaxAggregateOutputType | null
  }

  type GetNewsletter_bodyGroupByPayload<T extends newsletter_bodyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Newsletter_bodyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Newsletter_bodyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Newsletter_bodyGroupByOutputType[P]>
            : GetScalarType<T[P], Newsletter_bodyGroupByOutputType[P]>
        }
      >
    >


  export type newsletter_bodySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nlb_id?: boolean
    nlb_title?: boolean
    nlb_story?: boolean
    nlb_finished?: boolean
    nlb_postedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletter_body"]>



  export type newsletter_bodySelectScalar = {
    nlb_id?: boolean
    nlb_title?: boolean
    nlb_story?: boolean
    nlb_finished?: boolean
    nlb_postedby?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type newsletter_bodyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nlb_id" | "nlb_title" | "nlb_story" | "nlb_finished" | "nlb_postedby" | "createdAt" | "updatedAt", ExtArgs["result"]["newsletter_body"]>

  export type $newsletter_bodyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter_body"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      nlb_id: number
      nlb_title: string
      nlb_story: string
      nlb_finished: string
      nlb_postedby: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["newsletter_body"]>
    composites: {}
  }

  type newsletter_bodyGetPayload<S extends boolean | null | undefined | newsletter_bodyDefaultArgs> = $Result.GetResult<Prisma.$newsletter_bodyPayload, S>

  type newsletter_bodyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<newsletter_bodyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Newsletter_bodyCountAggregateInputType | true
    }

  export interface newsletter_bodyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter_body'], meta: { name: 'newsletter_body' } }
    /**
     * Find zero or one Newsletter_body that matches the filter.
     * @param {newsletter_bodyFindUniqueArgs} args - Arguments to find a Newsletter_body
     * @example
     * // Get one Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletter_bodyFindUniqueArgs>(args: SelectSubset<T, newsletter_bodyFindUniqueArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Newsletter_body that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {newsletter_bodyFindUniqueOrThrowArgs} args - Arguments to find a Newsletter_body
     * @example
     * // Get one Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletter_bodyFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletter_bodyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter_body that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyFindFirstArgs} args - Arguments to find a Newsletter_body
     * @example
     * // Get one Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletter_bodyFindFirstArgs>(args?: SelectSubset<T, newsletter_bodyFindFirstArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter_body that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyFindFirstOrThrowArgs} args - Arguments to find a Newsletter_body
     * @example
     * // Get one Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletter_bodyFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletter_bodyFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Newsletter_bodies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletter_bodies
     * const newsletter_bodies = await prisma.newsletter_body.findMany()
     * 
     * // Get first 10 Newsletter_bodies
     * const newsletter_bodies = await prisma.newsletter_body.findMany({ take: 10 })
     * 
     * // Only select the `nlb_id`
     * const newsletter_bodyWithNlb_idOnly = await prisma.newsletter_body.findMany({ select: { nlb_id: true } })
     * 
     */
    findMany<T extends newsletter_bodyFindManyArgs>(args?: SelectSubset<T, newsletter_bodyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Newsletter_body.
     * @param {newsletter_bodyCreateArgs} args - Arguments to create a Newsletter_body.
     * @example
     * // Create one Newsletter_body
     * const Newsletter_body = await prisma.newsletter_body.create({
     *   data: {
     *     // ... data to create a Newsletter_body
     *   }
     * })
     * 
     */
    create<T extends newsletter_bodyCreateArgs>(args: SelectSubset<T, newsletter_bodyCreateArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Newsletter_bodies.
     * @param {newsletter_bodyCreateManyArgs} args - Arguments to create many Newsletter_bodies.
     * @example
     * // Create many Newsletter_bodies
     * const newsletter_body = await prisma.newsletter_body.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletter_bodyCreateManyArgs>(args?: SelectSubset<T, newsletter_bodyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newsletter_body.
     * @param {newsletter_bodyDeleteArgs} args - Arguments to delete one Newsletter_body.
     * @example
     * // Delete one Newsletter_body
     * const Newsletter_body = await prisma.newsletter_body.delete({
     *   where: {
     *     // ... filter to delete one Newsletter_body
     *   }
     * })
     * 
     */
    delete<T extends newsletter_bodyDeleteArgs>(args: SelectSubset<T, newsletter_bodyDeleteArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Newsletter_body.
     * @param {newsletter_bodyUpdateArgs} args - Arguments to update one Newsletter_body.
     * @example
     * // Update one Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletter_bodyUpdateArgs>(args: SelectSubset<T, newsletter_bodyUpdateArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Newsletter_bodies.
     * @param {newsletter_bodyDeleteManyArgs} args - Arguments to filter Newsletter_bodies to delete.
     * @example
     * // Delete a few Newsletter_bodies
     * const { count } = await prisma.newsletter_body.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletter_bodyDeleteManyArgs>(args?: SelectSubset<T, newsletter_bodyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletter_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletter_bodies
     * const newsletter_body = await prisma.newsletter_body.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletter_bodyUpdateManyArgs>(args: SelectSubset<T, newsletter_bodyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter_body.
     * @param {newsletter_bodyUpsertArgs} args - Arguments to update or create a Newsletter_body.
     * @example
     * // Update or create a Newsletter_body
     * const newsletter_body = await prisma.newsletter_body.upsert({
     *   create: {
     *     // ... data to create a Newsletter_body
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter_body we want to update
     *   }
     * })
     */
    upsert<T extends newsletter_bodyUpsertArgs>(args: SelectSubset<T, newsletter_bodyUpsertArgs<ExtArgs>>): Prisma__newsletter_bodyClient<$Result.GetResult<Prisma.$newsletter_bodyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Newsletter_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyCountArgs} args - Arguments to filter Newsletter_bodies to count.
     * @example
     * // Count the number of Newsletter_bodies
     * const count = await prisma.newsletter_body.count({
     *   where: {
     *     // ... the filter for the Newsletter_bodies we want to count
     *   }
     * })
    **/
    count<T extends newsletter_bodyCountArgs>(
      args?: Subset<T, newsletter_bodyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Newsletter_bodyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter_body.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Newsletter_bodyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Newsletter_bodyAggregateArgs>(args: Subset<T, Newsletter_bodyAggregateArgs>): Prisma.PrismaPromise<GetNewsletter_bodyAggregateType<T>>

    /**
     * Group by Newsletter_body.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_bodyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletter_bodyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletter_bodyGroupByArgs['orderBy'] }
        : { orderBy?: newsletter_bodyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletter_bodyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletter_bodyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter_body model
   */
  readonly fields: newsletter_bodyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter_body.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletter_bodyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter_body model
   */
  interface newsletter_bodyFieldRefs {
    readonly nlb_id: FieldRef<"newsletter_body", 'Int'>
    readonly nlb_title: FieldRef<"newsletter_body", 'String'>
    readonly nlb_story: FieldRef<"newsletter_body", 'String'>
    readonly nlb_finished: FieldRef<"newsletter_body", 'String'>
    readonly nlb_postedby: FieldRef<"newsletter_body", 'String'>
    readonly createdAt: FieldRef<"newsletter_body", 'DateTime'>
    readonly updatedAt: FieldRef<"newsletter_body", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * newsletter_body findUnique
   */
  export type newsletter_bodyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter, which newsletter_body to fetch.
     */
    where: newsletter_bodyWhereUniqueInput
  }

  /**
   * newsletter_body findUniqueOrThrow
   */
  export type newsletter_bodyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter, which newsletter_body to fetch.
     */
    where: newsletter_bodyWhereUniqueInput
  }

  /**
   * newsletter_body findFirst
   */
  export type newsletter_bodyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter, which newsletter_body to fetch.
     */
    where?: newsletter_bodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_bodies to fetch.
     */
    orderBy?: newsletter_bodyOrderByWithRelationInput | newsletter_bodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_bodies.
     */
    cursor?: newsletter_bodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_bodies.
     */
    distinct?: Newsletter_bodyScalarFieldEnum | Newsletter_bodyScalarFieldEnum[]
  }

  /**
   * newsletter_body findFirstOrThrow
   */
  export type newsletter_bodyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter, which newsletter_body to fetch.
     */
    where?: newsletter_bodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_bodies to fetch.
     */
    orderBy?: newsletter_bodyOrderByWithRelationInput | newsletter_bodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_bodies.
     */
    cursor?: newsletter_bodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_bodies.
     */
    distinct?: Newsletter_bodyScalarFieldEnum | Newsletter_bodyScalarFieldEnum[]
  }

  /**
   * newsletter_body findMany
   */
  export type newsletter_bodyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter, which newsletter_bodies to fetch.
     */
    where?: newsletter_bodyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_bodies to fetch.
     */
    orderBy?: newsletter_bodyOrderByWithRelationInput | newsletter_bodyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletter_bodies.
     */
    cursor?: newsletter_bodyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_bodies.
     */
    skip?: number
    distinct?: Newsletter_bodyScalarFieldEnum | Newsletter_bodyScalarFieldEnum[]
  }

  /**
   * newsletter_body create
   */
  export type newsletter_bodyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * The data needed to create a newsletter_body.
     */
    data: XOR<newsletter_bodyCreateInput, newsletter_bodyUncheckedCreateInput>
  }

  /**
   * newsletter_body createMany
   */
  export type newsletter_bodyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletter_bodies.
     */
    data: newsletter_bodyCreateManyInput | newsletter_bodyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter_body update
   */
  export type newsletter_bodyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * The data needed to update a newsletter_body.
     */
    data: XOR<newsletter_bodyUpdateInput, newsletter_bodyUncheckedUpdateInput>
    /**
     * Choose, which newsletter_body to update.
     */
    where: newsletter_bodyWhereUniqueInput
  }

  /**
   * newsletter_body updateMany
   */
  export type newsletter_bodyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletter_bodies.
     */
    data: XOR<newsletter_bodyUpdateManyMutationInput, newsletter_bodyUncheckedUpdateManyInput>
    /**
     * Filter which newsletter_bodies to update
     */
    where?: newsletter_bodyWhereInput
    /**
     * Limit how many newsletter_bodies to update.
     */
    limit?: number
  }

  /**
   * newsletter_body upsert
   */
  export type newsletter_bodyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * The filter to search for the newsletter_body to update in case it exists.
     */
    where: newsletter_bodyWhereUniqueInput
    /**
     * In case the newsletter_body found by the `where` argument doesn't exist, create a new newsletter_body with this data.
     */
    create: XOR<newsletter_bodyCreateInput, newsletter_bodyUncheckedCreateInput>
    /**
     * In case the newsletter_body was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletter_bodyUpdateInput, newsletter_bodyUncheckedUpdateInput>
  }

  /**
   * newsletter_body delete
   */
  export type newsletter_bodyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
    /**
     * Filter which newsletter_body to delete.
     */
    where: newsletter_bodyWhereUniqueInput
  }

  /**
   * newsletter_body deleteMany
   */
  export type newsletter_bodyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_bodies to delete
     */
    where?: newsletter_bodyWhereInput
    /**
     * Limit how many newsletter_bodies to delete.
     */
    limit?: number
  }

  /**
   * newsletter_body without action
   */
  export type newsletter_bodyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_body
     */
    select?: newsletter_bodySelect<ExtArgs> | null
    /**
     * Omit specific fields from the newsletter_body
     */
    omit?: newsletter_bodyOmit<ExtArgs> | null
  }


  /**
   * Model paystackresponse
   */

  export type AggregatePaystackresponse = {
    _count: PaystackresponseCountAggregateOutputType | null
    _avg: PaystackresponseAvgAggregateOutputType | null
    _sum: PaystackresponseSumAggregateOutputType | null
    _min: PaystackresponseMinAggregateOutputType | null
    _max: PaystackresponseMaxAggregateOutputType | null
  }

  export type PaystackresponseAvgAggregateOutputType = {
    prid: number | null
  }

  export type PaystackresponseSumAggregateOutputType = {
    prid: number | null
  }

  export type PaystackresponseMinAggregateOutputType = {
    prid: number | null
    prbody: string | null
    pracc_number: string | null
    pracc_bank: string | null
    createdAt: Date | null
  }

  export type PaystackresponseMaxAggregateOutputType = {
    prid: number | null
    prbody: string | null
    pracc_number: string | null
    pracc_bank: string | null
    createdAt: Date | null
  }

  export type PaystackresponseCountAggregateOutputType = {
    prid: number
    prbody: number
    pracc_number: number
    pracc_bank: number
    createdAt: number
    _all: number
  }


  export type PaystackresponseAvgAggregateInputType = {
    prid?: true
  }

  export type PaystackresponseSumAggregateInputType = {
    prid?: true
  }

  export type PaystackresponseMinAggregateInputType = {
    prid?: true
    prbody?: true
    pracc_number?: true
    pracc_bank?: true
    createdAt?: true
  }

  export type PaystackresponseMaxAggregateInputType = {
    prid?: true
    prbody?: true
    pracc_number?: true
    pracc_bank?: true
    createdAt?: true
  }

  export type PaystackresponseCountAggregateInputType = {
    prid?: true
    prbody?: true
    pracc_number?: true
    pracc_bank?: true
    createdAt?: true
    _all?: true
  }

  export type PaystackresponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paystackresponse to aggregate.
     */
    where?: paystackresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paystackresponses to fetch.
     */
    orderBy?: paystackresponseOrderByWithRelationInput | paystackresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paystackresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paystackresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paystackresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paystackresponses
    **/
    _count?: true | PaystackresponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaystackresponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaystackresponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaystackresponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaystackresponseMaxAggregateInputType
  }

  export type GetPaystackresponseAggregateType<T extends PaystackresponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePaystackresponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaystackresponse[P]>
      : GetScalarType<T[P], AggregatePaystackresponse[P]>
  }




  export type paystackresponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paystackresponseWhereInput
    orderBy?: paystackresponseOrderByWithAggregationInput | paystackresponseOrderByWithAggregationInput[]
    by: PaystackresponseScalarFieldEnum[] | PaystackresponseScalarFieldEnum
    having?: paystackresponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaystackresponseCountAggregateInputType | true
    _avg?: PaystackresponseAvgAggregateInputType
    _sum?: PaystackresponseSumAggregateInputType
    _min?: PaystackresponseMinAggregateInputType
    _max?: PaystackresponseMaxAggregateInputType
  }

  export type PaystackresponseGroupByOutputType = {
    prid: number
    prbody: string
    pracc_number: string | null
    pracc_bank: string | null
    createdAt: Date
    _count: PaystackresponseCountAggregateOutputType | null
    _avg: PaystackresponseAvgAggregateOutputType | null
    _sum: PaystackresponseSumAggregateOutputType | null
    _min: PaystackresponseMinAggregateOutputType | null
    _max: PaystackresponseMaxAggregateOutputType | null
  }

  type GetPaystackresponseGroupByPayload<T extends paystackresponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaystackresponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaystackresponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaystackresponseGroupByOutputType[P]>
            : GetScalarType<T[P], PaystackresponseGroupByOutputType[P]>
        }
      >
    >


  export type paystackresponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prid?: boolean
    prbody?: boolean
    pracc_number?: boolean
    pracc_bank?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paystackresponse"]>



  export type paystackresponseSelectScalar = {
    prid?: boolean
    prbody?: boolean
    pracc_number?: boolean
    pracc_bank?: boolean
    createdAt?: boolean
  }

  export type paystackresponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"prid" | "prbody" | "pracc_number" | "pracc_bank" | "createdAt", ExtArgs["result"]["paystackresponse"]>

  export type $paystackresponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paystackresponse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      prid: number
      prbody: string
      pracc_number: string | null
      pracc_bank: string | null
      createdAt: Date
    }, ExtArgs["result"]["paystackresponse"]>
    composites: {}
  }

  type paystackresponseGetPayload<S extends boolean | null | undefined | paystackresponseDefaultArgs> = $Result.GetResult<Prisma.$paystackresponsePayload, S>

  type paystackresponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paystackresponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaystackresponseCountAggregateInputType | true
    }

  export interface paystackresponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paystackresponse'], meta: { name: 'paystackresponse' } }
    /**
     * Find zero or one Paystackresponse that matches the filter.
     * @param {paystackresponseFindUniqueArgs} args - Arguments to find a Paystackresponse
     * @example
     * // Get one Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paystackresponseFindUniqueArgs>(args: SelectSubset<T, paystackresponseFindUniqueArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paystackresponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paystackresponseFindUniqueOrThrowArgs} args - Arguments to find a Paystackresponse
     * @example
     * // Get one Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paystackresponseFindUniqueOrThrowArgs>(args: SelectSubset<T, paystackresponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paystackresponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseFindFirstArgs} args - Arguments to find a Paystackresponse
     * @example
     * // Get one Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paystackresponseFindFirstArgs>(args?: SelectSubset<T, paystackresponseFindFirstArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paystackresponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseFindFirstOrThrowArgs} args - Arguments to find a Paystackresponse
     * @example
     * // Get one Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paystackresponseFindFirstOrThrowArgs>(args?: SelectSubset<T, paystackresponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paystackresponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paystackresponses
     * const paystackresponses = await prisma.paystackresponse.findMany()
     * 
     * // Get first 10 Paystackresponses
     * const paystackresponses = await prisma.paystackresponse.findMany({ take: 10 })
     * 
     * // Only select the `prid`
     * const paystackresponseWithPridOnly = await prisma.paystackresponse.findMany({ select: { prid: true } })
     * 
     */
    findMany<T extends paystackresponseFindManyArgs>(args?: SelectSubset<T, paystackresponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paystackresponse.
     * @param {paystackresponseCreateArgs} args - Arguments to create a Paystackresponse.
     * @example
     * // Create one Paystackresponse
     * const Paystackresponse = await prisma.paystackresponse.create({
     *   data: {
     *     // ... data to create a Paystackresponse
     *   }
     * })
     * 
     */
    create<T extends paystackresponseCreateArgs>(args: SelectSubset<T, paystackresponseCreateArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paystackresponses.
     * @param {paystackresponseCreateManyArgs} args - Arguments to create many Paystackresponses.
     * @example
     * // Create many Paystackresponses
     * const paystackresponse = await prisma.paystackresponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paystackresponseCreateManyArgs>(args?: SelectSubset<T, paystackresponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paystackresponse.
     * @param {paystackresponseDeleteArgs} args - Arguments to delete one Paystackresponse.
     * @example
     * // Delete one Paystackresponse
     * const Paystackresponse = await prisma.paystackresponse.delete({
     *   where: {
     *     // ... filter to delete one Paystackresponse
     *   }
     * })
     * 
     */
    delete<T extends paystackresponseDeleteArgs>(args: SelectSubset<T, paystackresponseDeleteArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paystackresponse.
     * @param {paystackresponseUpdateArgs} args - Arguments to update one Paystackresponse.
     * @example
     * // Update one Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paystackresponseUpdateArgs>(args: SelectSubset<T, paystackresponseUpdateArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paystackresponses.
     * @param {paystackresponseDeleteManyArgs} args - Arguments to filter Paystackresponses to delete.
     * @example
     * // Delete a few Paystackresponses
     * const { count } = await prisma.paystackresponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paystackresponseDeleteManyArgs>(args?: SelectSubset<T, paystackresponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paystackresponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paystackresponses
     * const paystackresponse = await prisma.paystackresponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paystackresponseUpdateManyArgs>(args: SelectSubset<T, paystackresponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paystackresponse.
     * @param {paystackresponseUpsertArgs} args - Arguments to update or create a Paystackresponse.
     * @example
     * // Update or create a Paystackresponse
     * const paystackresponse = await prisma.paystackresponse.upsert({
     *   create: {
     *     // ... data to create a Paystackresponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paystackresponse we want to update
     *   }
     * })
     */
    upsert<T extends paystackresponseUpsertArgs>(args: SelectSubset<T, paystackresponseUpsertArgs<ExtArgs>>): Prisma__paystackresponseClient<$Result.GetResult<Prisma.$paystackresponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paystackresponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseCountArgs} args - Arguments to filter Paystackresponses to count.
     * @example
     * // Count the number of Paystackresponses
     * const count = await prisma.paystackresponse.count({
     *   where: {
     *     // ... the filter for the Paystackresponses we want to count
     *   }
     * })
    **/
    count<T extends paystackresponseCountArgs>(
      args?: Subset<T, paystackresponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaystackresponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paystackresponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaystackresponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaystackresponseAggregateArgs>(args: Subset<T, PaystackresponseAggregateArgs>): Prisma.PrismaPromise<GetPaystackresponseAggregateType<T>>

    /**
     * Group by Paystackresponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paystackresponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paystackresponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paystackresponseGroupByArgs['orderBy'] }
        : { orderBy?: paystackresponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paystackresponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaystackresponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paystackresponse model
   */
  readonly fields: paystackresponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paystackresponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paystackresponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paystackresponse model
   */
  interface paystackresponseFieldRefs {
    readonly prid: FieldRef<"paystackresponse", 'Int'>
    readonly prbody: FieldRef<"paystackresponse", 'String'>
    readonly pracc_number: FieldRef<"paystackresponse", 'String'>
    readonly pracc_bank: FieldRef<"paystackresponse", 'String'>
    readonly createdAt: FieldRef<"paystackresponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * paystackresponse findUnique
   */
  export type paystackresponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter, which paystackresponse to fetch.
     */
    where: paystackresponseWhereUniqueInput
  }

  /**
   * paystackresponse findUniqueOrThrow
   */
  export type paystackresponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter, which paystackresponse to fetch.
     */
    where: paystackresponseWhereUniqueInput
  }

  /**
   * paystackresponse findFirst
   */
  export type paystackresponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter, which paystackresponse to fetch.
     */
    where?: paystackresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paystackresponses to fetch.
     */
    orderBy?: paystackresponseOrderByWithRelationInput | paystackresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paystackresponses.
     */
    cursor?: paystackresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paystackresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paystackresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paystackresponses.
     */
    distinct?: PaystackresponseScalarFieldEnum | PaystackresponseScalarFieldEnum[]
  }

  /**
   * paystackresponse findFirstOrThrow
   */
  export type paystackresponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter, which paystackresponse to fetch.
     */
    where?: paystackresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paystackresponses to fetch.
     */
    orderBy?: paystackresponseOrderByWithRelationInput | paystackresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paystackresponses.
     */
    cursor?: paystackresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paystackresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paystackresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paystackresponses.
     */
    distinct?: PaystackresponseScalarFieldEnum | PaystackresponseScalarFieldEnum[]
  }

  /**
   * paystackresponse findMany
   */
  export type paystackresponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter, which paystackresponses to fetch.
     */
    where?: paystackresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paystackresponses to fetch.
     */
    orderBy?: paystackresponseOrderByWithRelationInput | paystackresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paystackresponses.
     */
    cursor?: paystackresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paystackresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paystackresponses.
     */
    skip?: number
    distinct?: PaystackresponseScalarFieldEnum | PaystackresponseScalarFieldEnum[]
  }

  /**
   * paystackresponse create
   */
  export type paystackresponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * The data needed to create a paystackresponse.
     */
    data: XOR<paystackresponseCreateInput, paystackresponseUncheckedCreateInput>
  }

  /**
   * paystackresponse createMany
   */
  export type paystackresponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paystackresponses.
     */
    data: paystackresponseCreateManyInput | paystackresponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paystackresponse update
   */
  export type paystackresponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * The data needed to update a paystackresponse.
     */
    data: XOR<paystackresponseUpdateInput, paystackresponseUncheckedUpdateInput>
    /**
     * Choose, which paystackresponse to update.
     */
    where: paystackresponseWhereUniqueInput
  }

  /**
   * paystackresponse updateMany
   */
  export type paystackresponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paystackresponses.
     */
    data: XOR<paystackresponseUpdateManyMutationInput, paystackresponseUncheckedUpdateManyInput>
    /**
     * Filter which paystackresponses to update
     */
    where?: paystackresponseWhereInput
    /**
     * Limit how many paystackresponses to update.
     */
    limit?: number
  }

  /**
   * paystackresponse upsert
   */
  export type paystackresponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * The filter to search for the paystackresponse to update in case it exists.
     */
    where: paystackresponseWhereUniqueInput
    /**
     * In case the paystackresponse found by the `where` argument doesn't exist, create a new paystackresponse with this data.
     */
    create: XOR<paystackresponseCreateInput, paystackresponseUncheckedCreateInput>
    /**
     * In case the paystackresponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paystackresponseUpdateInput, paystackresponseUncheckedUpdateInput>
  }

  /**
   * paystackresponse delete
   */
  export type paystackresponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
    /**
     * Filter which paystackresponse to delete.
     */
    where: paystackresponseWhereUniqueInput
  }

  /**
   * paystackresponse deleteMany
   */
  export type paystackresponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paystackresponses to delete
     */
    where?: paystackresponseWhereInput
    /**
     * Limit how many paystackresponses to delete.
     */
    limit?: number
  }

  /**
   * paystackresponse without action
   */
  export type paystackresponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paystackresponse
     */
    select?: paystackresponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paystackresponse
     */
    omit?: paystackresponseOmit<ExtArgs> | null
  }


  /**
   * Model productcategories
   */

  export type AggregateProductcategories = {
    _count: ProductcategoriesCountAggregateOutputType | null
    _avg: ProductcategoriesAvgAggregateOutputType | null
    _sum: ProductcategoriesSumAggregateOutputType | null
    _min: ProductcategoriesMinAggregateOutputType | null
    _max: ProductcategoriesMaxAggregateOutputType | null
  }

  export type ProductcategoriesAvgAggregateOutputType = {
    pcid: number | null
  }

  export type ProductcategoriesSumAggregateOutputType = {
    pcid: number | null
  }

  export type ProductcategoriesMinAggregateOutputType = {
    pcid: number | null
    pcatname: string | null
    pcatslug: string | null
    pcatpicture: string | null
    pcatdesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductcategoriesMaxAggregateOutputType = {
    pcid: number | null
    pcatname: string | null
    pcatslug: string | null
    pcatpicture: string | null
    pcatdesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductcategoriesCountAggregateOutputType = {
    pcid: number
    pcatname: number
    pcatslug: number
    pcatpicture: number
    pcatdesc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductcategoriesAvgAggregateInputType = {
    pcid?: true
  }

  export type ProductcategoriesSumAggregateInputType = {
    pcid?: true
  }

  export type ProductcategoriesMinAggregateInputType = {
    pcid?: true
    pcatname?: true
    pcatslug?: true
    pcatpicture?: true
    pcatdesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductcategoriesMaxAggregateInputType = {
    pcid?: true
    pcatname?: true
    pcatslug?: true
    pcatpicture?: true
    pcatdesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductcategoriesCountAggregateInputType = {
    pcid?: true
    pcatname?: true
    pcatslug?: true
    pcatpicture?: true
    pcatdesc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductcategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productcategories to aggregate.
     */
    where?: productcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productcategories to fetch.
     */
    orderBy?: productcategoriesOrderByWithRelationInput | productcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productcategories
    **/
    _count?: true | ProductcategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductcategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductcategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductcategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductcategoriesMaxAggregateInputType
  }

  export type GetProductcategoriesAggregateType<T extends ProductcategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductcategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductcategories[P]>
      : GetScalarType<T[P], AggregateProductcategories[P]>
  }




  export type productcategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productcategoriesWhereInput
    orderBy?: productcategoriesOrderByWithAggregationInput | productcategoriesOrderByWithAggregationInput[]
    by: ProductcategoriesScalarFieldEnum[] | ProductcategoriesScalarFieldEnum
    having?: productcategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductcategoriesCountAggregateInputType | true
    _avg?: ProductcategoriesAvgAggregateInputType
    _sum?: ProductcategoriesSumAggregateInputType
    _min?: ProductcategoriesMinAggregateInputType
    _max?: ProductcategoriesMaxAggregateInputType
  }

  export type ProductcategoriesGroupByOutputType = {
    pcid: number
    pcatname: string
    pcatslug: string
    pcatpicture: string
    pcatdesc: string
    createdAt: Date
    updatedAt: Date
    _count: ProductcategoriesCountAggregateOutputType | null
    _avg: ProductcategoriesAvgAggregateOutputType | null
    _sum: ProductcategoriesSumAggregateOutputType | null
    _min: ProductcategoriesMinAggregateOutputType | null
    _max: ProductcategoriesMaxAggregateOutputType | null
  }

  type GetProductcategoriesGroupByPayload<T extends productcategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductcategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductcategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductcategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], ProductcategoriesGroupByOutputType[P]>
        }
      >
    >


  export type productcategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pcid?: boolean
    pcatname?: boolean
    pcatslug?: boolean
    pcatpicture?: boolean
    pcatdesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productcategories"]>



  export type productcategoriesSelectScalar = {
    pcid?: boolean
    pcatname?: boolean
    pcatslug?: boolean
    pcatpicture?: boolean
    pcatdesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type productcategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pcid" | "pcatname" | "pcatslug" | "pcatpicture" | "pcatdesc" | "createdAt" | "updatedAt", ExtArgs["result"]["productcategories"]>

  export type $productcategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productcategories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pcid: number
      pcatname: string
      pcatslug: string
      pcatpicture: string
      pcatdesc: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productcategories"]>
    composites: {}
  }

  type productcategoriesGetPayload<S extends boolean | null | undefined | productcategoriesDefaultArgs> = $Result.GetResult<Prisma.$productcategoriesPayload, S>

  type productcategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productcategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductcategoriesCountAggregateInputType | true
    }

  export interface productcategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productcategories'], meta: { name: 'productcategories' } }
    /**
     * Find zero or one Productcategories that matches the filter.
     * @param {productcategoriesFindUniqueArgs} args - Arguments to find a Productcategories
     * @example
     * // Get one Productcategories
     * const productcategories = await prisma.productcategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productcategoriesFindUniqueArgs>(args: SelectSubset<T, productcategoriesFindUniqueArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Productcategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productcategoriesFindUniqueOrThrowArgs} args - Arguments to find a Productcategories
     * @example
     * // Get one Productcategories
     * const productcategories = await prisma.productcategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productcategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, productcategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesFindFirstArgs} args - Arguments to find a Productcategories
     * @example
     * // Get one Productcategories
     * const productcategories = await prisma.productcategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productcategoriesFindFirstArgs>(args?: SelectSubset<T, productcategoriesFindFirstArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productcategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesFindFirstOrThrowArgs} args - Arguments to find a Productcategories
     * @example
     * // Get one Productcategories
     * const productcategories = await prisma.productcategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productcategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, productcategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productcategories
     * const productcategories = await prisma.productcategories.findMany()
     * 
     * // Get first 10 Productcategories
     * const productcategories = await prisma.productcategories.findMany({ take: 10 })
     * 
     * // Only select the `pcid`
     * const productcategoriesWithPcidOnly = await prisma.productcategories.findMany({ select: { pcid: true } })
     * 
     */
    findMany<T extends productcategoriesFindManyArgs>(args?: SelectSubset<T, productcategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Productcategories.
     * @param {productcategoriesCreateArgs} args - Arguments to create a Productcategories.
     * @example
     * // Create one Productcategories
     * const Productcategories = await prisma.productcategories.create({
     *   data: {
     *     // ... data to create a Productcategories
     *   }
     * })
     * 
     */
    create<T extends productcategoriesCreateArgs>(args: SelectSubset<T, productcategoriesCreateArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productcategories.
     * @param {productcategoriesCreateManyArgs} args - Arguments to create many Productcategories.
     * @example
     * // Create many Productcategories
     * const productcategories = await prisma.productcategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productcategoriesCreateManyArgs>(args?: SelectSubset<T, productcategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Productcategories.
     * @param {productcategoriesDeleteArgs} args - Arguments to delete one Productcategories.
     * @example
     * // Delete one Productcategories
     * const Productcategories = await prisma.productcategories.delete({
     *   where: {
     *     // ... filter to delete one Productcategories
     *   }
     * })
     * 
     */
    delete<T extends productcategoriesDeleteArgs>(args: SelectSubset<T, productcategoriesDeleteArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Productcategories.
     * @param {productcategoriesUpdateArgs} args - Arguments to update one Productcategories.
     * @example
     * // Update one Productcategories
     * const productcategories = await prisma.productcategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productcategoriesUpdateArgs>(args: SelectSubset<T, productcategoriesUpdateArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productcategories.
     * @param {productcategoriesDeleteManyArgs} args - Arguments to filter Productcategories to delete.
     * @example
     * // Delete a few Productcategories
     * const { count } = await prisma.productcategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productcategoriesDeleteManyArgs>(args?: SelectSubset<T, productcategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productcategories
     * const productcategories = await prisma.productcategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productcategoriesUpdateManyArgs>(args: SelectSubset<T, productcategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Productcategories.
     * @param {productcategoriesUpsertArgs} args - Arguments to update or create a Productcategories.
     * @example
     * // Update or create a Productcategories
     * const productcategories = await prisma.productcategories.upsert({
     *   create: {
     *     // ... data to create a Productcategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productcategories we want to update
     *   }
     * })
     */
    upsert<T extends productcategoriesUpsertArgs>(args: SelectSubset<T, productcategoriesUpsertArgs<ExtArgs>>): Prisma__productcategoriesClient<$Result.GetResult<Prisma.$productcategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesCountArgs} args - Arguments to filter Productcategories to count.
     * @example
     * // Count the number of Productcategories
     * const count = await prisma.productcategories.count({
     *   where: {
     *     // ... the filter for the Productcategories we want to count
     *   }
     * })
    **/
    count<T extends productcategoriesCountArgs>(
      args?: Subset<T, productcategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductcategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductcategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductcategoriesAggregateArgs>(args: Subset<T, ProductcategoriesAggregateArgs>): Prisma.PrismaPromise<GetProductcategoriesAggregateType<T>>

    /**
     * Group by Productcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productcategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productcategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productcategoriesGroupByArgs['orderBy'] }
        : { orderBy?: productcategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productcategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductcategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productcategories model
   */
  readonly fields: productcategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productcategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productcategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productcategories model
   */
  interface productcategoriesFieldRefs {
    readonly pcid: FieldRef<"productcategories", 'Int'>
    readonly pcatname: FieldRef<"productcategories", 'String'>
    readonly pcatslug: FieldRef<"productcategories", 'String'>
    readonly pcatpicture: FieldRef<"productcategories", 'String'>
    readonly pcatdesc: FieldRef<"productcategories", 'String'>
    readonly createdAt: FieldRef<"productcategories", 'DateTime'>
    readonly updatedAt: FieldRef<"productcategories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * productcategories findUnique
   */
  export type productcategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter, which productcategories to fetch.
     */
    where: productcategoriesWhereUniqueInput
  }

  /**
   * productcategories findUniqueOrThrow
   */
  export type productcategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter, which productcategories to fetch.
     */
    where: productcategoriesWhereUniqueInput
  }

  /**
   * productcategories findFirst
   */
  export type productcategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter, which productcategories to fetch.
     */
    where?: productcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productcategories to fetch.
     */
    orderBy?: productcategoriesOrderByWithRelationInput | productcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productcategories.
     */
    cursor?: productcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productcategories.
     */
    distinct?: ProductcategoriesScalarFieldEnum | ProductcategoriesScalarFieldEnum[]
  }

  /**
   * productcategories findFirstOrThrow
   */
  export type productcategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter, which productcategories to fetch.
     */
    where?: productcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productcategories to fetch.
     */
    orderBy?: productcategoriesOrderByWithRelationInput | productcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productcategories.
     */
    cursor?: productcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productcategories.
     */
    distinct?: ProductcategoriesScalarFieldEnum | ProductcategoriesScalarFieldEnum[]
  }

  /**
   * productcategories findMany
   */
  export type productcategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter, which productcategories to fetch.
     */
    where?: productcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productcategories to fetch.
     */
    orderBy?: productcategoriesOrderByWithRelationInput | productcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productcategories.
     */
    cursor?: productcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productcategories.
     */
    skip?: number
    distinct?: ProductcategoriesScalarFieldEnum | ProductcategoriesScalarFieldEnum[]
  }

  /**
   * productcategories create
   */
  export type productcategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a productcategories.
     */
    data: XOR<productcategoriesCreateInput, productcategoriesUncheckedCreateInput>
  }

  /**
   * productcategories createMany
   */
  export type productcategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productcategories.
     */
    data: productcategoriesCreateManyInput | productcategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productcategories update
   */
  export type productcategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a productcategories.
     */
    data: XOR<productcategoriesUpdateInput, productcategoriesUncheckedUpdateInput>
    /**
     * Choose, which productcategories to update.
     */
    where: productcategoriesWhereUniqueInput
  }

  /**
   * productcategories updateMany
   */
  export type productcategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productcategories.
     */
    data: XOR<productcategoriesUpdateManyMutationInput, productcategoriesUncheckedUpdateManyInput>
    /**
     * Filter which productcategories to update
     */
    where?: productcategoriesWhereInput
    /**
     * Limit how many productcategories to update.
     */
    limit?: number
  }

  /**
   * productcategories upsert
   */
  export type productcategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the productcategories to update in case it exists.
     */
    where: productcategoriesWhereUniqueInput
    /**
     * In case the productcategories found by the `where` argument doesn't exist, create a new productcategories with this data.
     */
    create: XOR<productcategoriesCreateInput, productcategoriesUncheckedCreateInput>
    /**
     * In case the productcategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productcategoriesUpdateInput, productcategoriesUncheckedUpdateInput>
  }

  /**
   * productcategories delete
   */
  export type productcategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
    /**
     * Filter which productcategories to delete.
     */
    where: productcategoriesWhereUniqueInput
  }

  /**
   * productcategories deleteMany
   */
  export type productcategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productcategories to delete
     */
    where?: productcategoriesWhereInput
    /**
     * Limit how many productcategories to delete.
     */
    limit?: number
  }

  /**
   * productcategories without action
   */
  export type productcategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productcategories
     */
    select?: productcategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productcategories
     */
    omit?: productcategoriesOmit<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    category: string | null
    catslug: string | null
    uuid: string | null
    name: string | null
    nameslug: string | null
    sku: string | null
    description: string | null
    picture: string | null
    price: number | null
    size: string | null
    response_time: string | null
    status: boolean | null
    payment_account: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    category: string | null
    catslug: string | null
    uuid: string | null
    name: string | null
    nameslug: string | null
    sku: string | null
    description: string | null
    picture: string | null
    price: number | null
    size: string | null
    response_time: string | null
    status: boolean | null
    payment_account: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    category: number
    catslug: number
    uuid: number
    name: number
    nameslug: number
    sku: number
    description: number
    picture: number
    price: number
    size: number
    response_time: number
    status: number
    payment_account: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    category?: true
    catslug?: true
    uuid?: true
    name?: true
    nameslug?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    response_time?: true
    status?: true
    payment_account?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    category?: true
    catslug?: true
    uuid?: true
    name?: true
    nameslug?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    response_time?: true
    status?: true
    payment_account?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    category?: true
    catslug?: true
    uuid?: true
    name?: true
    nameslug?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    response_time?: true
    status?: true
    payment_account?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    category: string
    catslug: string
    uuid: string | null
    name: string
    nameslug: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    response_time: string | null
    status: boolean
    payment_account: string
    createdAt: Date
    updatedAt: Date
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    catslug?: boolean
    uuid?: boolean
    name?: boolean
    nameslug?: boolean
    sku?: boolean
    description?: boolean
    picture?: boolean
    price?: boolean
    size?: boolean
    response_time?: boolean
    status?: boolean
    payment_account?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["products"]>



  export type productsSelectScalar = {
    id?: boolean
    category?: boolean
    catslug?: boolean
    uuid?: boolean
    name?: boolean
    nameslug?: boolean
    sku?: boolean
    description?: boolean
    picture?: boolean
    price?: boolean
    size?: boolean
    response_time?: boolean
    status?: boolean
    payment_account?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "catslug" | "uuid" | "name" | "nameslug" | "sku" | "description" | "picture" | "price" | "size" | "response_time" | "status" | "payment_account" | "createdAt" | "updatedAt", ExtArgs["result"]["products"]>

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      catslug: string
      uuid: string | null
      name: string
      nameslug: string
      sku: string
      description: string
      picture: string
      price: number
      size: string
      response_time: string | null
      status: boolean
      payment_account: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'Int'>
    readonly category: FieldRef<"products", 'String'>
    readonly catslug: FieldRef<"products", 'String'>
    readonly uuid: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly nameslug: FieldRef<"products", 'String'>
    readonly sku: FieldRef<"products", 'String'>
    readonly description: FieldRef<"products", 'String'>
    readonly picture: FieldRef<"products", 'String'>
    readonly price: FieldRef<"products", 'Float'>
    readonly size: FieldRef<"products", 'String'>
    readonly response_time: FieldRef<"products", 'String'>
    readonly status: FieldRef<"products", 'Boolean'>
    readonly payment_account: FieldRef<"products", 'String'>
    readonly createdAt: FieldRef<"products", 'DateTime'>
    readonly updatedAt: FieldRef<"products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
  }


  /**
   * Model requests
   */

  export type AggregateRequests = {
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  export type RequestsAvgAggregateOutputType = {
    id: number | null
    orderid: number | null
    howmany: number | null
    productid: number | null
    prod_waittime: number | null
    amount: number | null
    commission: number | null
    customerid: number | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    driverid: number | null
    views: number | null
  }

  export type RequestsSumAggregateOutputType = {
    id: number | null
    orderid: number | null
    howmany: number | null
    productid: number | null
    prod_waittime: number | null
    amount: number | null
    commission: number | null
    customerid: number | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    driverid: number | null
    views: number | null
  }

  export type RequestsMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: number | null
    orderref: string | null
    orderdetails: string | null
    req_type: string | null
    task: string | null
    howmany: number | null
    productid: number | null
    productname: string | null
    prod_waittime: number | null
    amount: number | null
    commission: number | null
    customerid: number | null
    customername: string | null
    customerphone: string | null
    customeraddress: string | null
    customerarea: string | null
    customerareagroup: string | null
    third_party_delivery: string | null
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    address: string | null
    driverid: number | null
    drivername: string | null
    driverphone: string | null
    driveremail: string | null
    drivervehicleplateno: string | null
    status: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestsMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: number | null
    orderref: string | null
    orderdetails: string | null
    req_type: string | null
    task: string | null
    howmany: number | null
    productid: number | null
    productname: string | null
    prod_waittime: number | null
    amount: number | null
    commission: number | null
    customerid: number | null
    customername: string | null
    customerphone: string | null
    customeraddress: string | null
    customerarea: string | null
    customerareagroup: string | null
    third_party_delivery: string | null
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    address: string | null
    driverid: number | null
    drivername: string | null
    driverphone: string | null
    driveremail: string | null
    drivervehicleplateno: string | null
    status: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestsCountAggregateOutputType = {
    id: number
    uuid: number
    orderid: number
    orderref: number
    orderdetails: number
    req_type: number
    task: number
    howmany: number
    productid: number
    productname: number
    prod_waittime: number
    amount: number
    commission: number
    customerid: number
    customername: number
    customerphone: number
    customeraddress: number
    customerarea: number
    customerareagroup: number
    third_party_delivery: number
    third_party_name: number
    third_party_phone: number
    third_party_areagroup: number
    third_party_address: number
    customerlatitude: number
    customerlongitude: number
    address: number
    driverid: number
    drivername: number
    driverphone: number
    driveremail: number
    drivervehicleplateno: number
    status: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestsAvgAggregateInputType = {
    id?: true
    orderid?: true
    howmany?: true
    productid?: true
    prod_waittime?: true
    amount?: true
    commission?: true
    customerid?: true
    customerlatitude?: true
    customerlongitude?: true
    driverid?: true
    views?: true
  }

  export type RequestsSumAggregateInputType = {
    id?: true
    orderid?: true
    howmany?: true
    productid?: true
    prod_waittime?: true
    amount?: true
    commission?: true
    customerid?: true
    customerlatitude?: true
    customerlongitude?: true
    driverid?: true
    views?: true
  }

  export type RequestsMinAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    orderref?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    amount?: true
    commission?: true
    customerid?: true
    customername?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    address?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestsMaxAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    orderref?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    amount?: true
    commission?: true
    customerid?: true
    customername?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    address?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestsCountAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    orderref?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    amount?: true
    commission?: true
    customerid?: true
    customername?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    address?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    status?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requests to aggregate.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requests
    **/
    _count?: true | RequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestsMaxAggregateInputType
  }

  export type GetRequestsAggregateType<T extends RequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequests[P]>
      : GetScalarType<T[P], AggregateRequests[P]>
  }




  export type requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requestsWhereInput
    orderBy?: requestsOrderByWithAggregationInput | requestsOrderByWithAggregationInput[]
    by: RequestsScalarFieldEnum[] | RequestsScalarFieldEnum
    having?: requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestsCountAggregateInputType | true
    _avg?: RequestsAvgAggregateInputType
    _sum?: RequestsSumAggregateInputType
    _min?: RequestsMinAggregateInputType
    _max?: RequestsMaxAggregateInputType
  }

  export type RequestsGroupByOutputType = {
    id: number
    uuid: string | null
    orderid: number
    orderref: string
    orderdetails: string
    req_type: string
    task: string | null
    howmany: number | null
    productid: number
    productname: string
    prod_waittime: number | null
    amount: number
    commission: number
    customerid: number
    customername: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup: string | null
    third_party_delivery: string
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal
    customerlongitude: Decimal
    address: string | null
    driverid: number | null
    drivername: string | null
    driverphone: string | null
    driveremail: string | null
    drivervehicleplateno: string | null
    status: string
    views: number
    createdAt: Date
    updatedAt: Date
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  type GetRequestsGroupByPayload<T extends requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestsGroupByOutputType[P]>
        }
      >
    >


  export type requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    orderref?: boolean
    orderdetails?: boolean
    req_type?: boolean
    task?: boolean
    howmany?: boolean
    productid?: boolean
    productname?: boolean
    prod_waittime?: boolean
    amount?: boolean
    commission?: boolean
    customerid?: boolean
    customername?: boolean
    customerphone?: boolean
    customeraddress?: boolean
    customerarea?: boolean
    customerareagroup?: boolean
    third_party_delivery?: boolean
    third_party_name?: boolean
    third_party_phone?: boolean
    third_party_areagroup?: boolean
    third_party_address?: boolean
    customerlatitude?: boolean
    customerlongitude?: boolean
    address?: boolean
    driverid?: boolean
    drivername?: boolean
    driverphone?: boolean
    driveremail?: boolean
    drivervehicleplateno?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["requests"]>



  export type requestsSelectScalar = {
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    orderref?: boolean
    orderdetails?: boolean
    req_type?: boolean
    task?: boolean
    howmany?: boolean
    productid?: boolean
    productname?: boolean
    prod_waittime?: boolean
    amount?: boolean
    commission?: boolean
    customerid?: boolean
    customername?: boolean
    customerphone?: boolean
    customeraddress?: boolean
    customerarea?: boolean
    customerareagroup?: boolean
    third_party_delivery?: boolean
    third_party_name?: boolean
    third_party_phone?: boolean
    third_party_areagroup?: boolean
    third_party_address?: boolean
    customerlatitude?: boolean
    customerlongitude?: boolean
    address?: boolean
    driverid?: boolean
    drivername?: boolean
    driverphone?: boolean
    driveremail?: boolean
    drivervehicleplateno?: boolean
    status?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "orderid" | "orderref" | "orderdetails" | "req_type" | "task" | "howmany" | "productid" | "productname" | "prod_waittime" | "amount" | "commission" | "customerid" | "customername" | "customerphone" | "customeraddress" | "customerarea" | "customerareagroup" | "third_party_delivery" | "third_party_name" | "third_party_phone" | "third_party_areagroup" | "third_party_address" | "customerlatitude" | "customerlongitude" | "address" | "driverid" | "drivername" | "driverphone" | "driveremail" | "drivervehicleplateno" | "status" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["requests"]>

  export type $requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      orderid: number
      orderref: string
      orderdetails: string
      req_type: string
      task: string | null
      howmany: number | null
      productid: number
      productname: string
      prod_waittime: number | null
      amount: number
      commission: number
      customerid: number
      customername: string
      customerphone: string
      customeraddress: string
      customerarea: string
      customerareagroup: string | null
      third_party_delivery: string
      third_party_name: string | null
      third_party_phone: string | null
      third_party_areagroup: string | null
      third_party_address: string | null
      customerlatitude: Prisma.Decimal
      customerlongitude: Prisma.Decimal
      address: string | null
      driverid: number | null
      drivername: string | null
      driverphone: string | null
      driveremail: string | null
      drivervehicleplateno: string | null
      status: string
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requests"]>
    composites: {}
  }

  type requestsGetPayload<S extends boolean | null | undefined | requestsDefaultArgs> = $Result.GetResult<Prisma.$requestsPayload, S>

  type requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestsCountAggregateInputType | true
    }

  export interface requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requests'], meta: { name: 'requests' } }
    /**
     * Find zero or one Requests that matches the filter.
     * @param {requestsFindUniqueArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requestsFindUniqueArgs>(args: SelectSubset<T, requestsFindUniqueArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requestsFindUniqueOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindFirstArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requestsFindFirstArgs>(args?: SelectSubset<T, requestsFindFirstArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindFirstOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.requests.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestsWithIdOnly = await prisma.requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requestsFindManyArgs>(args?: SelectSubset<T, requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requests.
     * @param {requestsCreateArgs} args - Arguments to create a Requests.
     * @example
     * // Create one Requests
     * const Requests = await prisma.requests.create({
     *   data: {
     *     // ... data to create a Requests
     *   }
     * })
     * 
     */
    create<T extends requestsCreateArgs>(args: SelectSubset<T, requestsCreateArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {requestsCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const requests = await prisma.requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requestsCreateManyArgs>(args?: SelectSubset<T, requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Requests.
     * @param {requestsDeleteArgs} args - Arguments to delete one Requests.
     * @example
     * // Delete one Requests
     * const Requests = await prisma.requests.delete({
     *   where: {
     *     // ... filter to delete one Requests
     *   }
     * })
     * 
     */
    delete<T extends requestsDeleteArgs>(args: SelectSubset<T, requestsDeleteArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requests.
     * @param {requestsUpdateArgs} args - Arguments to update one Requests.
     * @example
     * // Update one Requests
     * const requests = await prisma.requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requestsUpdateArgs>(args: SelectSubset<T, requestsUpdateArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {requestsDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requestsDeleteManyArgs>(args?: SelectSubset<T, requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const requests = await prisma.requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requestsUpdateManyArgs>(args: SelectSubset<T, requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Requests.
     * @param {requestsUpsertArgs} args - Arguments to update or create a Requests.
     * @example
     * // Update or create a Requests
     * const requests = await prisma.requests.upsert({
     *   create: {
     *     // ... data to create a Requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requests we want to update
     *   }
     * })
     */
    upsert<T extends requestsUpsertArgs>(args: SelectSubset<T, requestsUpsertArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.requests.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends requestsCountArgs>(
      args?: Subset<T, requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestsAggregateArgs>(args: Subset<T, RequestsAggregateArgs>): Prisma.PrismaPromise<GetRequestsAggregateType<T>>

    /**
     * Group by Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requestsGroupByArgs['orderBy'] }
        : { orderBy?: requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requests model
   */
  readonly fields: requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requests model
   */
  interface requestsFieldRefs {
    readonly id: FieldRef<"requests", 'Int'>
    readonly uuid: FieldRef<"requests", 'String'>
    readonly orderid: FieldRef<"requests", 'Int'>
    readonly orderref: FieldRef<"requests", 'String'>
    readonly orderdetails: FieldRef<"requests", 'String'>
    readonly req_type: FieldRef<"requests", 'String'>
    readonly task: FieldRef<"requests", 'String'>
    readonly howmany: FieldRef<"requests", 'Int'>
    readonly productid: FieldRef<"requests", 'Int'>
    readonly productname: FieldRef<"requests", 'String'>
    readonly prod_waittime: FieldRef<"requests", 'Int'>
    readonly amount: FieldRef<"requests", 'Float'>
    readonly commission: FieldRef<"requests", 'Float'>
    readonly customerid: FieldRef<"requests", 'Int'>
    readonly customername: FieldRef<"requests", 'String'>
    readonly customerphone: FieldRef<"requests", 'String'>
    readonly customeraddress: FieldRef<"requests", 'String'>
    readonly customerarea: FieldRef<"requests", 'String'>
    readonly customerareagroup: FieldRef<"requests", 'String'>
    readonly third_party_delivery: FieldRef<"requests", 'String'>
    readonly third_party_name: FieldRef<"requests", 'String'>
    readonly third_party_phone: FieldRef<"requests", 'String'>
    readonly third_party_areagroup: FieldRef<"requests", 'String'>
    readonly third_party_address: FieldRef<"requests", 'String'>
    readonly customerlatitude: FieldRef<"requests", 'Decimal'>
    readonly customerlongitude: FieldRef<"requests", 'Decimal'>
    readonly address: FieldRef<"requests", 'String'>
    readonly driverid: FieldRef<"requests", 'Int'>
    readonly drivername: FieldRef<"requests", 'String'>
    readonly driverphone: FieldRef<"requests", 'String'>
    readonly driveremail: FieldRef<"requests", 'String'>
    readonly drivervehicleplateno: FieldRef<"requests", 'String'>
    readonly status: FieldRef<"requests", 'String'>
    readonly views: FieldRef<"requests", 'Int'>
    readonly createdAt: FieldRef<"requests", 'DateTime'>
    readonly updatedAt: FieldRef<"requests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * requests findUnique
   */
  export type requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests findUniqueOrThrow
   */
  export type requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests findFirst
   */
  export type requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests findFirstOrThrow
   */
  export type requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests findMany
   */
  export type requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests create
   */
  export type requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The data needed to create a requests.
     */
    data: XOR<requestsCreateInput, requestsUncheckedCreateInput>
  }

  /**
   * requests createMany
   */
  export type requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requests.
     */
    data: requestsCreateManyInput | requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requests update
   */
  export type requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The data needed to update a requests.
     */
    data: XOR<requestsUpdateInput, requestsUncheckedUpdateInput>
    /**
     * Choose, which requests to update.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests updateMany
   */
  export type requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requests.
     */
    data: XOR<requestsUpdateManyMutationInput, requestsUncheckedUpdateManyInput>
    /**
     * Filter which requests to update
     */
    where?: requestsWhereInput
    /**
     * Limit how many requests to update.
     */
    limit?: number
  }

  /**
   * requests upsert
   */
  export type requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The filter to search for the requests to update in case it exists.
     */
    where: requestsWhereUniqueInput
    /**
     * In case the requests found by the `where` argument doesn't exist, create a new requests with this data.
     */
    create: XOR<requestsCreateInput, requestsUncheckedCreateInput>
    /**
     * In case the requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requestsUpdateInput, requestsUncheckedUpdateInput>
  }

  /**
   * requests delete
   */
  export type requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter which requests to delete.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests deleteMany
   */
  export type requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requests to delete
     */
    where?: requestsWhereInput
    /**
     * Limit how many requests to delete.
     */
    limit?: number
  }

  /**
   * requests without action
   */
  export type requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
  }


  /**
   * Model shopinfo
   */

  export type AggregateShopinfo = {
    _count: ShopinfoCountAggregateOutputType | null
    _avg: ShopinfoAvgAggregateOutputType | null
    _sum: ShopinfoSumAggregateOutputType | null
    _min: ShopinfoMinAggregateOutputType | null
    _max: ShopinfoMaxAggregateOutputType | null
  }

  export type ShopinfoAvgAggregateOutputType = {
    shopid: number | null
    driver_commission: number | null
    water_merchant_commission: number | null
    latestonhome: number | null
    offline: number | null
    total_news: number | null
  }

  export type ShopinfoSumAggregateOutputType = {
    shopid: number | null
    driver_commission: number | null
    water_merchant_commission: number | null
    latestonhome: number | null
    offline: number | null
    total_news: number | null
  }

  export type ShopinfoMinAggregateOutputType = {
    shopid: number | null
    shopname: string | null
    shopdescription: string | null
    driver_commission: number | null
    water_merchant_commission: number | null
    shoplogo: string | null
    shmetakey: string | null
    shmetadesc: string | null
    shopphone: string | null
    shopemailname: string | null
    shopemailaddress: string | null
    shoporderemail: string | null
    shopaddress: string | null
    shopcity: string | null
    shopstate: string | null
    shopcountry: string | null
    latestonhome: number | null
    offline: number | null
    offlinemsg: string | null
    shopimage: string | null
    total_news: number | null
    slfacebook: string | null
    sltwitter: string | null
    slinstagram: string | null
    slyoutube: string | null
    postedby: string | null
    updatedAt: Date | null
  }

  export type ShopinfoMaxAggregateOutputType = {
    shopid: number | null
    shopname: string | null
    shopdescription: string | null
    driver_commission: number | null
    water_merchant_commission: number | null
    shoplogo: string | null
    shmetakey: string | null
    shmetadesc: string | null
    shopphone: string | null
    shopemailname: string | null
    shopemailaddress: string | null
    shoporderemail: string | null
    shopaddress: string | null
    shopcity: string | null
    shopstate: string | null
    shopcountry: string | null
    latestonhome: number | null
    offline: number | null
    offlinemsg: string | null
    shopimage: string | null
    total_news: number | null
    slfacebook: string | null
    sltwitter: string | null
    slinstagram: string | null
    slyoutube: string | null
    postedby: string | null
    updatedAt: Date | null
  }

  export type ShopinfoCountAggregateOutputType = {
    shopid: number
    shopname: number
    shopdescription: number
    driver_commission: number
    water_merchant_commission: number
    shoplogo: number
    shmetakey: number
    shmetadesc: number
    shopphone: number
    shopemailname: number
    shopemailaddress: number
    shoporderemail: number
    shopaddress: number
    shopcity: number
    shopstate: number
    shopcountry: number
    latestonhome: number
    offline: number
    offlinemsg: number
    shopimage: number
    total_news: number
    slfacebook: number
    sltwitter: number
    slinstagram: number
    slyoutube: number
    postedby: number
    updatedAt: number
    _all: number
  }


  export type ShopinfoAvgAggregateInputType = {
    shopid?: true
    driver_commission?: true
    water_merchant_commission?: true
    latestonhome?: true
    offline?: true
    total_news?: true
  }

  export type ShopinfoSumAggregateInputType = {
    shopid?: true
    driver_commission?: true
    water_merchant_commission?: true
    latestonhome?: true
    offline?: true
    total_news?: true
  }

  export type ShopinfoMinAggregateInputType = {
    shopid?: true
    shopname?: true
    shopdescription?: true
    driver_commission?: true
    water_merchant_commission?: true
    shoplogo?: true
    shmetakey?: true
    shmetadesc?: true
    shopphone?: true
    shopemailname?: true
    shopemailaddress?: true
    shoporderemail?: true
    shopaddress?: true
    shopcity?: true
    shopstate?: true
    shopcountry?: true
    latestonhome?: true
    offline?: true
    offlinemsg?: true
    shopimage?: true
    total_news?: true
    slfacebook?: true
    sltwitter?: true
    slinstagram?: true
    slyoutube?: true
    postedby?: true
    updatedAt?: true
  }

  export type ShopinfoMaxAggregateInputType = {
    shopid?: true
    shopname?: true
    shopdescription?: true
    driver_commission?: true
    water_merchant_commission?: true
    shoplogo?: true
    shmetakey?: true
    shmetadesc?: true
    shopphone?: true
    shopemailname?: true
    shopemailaddress?: true
    shoporderemail?: true
    shopaddress?: true
    shopcity?: true
    shopstate?: true
    shopcountry?: true
    latestonhome?: true
    offline?: true
    offlinemsg?: true
    shopimage?: true
    total_news?: true
    slfacebook?: true
    sltwitter?: true
    slinstagram?: true
    slyoutube?: true
    postedby?: true
    updatedAt?: true
  }

  export type ShopinfoCountAggregateInputType = {
    shopid?: true
    shopname?: true
    shopdescription?: true
    driver_commission?: true
    water_merchant_commission?: true
    shoplogo?: true
    shmetakey?: true
    shmetadesc?: true
    shopphone?: true
    shopemailname?: true
    shopemailaddress?: true
    shoporderemail?: true
    shopaddress?: true
    shopcity?: true
    shopstate?: true
    shopcountry?: true
    latestonhome?: true
    offline?: true
    offlinemsg?: true
    shopimage?: true
    total_news?: true
    slfacebook?: true
    sltwitter?: true
    slinstagram?: true
    slyoutube?: true
    postedby?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopinfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shopinfo to aggregate.
     */
    where?: shopinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopinfos to fetch.
     */
    orderBy?: shopinfoOrderByWithRelationInput | shopinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shopinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shopinfos
    **/
    _count?: true | ShopinfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopinfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopinfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopinfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopinfoMaxAggregateInputType
  }

  export type GetShopinfoAggregateType<T extends ShopinfoAggregateArgs> = {
        [P in keyof T & keyof AggregateShopinfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopinfo[P]>
      : GetScalarType<T[P], AggregateShopinfo[P]>
  }




  export type shopinfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shopinfoWhereInput
    orderBy?: shopinfoOrderByWithAggregationInput | shopinfoOrderByWithAggregationInput[]
    by: ShopinfoScalarFieldEnum[] | ShopinfoScalarFieldEnum
    having?: shopinfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopinfoCountAggregateInputType | true
    _avg?: ShopinfoAvgAggregateInputType
    _sum?: ShopinfoSumAggregateInputType
    _min?: ShopinfoMinAggregateInputType
    _max?: ShopinfoMaxAggregateInputType
  }

  export type ShopinfoGroupByOutputType = {
    shopid: number
    shopname: string
    shopdescription: string
    driver_commission: number
    water_merchant_commission: number
    shoplogo: string | null
    shmetakey: string
    shmetadesc: string
    shopphone: string
    shopemailname: string
    shopemailaddress: string
    shoporderemail: string | null
    shopaddress: string
    shopcity: string
    shopstate: string
    shopcountry: string
    latestonhome: number
    offline: number
    offlinemsg: string
    shopimage: string
    total_news: number
    slfacebook: string
    sltwitter: string
    slinstagram: string
    slyoutube: string
    postedby: string
    updatedAt: Date
    _count: ShopinfoCountAggregateOutputType | null
    _avg: ShopinfoAvgAggregateOutputType | null
    _sum: ShopinfoSumAggregateOutputType | null
    _min: ShopinfoMinAggregateOutputType | null
    _max: ShopinfoMaxAggregateOutputType | null
  }

  type GetShopinfoGroupByPayload<T extends shopinfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopinfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopinfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopinfoGroupByOutputType[P]>
            : GetScalarType<T[P], ShopinfoGroupByOutputType[P]>
        }
      >
    >


  export type shopinfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopid?: boolean
    shopname?: boolean
    shopdescription?: boolean
    driver_commission?: boolean
    water_merchant_commission?: boolean
    shoplogo?: boolean
    shmetakey?: boolean
    shmetadesc?: boolean
    shopphone?: boolean
    shopemailname?: boolean
    shopemailaddress?: boolean
    shoporderemail?: boolean
    shopaddress?: boolean
    shopcity?: boolean
    shopstate?: boolean
    shopcountry?: boolean
    latestonhome?: boolean
    offline?: boolean
    offlinemsg?: boolean
    shopimage?: boolean
    total_news?: boolean
    slfacebook?: boolean
    sltwitter?: boolean
    slinstagram?: boolean
    slyoutube?: boolean
    postedby?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopinfo"]>



  export type shopinfoSelectScalar = {
    shopid?: boolean
    shopname?: boolean
    shopdescription?: boolean
    driver_commission?: boolean
    water_merchant_commission?: boolean
    shoplogo?: boolean
    shmetakey?: boolean
    shmetadesc?: boolean
    shopphone?: boolean
    shopemailname?: boolean
    shopemailaddress?: boolean
    shoporderemail?: boolean
    shopaddress?: boolean
    shopcity?: boolean
    shopstate?: boolean
    shopcountry?: boolean
    latestonhome?: boolean
    offline?: boolean
    offlinemsg?: boolean
    shopimage?: boolean
    total_news?: boolean
    slfacebook?: boolean
    sltwitter?: boolean
    slinstagram?: boolean
    slyoutube?: boolean
    postedby?: boolean
    updatedAt?: boolean
  }

  export type shopinfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopid" | "shopname" | "shopdescription" | "driver_commission" | "water_merchant_commission" | "shoplogo" | "shmetakey" | "shmetadesc" | "shopphone" | "shopemailname" | "shopemailaddress" | "shoporderemail" | "shopaddress" | "shopcity" | "shopstate" | "shopcountry" | "latestonhome" | "offline" | "offlinemsg" | "shopimage" | "total_news" | "slfacebook" | "sltwitter" | "slinstagram" | "slyoutube" | "postedby" | "updatedAt", ExtArgs["result"]["shopinfo"]>

  export type $shopinfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shopinfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      shopid: number
      shopname: string
      shopdescription: string
      driver_commission: number
      water_merchant_commission: number
      shoplogo: string | null
      shmetakey: string
      shmetadesc: string
      shopphone: string
      shopemailname: string
      shopemailaddress: string
      shoporderemail: string | null
      shopaddress: string
      shopcity: string
      shopstate: string
      shopcountry: string
      latestonhome: number
      offline: number
      offlinemsg: string
      shopimage: string
      total_news: number
      slfacebook: string
      sltwitter: string
      slinstagram: string
      slyoutube: string
      postedby: string
      updatedAt: Date
    }, ExtArgs["result"]["shopinfo"]>
    composites: {}
  }

  type shopinfoGetPayload<S extends boolean | null | undefined | shopinfoDefaultArgs> = $Result.GetResult<Prisma.$shopinfoPayload, S>

  type shopinfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shopinfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopinfoCountAggregateInputType | true
    }

  export interface shopinfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shopinfo'], meta: { name: 'shopinfo' } }
    /**
     * Find zero or one Shopinfo that matches the filter.
     * @param {shopinfoFindUniqueArgs} args - Arguments to find a Shopinfo
     * @example
     * // Get one Shopinfo
     * const shopinfo = await prisma.shopinfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shopinfoFindUniqueArgs>(args: SelectSubset<T, shopinfoFindUniqueArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shopinfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shopinfoFindUniqueOrThrowArgs} args - Arguments to find a Shopinfo
     * @example
     * // Get one Shopinfo
     * const shopinfo = await prisma.shopinfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shopinfoFindUniqueOrThrowArgs>(args: SelectSubset<T, shopinfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopinfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoFindFirstArgs} args - Arguments to find a Shopinfo
     * @example
     * // Get one Shopinfo
     * const shopinfo = await prisma.shopinfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shopinfoFindFirstArgs>(args?: SelectSubset<T, shopinfoFindFirstArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopinfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoFindFirstOrThrowArgs} args - Arguments to find a Shopinfo
     * @example
     * // Get one Shopinfo
     * const shopinfo = await prisma.shopinfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shopinfoFindFirstOrThrowArgs>(args?: SelectSubset<T, shopinfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shopinfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shopinfos
     * const shopinfos = await prisma.shopinfo.findMany()
     * 
     * // Get first 10 Shopinfos
     * const shopinfos = await prisma.shopinfo.findMany({ take: 10 })
     * 
     * // Only select the `shopid`
     * const shopinfoWithShopidOnly = await prisma.shopinfo.findMany({ select: { shopid: true } })
     * 
     */
    findMany<T extends shopinfoFindManyArgs>(args?: SelectSubset<T, shopinfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shopinfo.
     * @param {shopinfoCreateArgs} args - Arguments to create a Shopinfo.
     * @example
     * // Create one Shopinfo
     * const Shopinfo = await prisma.shopinfo.create({
     *   data: {
     *     // ... data to create a Shopinfo
     *   }
     * })
     * 
     */
    create<T extends shopinfoCreateArgs>(args: SelectSubset<T, shopinfoCreateArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shopinfos.
     * @param {shopinfoCreateManyArgs} args - Arguments to create many Shopinfos.
     * @example
     * // Create many Shopinfos
     * const shopinfo = await prisma.shopinfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shopinfoCreateManyArgs>(args?: SelectSubset<T, shopinfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shopinfo.
     * @param {shopinfoDeleteArgs} args - Arguments to delete one Shopinfo.
     * @example
     * // Delete one Shopinfo
     * const Shopinfo = await prisma.shopinfo.delete({
     *   where: {
     *     // ... filter to delete one Shopinfo
     *   }
     * })
     * 
     */
    delete<T extends shopinfoDeleteArgs>(args: SelectSubset<T, shopinfoDeleteArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shopinfo.
     * @param {shopinfoUpdateArgs} args - Arguments to update one Shopinfo.
     * @example
     * // Update one Shopinfo
     * const shopinfo = await prisma.shopinfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shopinfoUpdateArgs>(args: SelectSubset<T, shopinfoUpdateArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shopinfos.
     * @param {shopinfoDeleteManyArgs} args - Arguments to filter Shopinfos to delete.
     * @example
     * // Delete a few Shopinfos
     * const { count } = await prisma.shopinfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shopinfoDeleteManyArgs>(args?: SelectSubset<T, shopinfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shopinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shopinfos
     * const shopinfo = await prisma.shopinfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shopinfoUpdateManyArgs>(args: SelectSubset<T, shopinfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shopinfo.
     * @param {shopinfoUpsertArgs} args - Arguments to update or create a Shopinfo.
     * @example
     * // Update or create a Shopinfo
     * const shopinfo = await prisma.shopinfo.upsert({
     *   create: {
     *     // ... data to create a Shopinfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shopinfo we want to update
     *   }
     * })
     */
    upsert<T extends shopinfoUpsertArgs>(args: SelectSubset<T, shopinfoUpsertArgs<ExtArgs>>): Prisma__shopinfoClient<$Result.GetResult<Prisma.$shopinfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shopinfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoCountArgs} args - Arguments to filter Shopinfos to count.
     * @example
     * // Count the number of Shopinfos
     * const count = await prisma.shopinfo.count({
     *   where: {
     *     // ... the filter for the Shopinfos we want to count
     *   }
     * })
    **/
    count<T extends shopinfoCountArgs>(
      args?: Subset<T, shopinfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopinfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shopinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopinfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopinfoAggregateArgs>(args: Subset<T, ShopinfoAggregateArgs>): Prisma.PrismaPromise<GetShopinfoAggregateType<T>>

    /**
     * Group by Shopinfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopinfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shopinfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shopinfoGroupByArgs['orderBy'] }
        : { orderBy?: shopinfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shopinfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopinfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shopinfo model
   */
  readonly fields: shopinfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shopinfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shopinfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shopinfo model
   */
  interface shopinfoFieldRefs {
    readonly shopid: FieldRef<"shopinfo", 'Int'>
    readonly shopname: FieldRef<"shopinfo", 'String'>
    readonly shopdescription: FieldRef<"shopinfo", 'String'>
    readonly driver_commission: FieldRef<"shopinfo", 'Float'>
    readonly water_merchant_commission: FieldRef<"shopinfo", 'Float'>
    readonly shoplogo: FieldRef<"shopinfo", 'String'>
    readonly shmetakey: FieldRef<"shopinfo", 'String'>
    readonly shmetadesc: FieldRef<"shopinfo", 'String'>
    readonly shopphone: FieldRef<"shopinfo", 'String'>
    readonly shopemailname: FieldRef<"shopinfo", 'String'>
    readonly shopemailaddress: FieldRef<"shopinfo", 'String'>
    readonly shoporderemail: FieldRef<"shopinfo", 'String'>
    readonly shopaddress: FieldRef<"shopinfo", 'String'>
    readonly shopcity: FieldRef<"shopinfo", 'String'>
    readonly shopstate: FieldRef<"shopinfo", 'String'>
    readonly shopcountry: FieldRef<"shopinfo", 'String'>
    readonly latestonhome: FieldRef<"shopinfo", 'Int'>
    readonly offline: FieldRef<"shopinfo", 'Int'>
    readonly offlinemsg: FieldRef<"shopinfo", 'String'>
    readonly shopimage: FieldRef<"shopinfo", 'String'>
    readonly total_news: FieldRef<"shopinfo", 'Int'>
    readonly slfacebook: FieldRef<"shopinfo", 'String'>
    readonly sltwitter: FieldRef<"shopinfo", 'String'>
    readonly slinstagram: FieldRef<"shopinfo", 'String'>
    readonly slyoutube: FieldRef<"shopinfo", 'String'>
    readonly postedby: FieldRef<"shopinfo", 'String'>
    readonly updatedAt: FieldRef<"shopinfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * shopinfo findUnique
   */
  export type shopinfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter, which shopinfo to fetch.
     */
    where: shopinfoWhereUniqueInput
  }

  /**
   * shopinfo findUniqueOrThrow
   */
  export type shopinfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter, which shopinfo to fetch.
     */
    where: shopinfoWhereUniqueInput
  }

  /**
   * shopinfo findFirst
   */
  export type shopinfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter, which shopinfo to fetch.
     */
    where?: shopinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopinfos to fetch.
     */
    orderBy?: shopinfoOrderByWithRelationInput | shopinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopinfos.
     */
    cursor?: shopinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopinfos.
     */
    distinct?: ShopinfoScalarFieldEnum | ShopinfoScalarFieldEnum[]
  }

  /**
   * shopinfo findFirstOrThrow
   */
  export type shopinfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter, which shopinfo to fetch.
     */
    where?: shopinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopinfos to fetch.
     */
    orderBy?: shopinfoOrderByWithRelationInput | shopinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopinfos.
     */
    cursor?: shopinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopinfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopinfos.
     */
    distinct?: ShopinfoScalarFieldEnum | ShopinfoScalarFieldEnum[]
  }

  /**
   * shopinfo findMany
   */
  export type shopinfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter, which shopinfos to fetch.
     */
    where?: shopinfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopinfos to fetch.
     */
    orderBy?: shopinfoOrderByWithRelationInput | shopinfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shopinfos.
     */
    cursor?: shopinfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopinfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopinfos.
     */
    skip?: number
    distinct?: ShopinfoScalarFieldEnum | ShopinfoScalarFieldEnum[]
  }

  /**
   * shopinfo create
   */
  export type shopinfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * The data needed to create a shopinfo.
     */
    data: XOR<shopinfoCreateInput, shopinfoUncheckedCreateInput>
  }

  /**
   * shopinfo createMany
   */
  export type shopinfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shopinfos.
     */
    data: shopinfoCreateManyInput | shopinfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shopinfo update
   */
  export type shopinfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * The data needed to update a shopinfo.
     */
    data: XOR<shopinfoUpdateInput, shopinfoUncheckedUpdateInput>
    /**
     * Choose, which shopinfo to update.
     */
    where: shopinfoWhereUniqueInput
  }

  /**
   * shopinfo updateMany
   */
  export type shopinfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shopinfos.
     */
    data: XOR<shopinfoUpdateManyMutationInput, shopinfoUncheckedUpdateManyInput>
    /**
     * Filter which shopinfos to update
     */
    where?: shopinfoWhereInput
    /**
     * Limit how many shopinfos to update.
     */
    limit?: number
  }

  /**
   * shopinfo upsert
   */
  export type shopinfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * The filter to search for the shopinfo to update in case it exists.
     */
    where: shopinfoWhereUniqueInput
    /**
     * In case the shopinfo found by the `where` argument doesn't exist, create a new shopinfo with this data.
     */
    create: XOR<shopinfoCreateInput, shopinfoUncheckedCreateInput>
    /**
     * In case the shopinfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shopinfoUpdateInput, shopinfoUncheckedUpdateInput>
  }

  /**
   * shopinfo delete
   */
  export type shopinfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
    /**
     * Filter which shopinfo to delete.
     */
    where: shopinfoWhereUniqueInput
  }

  /**
   * shopinfo deleteMany
   */
  export type shopinfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shopinfos to delete
     */
    where?: shopinfoWhereInput
    /**
     * Limit how many shopinfos to delete.
     */
    limit?: number
  }

  /**
   * shopinfo without action
   */
  export type shopinfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shopinfo
     */
    select?: shopinfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shopinfo
     */
    omit?: shopinfoOmit<ExtArgs> | null
  }


  /**
   * Model sociallinks
   */

  export type AggregateSociallinks = {
    _count: SociallinksCountAggregateOutputType | null
    _avg: SociallinksAvgAggregateOutputType | null
    _sum: SociallinksSumAggregateOutputType | null
    _min: SociallinksMinAggregateOutputType | null
    _max: SociallinksMaxAggregateOutputType | null
  }

  export type SociallinksAvgAggregateOutputType = {
    slid: number | null
  }

  export type SociallinksSumAggregateOutputType = {
    slid: number | null
  }

  export type SociallinksMinAggregateOutputType = {
    slid: number | null
    slimage: string | null
    sladdress: string | null
  }

  export type SociallinksMaxAggregateOutputType = {
    slid: number | null
    slimage: string | null
    sladdress: string | null
  }

  export type SociallinksCountAggregateOutputType = {
    slid: number
    slimage: number
    sladdress: number
    _all: number
  }


  export type SociallinksAvgAggregateInputType = {
    slid?: true
  }

  export type SociallinksSumAggregateInputType = {
    slid?: true
  }

  export type SociallinksMinAggregateInputType = {
    slid?: true
    slimage?: true
    sladdress?: true
  }

  export type SociallinksMaxAggregateInputType = {
    slid?: true
    slimage?: true
    sladdress?: true
  }

  export type SociallinksCountAggregateInputType = {
    slid?: true
    slimage?: true
    sladdress?: true
    _all?: true
  }

  export type SociallinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sociallinks to aggregate.
     */
    where?: sociallinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sociallinks to fetch.
     */
    orderBy?: sociallinksOrderByWithRelationInput | sociallinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sociallinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sociallinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sociallinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sociallinks
    **/
    _count?: true | SociallinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SociallinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SociallinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SociallinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SociallinksMaxAggregateInputType
  }

  export type GetSociallinksAggregateType<T extends SociallinksAggregateArgs> = {
        [P in keyof T & keyof AggregateSociallinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSociallinks[P]>
      : GetScalarType<T[P], AggregateSociallinks[P]>
  }




  export type sociallinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sociallinksWhereInput
    orderBy?: sociallinksOrderByWithAggregationInput | sociallinksOrderByWithAggregationInput[]
    by: SociallinksScalarFieldEnum[] | SociallinksScalarFieldEnum
    having?: sociallinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SociallinksCountAggregateInputType | true
    _avg?: SociallinksAvgAggregateInputType
    _sum?: SociallinksSumAggregateInputType
    _min?: SociallinksMinAggregateInputType
    _max?: SociallinksMaxAggregateInputType
  }

  export type SociallinksGroupByOutputType = {
    slid: number
    slimage: string | null
    sladdress: string
    _count: SociallinksCountAggregateOutputType | null
    _avg: SociallinksAvgAggregateOutputType | null
    _sum: SociallinksSumAggregateOutputType | null
    _min: SociallinksMinAggregateOutputType | null
    _max: SociallinksMaxAggregateOutputType | null
  }

  type GetSociallinksGroupByPayload<T extends sociallinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SociallinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SociallinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SociallinksGroupByOutputType[P]>
            : GetScalarType<T[P], SociallinksGroupByOutputType[P]>
        }
      >
    >


  export type sociallinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    slid?: boolean
    slimage?: boolean
    sladdress?: boolean
  }, ExtArgs["result"]["sociallinks"]>



  export type sociallinksSelectScalar = {
    slid?: boolean
    slimage?: boolean
    sladdress?: boolean
  }

  export type sociallinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"slid" | "slimage" | "sladdress", ExtArgs["result"]["sociallinks"]>

  export type $sociallinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sociallinks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      slid: number
      slimage: string | null
      sladdress: string
    }, ExtArgs["result"]["sociallinks"]>
    composites: {}
  }

  type sociallinksGetPayload<S extends boolean | null | undefined | sociallinksDefaultArgs> = $Result.GetResult<Prisma.$sociallinksPayload, S>

  type sociallinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sociallinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SociallinksCountAggregateInputType | true
    }

  export interface sociallinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sociallinks'], meta: { name: 'sociallinks' } }
    /**
     * Find zero or one Sociallinks that matches the filter.
     * @param {sociallinksFindUniqueArgs} args - Arguments to find a Sociallinks
     * @example
     * // Get one Sociallinks
     * const sociallinks = await prisma.sociallinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sociallinksFindUniqueArgs>(args: SelectSubset<T, sociallinksFindUniqueArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sociallinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sociallinksFindUniqueOrThrowArgs} args - Arguments to find a Sociallinks
     * @example
     * // Get one Sociallinks
     * const sociallinks = await prisma.sociallinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sociallinksFindUniqueOrThrowArgs>(args: SelectSubset<T, sociallinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sociallinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksFindFirstArgs} args - Arguments to find a Sociallinks
     * @example
     * // Get one Sociallinks
     * const sociallinks = await prisma.sociallinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sociallinksFindFirstArgs>(args?: SelectSubset<T, sociallinksFindFirstArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sociallinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksFindFirstOrThrowArgs} args - Arguments to find a Sociallinks
     * @example
     * // Get one Sociallinks
     * const sociallinks = await prisma.sociallinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sociallinksFindFirstOrThrowArgs>(args?: SelectSubset<T, sociallinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sociallinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sociallinks
     * const sociallinks = await prisma.sociallinks.findMany()
     * 
     * // Get first 10 Sociallinks
     * const sociallinks = await prisma.sociallinks.findMany({ take: 10 })
     * 
     * // Only select the `slid`
     * const sociallinksWithSlidOnly = await prisma.sociallinks.findMany({ select: { slid: true } })
     * 
     */
    findMany<T extends sociallinksFindManyArgs>(args?: SelectSubset<T, sociallinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sociallinks.
     * @param {sociallinksCreateArgs} args - Arguments to create a Sociallinks.
     * @example
     * // Create one Sociallinks
     * const Sociallinks = await prisma.sociallinks.create({
     *   data: {
     *     // ... data to create a Sociallinks
     *   }
     * })
     * 
     */
    create<T extends sociallinksCreateArgs>(args: SelectSubset<T, sociallinksCreateArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sociallinks.
     * @param {sociallinksCreateManyArgs} args - Arguments to create many Sociallinks.
     * @example
     * // Create many Sociallinks
     * const sociallinks = await prisma.sociallinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sociallinksCreateManyArgs>(args?: SelectSubset<T, sociallinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sociallinks.
     * @param {sociallinksDeleteArgs} args - Arguments to delete one Sociallinks.
     * @example
     * // Delete one Sociallinks
     * const Sociallinks = await prisma.sociallinks.delete({
     *   where: {
     *     // ... filter to delete one Sociallinks
     *   }
     * })
     * 
     */
    delete<T extends sociallinksDeleteArgs>(args: SelectSubset<T, sociallinksDeleteArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sociallinks.
     * @param {sociallinksUpdateArgs} args - Arguments to update one Sociallinks.
     * @example
     * // Update one Sociallinks
     * const sociallinks = await prisma.sociallinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sociallinksUpdateArgs>(args: SelectSubset<T, sociallinksUpdateArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sociallinks.
     * @param {sociallinksDeleteManyArgs} args - Arguments to filter Sociallinks to delete.
     * @example
     * // Delete a few Sociallinks
     * const { count } = await prisma.sociallinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sociallinksDeleteManyArgs>(args?: SelectSubset<T, sociallinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sociallinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sociallinks
     * const sociallinks = await prisma.sociallinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sociallinksUpdateManyArgs>(args: SelectSubset<T, sociallinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sociallinks.
     * @param {sociallinksUpsertArgs} args - Arguments to update or create a Sociallinks.
     * @example
     * // Update or create a Sociallinks
     * const sociallinks = await prisma.sociallinks.upsert({
     *   create: {
     *     // ... data to create a Sociallinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sociallinks we want to update
     *   }
     * })
     */
    upsert<T extends sociallinksUpsertArgs>(args: SelectSubset<T, sociallinksUpsertArgs<ExtArgs>>): Prisma__sociallinksClient<$Result.GetResult<Prisma.$sociallinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sociallinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksCountArgs} args - Arguments to filter Sociallinks to count.
     * @example
     * // Count the number of Sociallinks
     * const count = await prisma.sociallinks.count({
     *   where: {
     *     // ... the filter for the Sociallinks we want to count
     *   }
     * })
    **/
    count<T extends sociallinksCountArgs>(
      args?: Subset<T, sociallinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SociallinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sociallinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SociallinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SociallinksAggregateArgs>(args: Subset<T, SociallinksAggregateArgs>): Prisma.PrismaPromise<GetSociallinksAggregateType<T>>

    /**
     * Group by Sociallinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sociallinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sociallinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sociallinksGroupByArgs['orderBy'] }
        : { orderBy?: sociallinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sociallinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSociallinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sociallinks model
   */
  readonly fields: sociallinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sociallinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sociallinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sociallinks model
   */
  interface sociallinksFieldRefs {
    readonly slid: FieldRef<"sociallinks", 'Int'>
    readonly slimage: FieldRef<"sociallinks", 'String'>
    readonly sladdress: FieldRef<"sociallinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sociallinks findUnique
   */
  export type sociallinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter, which sociallinks to fetch.
     */
    where: sociallinksWhereUniqueInput
  }

  /**
   * sociallinks findUniqueOrThrow
   */
  export type sociallinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter, which sociallinks to fetch.
     */
    where: sociallinksWhereUniqueInput
  }

  /**
   * sociallinks findFirst
   */
  export type sociallinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter, which sociallinks to fetch.
     */
    where?: sociallinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sociallinks to fetch.
     */
    orderBy?: sociallinksOrderByWithRelationInput | sociallinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sociallinks.
     */
    cursor?: sociallinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sociallinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sociallinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sociallinks.
     */
    distinct?: SociallinksScalarFieldEnum | SociallinksScalarFieldEnum[]
  }

  /**
   * sociallinks findFirstOrThrow
   */
  export type sociallinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter, which sociallinks to fetch.
     */
    where?: sociallinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sociallinks to fetch.
     */
    orderBy?: sociallinksOrderByWithRelationInput | sociallinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sociallinks.
     */
    cursor?: sociallinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sociallinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sociallinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sociallinks.
     */
    distinct?: SociallinksScalarFieldEnum | SociallinksScalarFieldEnum[]
  }

  /**
   * sociallinks findMany
   */
  export type sociallinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter, which sociallinks to fetch.
     */
    where?: sociallinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sociallinks to fetch.
     */
    orderBy?: sociallinksOrderByWithRelationInput | sociallinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sociallinks.
     */
    cursor?: sociallinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sociallinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sociallinks.
     */
    skip?: number
    distinct?: SociallinksScalarFieldEnum | SociallinksScalarFieldEnum[]
  }

  /**
   * sociallinks create
   */
  export type sociallinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * The data needed to create a sociallinks.
     */
    data: XOR<sociallinksCreateInput, sociallinksUncheckedCreateInput>
  }

  /**
   * sociallinks createMany
   */
  export type sociallinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sociallinks.
     */
    data: sociallinksCreateManyInput | sociallinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sociallinks update
   */
  export type sociallinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * The data needed to update a sociallinks.
     */
    data: XOR<sociallinksUpdateInput, sociallinksUncheckedUpdateInput>
    /**
     * Choose, which sociallinks to update.
     */
    where: sociallinksWhereUniqueInput
  }

  /**
   * sociallinks updateMany
   */
  export type sociallinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sociallinks.
     */
    data: XOR<sociallinksUpdateManyMutationInput, sociallinksUncheckedUpdateManyInput>
    /**
     * Filter which sociallinks to update
     */
    where?: sociallinksWhereInput
    /**
     * Limit how many sociallinks to update.
     */
    limit?: number
  }

  /**
   * sociallinks upsert
   */
  export type sociallinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * The filter to search for the sociallinks to update in case it exists.
     */
    where: sociallinksWhereUniqueInput
    /**
     * In case the sociallinks found by the `where` argument doesn't exist, create a new sociallinks with this data.
     */
    create: XOR<sociallinksCreateInput, sociallinksUncheckedCreateInput>
    /**
     * In case the sociallinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sociallinksUpdateInput, sociallinksUncheckedUpdateInput>
  }

  /**
   * sociallinks delete
   */
  export type sociallinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
    /**
     * Filter which sociallinks to delete.
     */
    where: sociallinksWhereUniqueInput
  }

  /**
   * sociallinks deleteMany
   */
  export type sociallinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sociallinks to delete
     */
    where?: sociallinksWhereInput
    /**
     * Limit how many sociallinks to delete.
     */
    limit?: number
  }

  /**
   * sociallinks without action
   */
  export type sociallinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sociallinks
     */
    select?: sociallinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sociallinks
     */
    omit?: sociallinksOmit<ExtArgs> | null
  }


  /**
   * Model subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    submagid: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    submagid: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    submagid: number | null
    sm_title: string | null
    sm_initials: string | null
    sm_surname: string | null
    sm_business: string | null
    sm_address: string | null
    sm_postcode: string | null
    sm_country: string | null
    sm_telephone: string | null
    sm_email: string | null
    sm_dateposted: Date | null
    sm_amount: string | null
    sm_paid: string | null
    sm_datepaid: string | null
    sm_from: string | null
    sm_to: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    submagid: number | null
    sm_title: string | null
    sm_initials: string | null
    sm_surname: string | null
    sm_business: string | null
    sm_address: string | null
    sm_postcode: string | null
    sm_country: string | null
    sm_telephone: string | null
    sm_email: string | null
    sm_dateposted: Date | null
    sm_amount: string | null
    sm_paid: string | null
    sm_datepaid: string | null
    sm_from: string | null
    sm_to: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    submagid: number
    sm_title: number
    sm_initials: number
    sm_surname: number
    sm_business: number
    sm_address: number
    sm_postcode: number
    sm_country: number
    sm_telephone: number
    sm_email: number
    sm_dateposted: number
    sm_amount: number
    sm_paid: number
    sm_datepaid: number
    sm_from: number
    sm_to: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    submagid?: true
  }

  export type SubscriptionSumAggregateInputType = {
    submagid?: true
  }

  export type SubscriptionMinAggregateInputType = {
    submagid?: true
    sm_title?: true
    sm_initials?: true
    sm_surname?: true
    sm_business?: true
    sm_address?: true
    sm_postcode?: true
    sm_country?: true
    sm_telephone?: true
    sm_email?: true
    sm_dateposted?: true
    sm_amount?: true
    sm_paid?: true
    sm_datepaid?: true
    sm_from?: true
    sm_to?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    submagid?: true
    sm_title?: true
    sm_initials?: true
    sm_surname?: true
    sm_business?: true
    sm_address?: true
    sm_postcode?: true
    sm_country?: true
    sm_telephone?: true
    sm_email?: true
    sm_dateposted?: true
    sm_amount?: true
    sm_paid?: true
    sm_datepaid?: true
    sm_from?: true
    sm_to?: true
  }

  export type SubscriptionCountAggregateInputType = {
    submagid?: true
    sm_title?: true
    sm_initials?: true
    sm_surname?: true
    sm_business?: true
    sm_address?: true
    sm_postcode?: true
    sm_country?: true
    sm_telephone?: true
    sm_email?: true
    sm_dateposted?: true
    sm_amount?: true
    sm_paid?: true
    sm_datepaid?: true
    sm_from?: true
    sm_to?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription to aggregate.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type subscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithAggregationInput | subscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    submagid: number
    sm_title: string | null
    sm_initials: string
    sm_surname: string
    sm_business: string
    sm_address: string
    sm_postcode: string | null
    sm_country: string
    sm_telephone: string
    sm_email: string
    sm_dateposted: Date
    sm_amount: string
    sm_paid: string
    sm_datepaid: string
    sm_from: string
    sm_to: string
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    submagid?: boolean
    sm_title?: boolean
    sm_initials?: boolean
    sm_surname?: boolean
    sm_business?: boolean
    sm_address?: boolean
    sm_postcode?: boolean
    sm_country?: boolean
    sm_telephone?: boolean
    sm_email?: boolean
    sm_dateposted?: boolean
    sm_amount?: boolean
    sm_paid?: boolean
    sm_datepaid?: boolean
    sm_from?: boolean
    sm_to?: boolean
  }, ExtArgs["result"]["subscription"]>



  export type subscriptionSelectScalar = {
    submagid?: boolean
    sm_title?: boolean
    sm_initials?: boolean
    sm_surname?: boolean
    sm_business?: boolean
    sm_address?: boolean
    sm_postcode?: boolean
    sm_country?: boolean
    sm_telephone?: boolean
    sm_email?: boolean
    sm_dateposted?: boolean
    sm_amount?: boolean
    sm_paid?: boolean
    sm_datepaid?: boolean
    sm_from?: boolean
    sm_to?: boolean
  }

  export type subscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"submagid" | "sm_title" | "sm_initials" | "sm_surname" | "sm_business" | "sm_address" | "sm_postcode" | "sm_country" | "sm_telephone" | "sm_email" | "sm_dateposted" | "sm_amount" | "sm_paid" | "sm_datepaid" | "sm_from" | "sm_to", ExtArgs["result"]["subscription"]>

  export type $subscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      submagid: number
      sm_title: string | null
      sm_initials: string
      sm_surname: string
      sm_business: string
      sm_address: string
      sm_postcode: string | null
      sm_country: string
      sm_telephone: string
      sm_email: string
      sm_dateposted: Date
      sm_amount: string
      sm_paid: string
      sm_datepaid: string
      sm_from: string
      sm_to: string
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionDefaultArgs> = $Result.GetResult<Prisma.$subscriptionPayload, S>

  type subscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface subscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription'], meta: { name: 'subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionFindUniqueArgs>(args: SelectSubset<T, subscriptionFindUniqueArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionFindFirstArgs>(args?: SelectSubset<T, subscriptionFindFirstArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `submagid`
     * const subscriptionWithSubmagidOnly = await prisma.subscription.findMany({ select: { submagid: true } })
     * 
     */
    findMany<T extends subscriptionFindManyArgs>(args?: SelectSubset<T, subscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends subscriptionCreateArgs>(args: SelectSubset<T, subscriptionCreateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionCreateManyArgs>(args?: SelectSubset<T, subscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends subscriptionDeleteArgs>(args: SelectSubset<T, subscriptionDeleteArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionUpdateArgs>(args: SelectSubset<T, subscriptionUpdateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionDeleteManyArgs>(args?: SelectSubset<T, subscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionUpdateManyArgs>(args: SelectSubset<T, subscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionUpsertArgs>(args: SelectSubset<T, subscriptionUpsertArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription model
   */
  readonly fields: subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscription model
   */
  interface subscriptionFieldRefs {
    readonly submagid: FieldRef<"subscription", 'Int'>
    readonly sm_title: FieldRef<"subscription", 'String'>
    readonly sm_initials: FieldRef<"subscription", 'String'>
    readonly sm_surname: FieldRef<"subscription", 'String'>
    readonly sm_business: FieldRef<"subscription", 'String'>
    readonly sm_address: FieldRef<"subscription", 'String'>
    readonly sm_postcode: FieldRef<"subscription", 'String'>
    readonly sm_country: FieldRef<"subscription", 'String'>
    readonly sm_telephone: FieldRef<"subscription", 'String'>
    readonly sm_email: FieldRef<"subscription", 'String'>
    readonly sm_dateposted: FieldRef<"subscription", 'DateTime'>
    readonly sm_amount: FieldRef<"subscription", 'String'>
    readonly sm_paid: FieldRef<"subscription", 'String'>
    readonly sm_datepaid: FieldRef<"subscription", 'String'>
    readonly sm_from: FieldRef<"subscription", 'String'>
    readonly sm_to: FieldRef<"subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subscription findUnique
   */
  export type subscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findFirst
   */
  export type subscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription create
   */
  export type subscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a subscription.
     */
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }

  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription update
   */
  export type subscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a subscription.
     */
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the subscription to update in case it exists.
     */
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     */
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }

  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Filter which subscription to delete.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscription without action
   */
  export type subscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
  }


  /**
   * Model team_category
   */

  export type AggregateTeam_category = {
    _count: Team_categoryCountAggregateOutputType | null
    _avg: Team_categoryAvgAggregateOutputType | null
    _sum: Team_categorySumAggregateOutputType | null
    _min: Team_categoryMinAggregateOutputType | null
    _max: Team_categoryMaxAggregateOutputType | null
  }

  export type Team_categoryAvgAggregateOutputType = {
    teamcategoryid: number | null
  }

  export type Team_categorySumAggregateOutputType = {
    teamcategoryid: number | null
  }

  export type Team_categoryMinAggregateOutputType = {
    teamcategoryid: number | null
    teamcategory: string | null
    teamcat_slug: string | null
  }

  export type Team_categoryMaxAggregateOutputType = {
    teamcategoryid: number | null
    teamcategory: string | null
    teamcat_slug: string | null
  }

  export type Team_categoryCountAggregateOutputType = {
    teamcategoryid: number
    teamcategory: number
    teamcat_slug: number
    _all: number
  }


  export type Team_categoryAvgAggregateInputType = {
    teamcategoryid?: true
  }

  export type Team_categorySumAggregateInputType = {
    teamcategoryid?: true
  }

  export type Team_categoryMinAggregateInputType = {
    teamcategoryid?: true
    teamcategory?: true
    teamcat_slug?: true
  }

  export type Team_categoryMaxAggregateInputType = {
    teamcategoryid?: true
    teamcategory?: true
    teamcat_slug?: true
  }

  export type Team_categoryCountAggregateInputType = {
    teamcategoryid?: true
    teamcategory?: true
    teamcat_slug?: true
    _all?: true
  }

  export type Team_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_category to aggregate.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_categories
    **/
    _count?: true | Team_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_categoryMaxAggregateInputType
  }

  export type GetTeam_categoryAggregateType<T extends Team_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_category[P]>
      : GetScalarType<T[P], AggregateTeam_category[P]>
  }




  export type team_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_categoryWhereInput
    orderBy?: team_categoryOrderByWithAggregationInput | team_categoryOrderByWithAggregationInput[]
    by: Team_categoryScalarFieldEnum[] | Team_categoryScalarFieldEnum
    having?: team_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_categoryCountAggregateInputType | true
    _avg?: Team_categoryAvgAggregateInputType
    _sum?: Team_categorySumAggregateInputType
    _min?: Team_categoryMinAggregateInputType
    _max?: Team_categoryMaxAggregateInputType
  }

  export type Team_categoryGroupByOutputType = {
    teamcategoryid: number
    teamcategory: string
    teamcat_slug: string
    _count: Team_categoryCountAggregateOutputType | null
    _avg: Team_categoryAvgAggregateOutputType | null
    _sum: Team_categorySumAggregateOutputType | null
    _min: Team_categoryMinAggregateOutputType | null
    _max: Team_categoryMaxAggregateOutputType | null
  }

  type GetTeam_categoryGroupByPayload<T extends team_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Team_categoryGroupByOutputType[P]>
        }
      >
    >


  export type team_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamcategoryid?: boolean
    teamcategory?: boolean
    teamcat_slug?: boolean
  }, ExtArgs["result"]["team_category"]>



  export type team_categorySelectScalar = {
    teamcategoryid?: boolean
    teamcategory?: boolean
    teamcat_slug?: boolean
  }

  export type team_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"teamcategoryid" | "teamcategory" | "teamcat_slug", ExtArgs["result"]["team_category"]>

  export type $team_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      teamcategoryid: number
      teamcategory: string
      teamcat_slug: string
    }, ExtArgs["result"]["team_category"]>
    composites: {}
  }

  type team_categoryGetPayload<S extends boolean | null | undefined | team_categoryDefaultArgs> = $Result.GetResult<Prisma.$team_categoryPayload, S>

  type team_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<team_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Team_categoryCountAggregateInputType | true
    }

  export interface team_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_category'], meta: { name: 'team_category' } }
    /**
     * Find zero or one Team_category that matches the filter.
     * @param {team_categoryFindUniqueArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_categoryFindUniqueArgs>(args: SelectSubset<T, team_categoryFindUniqueArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {team_categoryFindUniqueOrThrowArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, team_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindFirstArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_categoryFindFirstArgs>(args?: SelectSubset<T, team_categoryFindFirstArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindFirstOrThrowArgs} args - Arguments to find a Team_category
     * @example
     * // Get one Team_category
     * const team_category = await prisma.team_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, team_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Team_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_categories
     * const team_categories = await prisma.team_category.findMany()
     * 
     * // Get first 10 Team_categories
     * const team_categories = await prisma.team_category.findMany({ take: 10 })
     * 
     * // Only select the `teamcategoryid`
     * const team_categoryWithTeamcategoryidOnly = await prisma.team_category.findMany({ select: { teamcategoryid: true } })
     * 
     */
    findMany<T extends team_categoryFindManyArgs>(args?: SelectSubset<T, team_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team_category.
     * @param {team_categoryCreateArgs} args - Arguments to create a Team_category.
     * @example
     * // Create one Team_category
     * const Team_category = await prisma.team_category.create({
     *   data: {
     *     // ... data to create a Team_category
     *   }
     * })
     * 
     */
    create<T extends team_categoryCreateArgs>(args: SelectSubset<T, team_categoryCreateArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Team_categories.
     * @param {team_categoryCreateManyArgs} args - Arguments to create many Team_categories.
     * @example
     * // Create many Team_categories
     * const team_category = await prisma.team_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_categoryCreateManyArgs>(args?: SelectSubset<T, team_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_category.
     * @param {team_categoryDeleteArgs} args - Arguments to delete one Team_category.
     * @example
     * // Delete one Team_category
     * const Team_category = await prisma.team_category.delete({
     *   where: {
     *     // ... filter to delete one Team_category
     *   }
     * })
     * 
     */
    delete<T extends team_categoryDeleteArgs>(args: SelectSubset<T, team_categoryDeleteArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team_category.
     * @param {team_categoryUpdateArgs} args - Arguments to update one Team_category.
     * @example
     * // Update one Team_category
     * const team_category = await prisma.team_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_categoryUpdateArgs>(args: SelectSubset<T, team_categoryUpdateArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Team_categories.
     * @param {team_categoryDeleteManyArgs} args - Arguments to filter Team_categories to delete.
     * @example
     * // Delete a few Team_categories
     * const { count } = await prisma.team_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_categoryDeleteManyArgs>(args?: SelectSubset<T, team_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_categories
     * const team_category = await prisma.team_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_categoryUpdateManyArgs>(args: SelectSubset<T, team_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_category.
     * @param {team_categoryUpsertArgs} args - Arguments to update or create a Team_category.
     * @example
     * // Update or create a Team_category
     * const team_category = await prisma.team_category.upsert({
     *   create: {
     *     // ... data to create a Team_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_category we want to update
     *   }
     * })
     */
    upsert<T extends team_categoryUpsertArgs>(args: SelectSubset<T, team_categoryUpsertArgs<ExtArgs>>): Prisma__team_categoryClient<$Result.GetResult<Prisma.$team_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Team_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryCountArgs} args - Arguments to filter Team_categories to count.
     * @example
     * // Count the number of Team_categories
     * const count = await prisma.team_category.count({
     *   where: {
     *     // ... the filter for the Team_categories we want to count
     *   }
     * })
    **/
    count<T extends team_categoryCountArgs>(
      args?: Subset<T, team_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_categoryAggregateArgs>(args: Subset<T, Team_categoryAggregateArgs>): Prisma.PrismaPromise<GetTeam_categoryAggregateType<T>>

    /**
     * Group by Team_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_categoryGroupByArgs['orderBy'] }
        : { orderBy?: team_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_category model
   */
  readonly fields: team_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_category model
   */
  interface team_categoryFieldRefs {
    readonly teamcategoryid: FieldRef<"team_category", 'Int'>
    readonly teamcategory: FieldRef<"team_category", 'String'>
    readonly teamcat_slug: FieldRef<"team_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * team_category findUnique
   */
  export type team_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where: team_categoryWhereUniqueInput
  }

  /**
   * team_category findUniqueOrThrow
   */
  export type team_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where: team_categoryWhereUniqueInput
  }

  /**
   * team_category findFirst
   */
  export type team_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_categories.
     */
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }

  /**
   * team_category findFirstOrThrow
   */
  export type team_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter, which team_category to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_categories.
     */
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }

  /**
   * team_category findMany
   */
  export type team_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter, which team_categories to fetch.
     */
    where?: team_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_categories to fetch.
     */
    orderBy?: team_categoryOrderByWithRelationInput | team_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_categories.
     */
    cursor?: team_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_categories.
     */
    skip?: number
    distinct?: Team_categoryScalarFieldEnum | Team_categoryScalarFieldEnum[]
  }

  /**
   * team_category create
   */
  export type team_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * The data needed to create a team_category.
     */
    data: XOR<team_categoryCreateInput, team_categoryUncheckedCreateInput>
  }

  /**
   * team_category createMany
   */
  export type team_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_categories.
     */
    data: team_categoryCreateManyInput | team_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * team_category update
   */
  export type team_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * The data needed to update a team_category.
     */
    data: XOR<team_categoryUpdateInput, team_categoryUncheckedUpdateInput>
    /**
     * Choose, which team_category to update.
     */
    where: team_categoryWhereUniqueInput
  }

  /**
   * team_category updateMany
   */
  export type team_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_categories.
     */
    data: XOR<team_categoryUpdateManyMutationInput, team_categoryUncheckedUpdateManyInput>
    /**
     * Filter which team_categories to update
     */
    where?: team_categoryWhereInput
    /**
     * Limit how many team_categories to update.
     */
    limit?: number
  }

  /**
   * team_category upsert
   */
  export type team_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * The filter to search for the team_category to update in case it exists.
     */
    where: team_categoryWhereUniqueInput
    /**
     * In case the team_category found by the `where` argument doesn't exist, create a new team_category with this data.
     */
    create: XOR<team_categoryCreateInput, team_categoryUncheckedCreateInput>
    /**
     * In case the team_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_categoryUpdateInput, team_categoryUncheckedUpdateInput>
  }

  /**
   * team_category delete
   */
  export type team_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
    /**
     * Filter which team_category to delete.
     */
    where: team_categoryWhereUniqueInput
  }

  /**
   * team_category deleteMany
   */
  export type team_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_categories to delete
     */
    where?: team_categoryWhereInput
    /**
     * Limit how many team_categories to delete.
     */
    limit?: number
  }

  /**
   * team_category without action
   */
  export type team_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_category
     */
    select?: team_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_category
     */
    omit?: team_categoryOmit<ExtArgs> | null
  }


  /**
   * Model team_members
   */

  export type AggregateTeam_members = {
    _count: Team_membersCountAggregateOutputType | null
    _avg: Team_membersAvgAggregateOutputType | null
    _sum: Team_membersSumAggregateOutputType | null
    _min: Team_membersMinAggregateOutputType | null
    _max: Team_membersMaxAggregateOutputType | null
  }

  export type Team_membersAvgAggregateOutputType = {
    tmemberid: number | null
    tmemberrank: number | null
  }

  export type Team_membersSumAggregateOutputType = {
    tmemberid: number | null
    tmemberrank: number | null
  }

  export type Team_membersMinAggregateOutputType = {
    tmemberid: number | null
    tmcategory: string | null
    tmember: string | null
    tmember_slug: string | null
    tmemberposition: string | null
    tmemberphoto: string | null
    tmemberprofile: string | null
    tmembersummary: string | null
    tmemberdateadded: Date | null
    tmemberpostedby: string | null
    tmemberrank: number | null
    tmember_email: string | null
    tmember_phone: string | null
    tmember_facebook: string | null
    tmember_twitter: string | null
    tmember_linkedin: string | null
    tmember_instagram: string | null
  }

  export type Team_membersMaxAggregateOutputType = {
    tmemberid: number | null
    tmcategory: string | null
    tmember: string | null
    tmember_slug: string | null
    tmemberposition: string | null
    tmemberphoto: string | null
    tmemberprofile: string | null
    tmembersummary: string | null
    tmemberdateadded: Date | null
    tmemberpostedby: string | null
    tmemberrank: number | null
    tmember_email: string | null
    tmember_phone: string | null
    tmember_facebook: string | null
    tmember_twitter: string | null
    tmember_linkedin: string | null
    tmember_instagram: string | null
  }

  export type Team_membersCountAggregateOutputType = {
    tmemberid: number
    tmcategory: number
    tmember: number
    tmember_slug: number
    tmemberposition: number
    tmemberphoto: number
    tmemberprofile: number
    tmembersummary: number
    tmemberdateadded: number
    tmemberpostedby: number
    tmemberrank: number
    tmember_email: number
    tmember_phone: number
    tmember_facebook: number
    tmember_twitter: number
    tmember_linkedin: number
    tmember_instagram: number
    _all: number
  }


  export type Team_membersAvgAggregateInputType = {
    tmemberid?: true
    tmemberrank?: true
  }

  export type Team_membersSumAggregateInputType = {
    tmemberid?: true
    tmemberrank?: true
  }

  export type Team_membersMinAggregateInputType = {
    tmemberid?: true
    tmcategory?: true
    tmember?: true
    tmember_slug?: true
    tmemberposition?: true
    tmemberphoto?: true
    tmemberprofile?: true
    tmembersummary?: true
    tmemberdateadded?: true
    tmemberpostedby?: true
    tmemberrank?: true
    tmember_email?: true
    tmember_phone?: true
    tmember_facebook?: true
    tmember_twitter?: true
    tmember_linkedin?: true
    tmember_instagram?: true
  }

  export type Team_membersMaxAggregateInputType = {
    tmemberid?: true
    tmcategory?: true
    tmember?: true
    tmember_slug?: true
    tmemberposition?: true
    tmemberphoto?: true
    tmemberprofile?: true
    tmembersummary?: true
    tmemberdateadded?: true
    tmemberpostedby?: true
    tmemberrank?: true
    tmember_email?: true
    tmember_phone?: true
    tmember_facebook?: true
    tmember_twitter?: true
    tmember_linkedin?: true
    tmember_instagram?: true
  }

  export type Team_membersCountAggregateInputType = {
    tmemberid?: true
    tmcategory?: true
    tmember?: true
    tmember_slug?: true
    tmemberposition?: true
    tmemberphoto?: true
    tmemberprofile?: true
    tmembersummary?: true
    tmemberdateadded?: true
    tmemberpostedby?: true
    tmemberrank?: true
    tmember_email?: true
    tmember_phone?: true
    tmember_facebook?: true
    tmember_twitter?: true
    tmember_linkedin?: true
    tmember_instagram?: true
    _all?: true
  }

  export type Team_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_members to aggregate.
     */
    where?: team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_membersOrderByWithRelationInput | team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_members
    **/
    _count?: true | Team_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Team_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Team_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_membersMaxAggregateInputType
  }

  export type GetTeam_membersAggregateType<T extends Team_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_members[P]>
      : GetScalarType<T[P], AggregateTeam_members[P]>
  }




  export type team_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_membersWhereInput
    orderBy?: team_membersOrderByWithAggregationInput | team_membersOrderByWithAggregationInput[]
    by: Team_membersScalarFieldEnum[] | Team_membersScalarFieldEnum
    having?: team_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_membersCountAggregateInputType | true
    _avg?: Team_membersAvgAggregateInputType
    _sum?: Team_membersSumAggregateInputType
    _min?: Team_membersMinAggregateInputType
    _max?: Team_membersMaxAggregateInputType
  }

  export type Team_membersGroupByOutputType = {
    tmemberid: number
    tmcategory: string | null
    tmember: string
    tmember_slug: string
    tmemberposition: string
    tmemberphoto: string
    tmemberprofile: string
    tmembersummary: string | null
    tmemberdateadded: Date
    tmemberpostedby: string | null
    tmemberrank: number
    tmember_email: string | null
    tmember_phone: string | null
    tmember_facebook: string | null
    tmember_twitter: string | null
    tmember_linkedin: string | null
    tmember_instagram: string | null
    _count: Team_membersCountAggregateOutputType | null
    _avg: Team_membersAvgAggregateOutputType | null
    _sum: Team_membersSumAggregateOutputType | null
    _min: Team_membersMinAggregateOutputType | null
    _max: Team_membersMaxAggregateOutputType | null
  }

  type GetTeam_membersGroupByPayload<T extends team_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Team_membersGroupByOutputType[P]>
        }
      >
    >


  export type team_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tmemberid?: boolean
    tmcategory?: boolean
    tmember?: boolean
    tmember_slug?: boolean
    tmemberposition?: boolean
    tmemberphoto?: boolean
    tmemberprofile?: boolean
    tmembersummary?: boolean
    tmemberdateadded?: boolean
    tmemberpostedby?: boolean
    tmemberrank?: boolean
    tmember_email?: boolean
    tmember_phone?: boolean
    tmember_facebook?: boolean
    tmember_twitter?: boolean
    tmember_linkedin?: boolean
    tmember_instagram?: boolean
  }, ExtArgs["result"]["team_members"]>



  export type team_membersSelectScalar = {
    tmemberid?: boolean
    tmcategory?: boolean
    tmember?: boolean
    tmember_slug?: boolean
    tmemberposition?: boolean
    tmemberphoto?: boolean
    tmemberprofile?: boolean
    tmembersummary?: boolean
    tmemberdateadded?: boolean
    tmemberpostedby?: boolean
    tmemberrank?: boolean
    tmember_email?: boolean
    tmember_phone?: boolean
    tmember_facebook?: boolean
    tmember_twitter?: boolean
    tmember_linkedin?: boolean
    tmember_instagram?: boolean
  }

  export type team_membersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tmemberid" | "tmcategory" | "tmember" | "tmember_slug" | "tmemberposition" | "tmemberphoto" | "tmemberprofile" | "tmembersummary" | "tmemberdateadded" | "tmemberpostedby" | "tmemberrank" | "tmember_email" | "tmember_phone" | "tmember_facebook" | "tmember_twitter" | "tmember_linkedin" | "tmember_instagram", ExtArgs["result"]["team_members"]>

  export type $team_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_members"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tmemberid: number
      tmcategory: string | null
      tmember: string
      tmember_slug: string
      tmemberposition: string
      tmemberphoto: string
      tmemberprofile: string
      tmembersummary: string | null
      tmemberdateadded: Date
      tmemberpostedby: string | null
      tmemberrank: number
      tmember_email: string | null
      tmember_phone: string | null
      tmember_facebook: string | null
      tmember_twitter: string | null
      tmember_linkedin: string | null
      tmember_instagram: string | null
    }, ExtArgs["result"]["team_members"]>
    composites: {}
  }

  type team_membersGetPayload<S extends boolean | null | undefined | team_membersDefaultArgs> = $Result.GetResult<Prisma.$team_membersPayload, S>

  type team_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<team_membersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Team_membersCountAggregateInputType | true
    }

  export interface team_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_members'], meta: { name: 'team_members' } }
    /**
     * Find zero or one Team_members that matches the filter.
     * @param {team_membersFindUniqueArgs} args - Arguments to find a Team_members
     * @example
     * // Get one Team_members
     * const team_members = await prisma.team_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_membersFindUniqueArgs>(args: SelectSubset<T, team_membersFindUniqueArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team_members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {team_membersFindUniqueOrThrowArgs} args - Arguments to find a Team_members
     * @example
     * // Get one Team_members
     * const team_members = await prisma.team_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, team_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersFindFirstArgs} args - Arguments to find a Team_members
     * @example
     * // Get one Team_members
     * const team_members = await prisma.team_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_membersFindFirstArgs>(args?: SelectSubset<T, team_membersFindFirstArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersFindFirstOrThrowArgs} args - Arguments to find a Team_members
     * @example
     * // Get one Team_members
     * const team_members = await prisma.team_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, team_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Team_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_members
     * const team_members = await prisma.team_members.findMany()
     * 
     * // Get first 10 Team_members
     * const team_members = await prisma.team_members.findMany({ take: 10 })
     * 
     * // Only select the `tmemberid`
     * const team_membersWithTmemberidOnly = await prisma.team_members.findMany({ select: { tmemberid: true } })
     * 
     */
    findMany<T extends team_membersFindManyArgs>(args?: SelectSubset<T, team_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team_members.
     * @param {team_membersCreateArgs} args - Arguments to create a Team_members.
     * @example
     * // Create one Team_members
     * const Team_members = await prisma.team_members.create({
     *   data: {
     *     // ... data to create a Team_members
     *   }
     * })
     * 
     */
    create<T extends team_membersCreateArgs>(args: SelectSubset<T, team_membersCreateArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Team_members.
     * @param {team_membersCreateManyArgs} args - Arguments to create many Team_members.
     * @example
     * // Create many Team_members
     * const team_members = await prisma.team_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_membersCreateManyArgs>(args?: SelectSubset<T, team_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_members.
     * @param {team_membersDeleteArgs} args - Arguments to delete one Team_members.
     * @example
     * // Delete one Team_members
     * const Team_members = await prisma.team_members.delete({
     *   where: {
     *     // ... filter to delete one Team_members
     *   }
     * })
     * 
     */
    delete<T extends team_membersDeleteArgs>(args: SelectSubset<T, team_membersDeleteArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team_members.
     * @param {team_membersUpdateArgs} args - Arguments to update one Team_members.
     * @example
     * // Update one Team_members
     * const team_members = await prisma.team_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_membersUpdateArgs>(args: SelectSubset<T, team_membersUpdateArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Team_members.
     * @param {team_membersDeleteManyArgs} args - Arguments to filter Team_members to delete.
     * @example
     * // Delete a few Team_members
     * const { count } = await prisma.team_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_membersDeleteManyArgs>(args?: SelectSubset<T, team_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_members
     * const team_members = await prisma.team_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_membersUpdateManyArgs>(args: SelectSubset<T, team_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_members.
     * @param {team_membersUpsertArgs} args - Arguments to update or create a Team_members.
     * @example
     * // Update or create a Team_members
     * const team_members = await prisma.team_members.upsert({
     *   create: {
     *     // ... data to create a Team_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_members we want to update
     *   }
     * })
     */
    upsert<T extends team_membersUpsertArgs>(args: SelectSubset<T, team_membersUpsertArgs<ExtArgs>>): Prisma__team_membersClient<$Result.GetResult<Prisma.$team_membersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersCountArgs} args - Arguments to filter Team_members to count.
     * @example
     * // Count the number of Team_members
     * const count = await prisma.team_members.count({
     *   where: {
     *     // ... the filter for the Team_members we want to count
     *   }
     * })
    **/
    count<T extends team_membersCountArgs>(
      args?: Subset<T, team_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_membersAggregateArgs>(args: Subset<T, Team_membersAggregateArgs>): Prisma.PrismaPromise<GetTeam_membersAggregateType<T>>

    /**
     * Group by Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_membersGroupByArgs['orderBy'] }
        : { orderBy?: team_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_members model
   */
  readonly fields: team_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_members model
   */
  interface team_membersFieldRefs {
    readonly tmemberid: FieldRef<"team_members", 'Int'>
    readonly tmcategory: FieldRef<"team_members", 'String'>
    readonly tmember: FieldRef<"team_members", 'String'>
    readonly tmember_slug: FieldRef<"team_members", 'String'>
    readonly tmemberposition: FieldRef<"team_members", 'String'>
    readonly tmemberphoto: FieldRef<"team_members", 'String'>
    readonly tmemberprofile: FieldRef<"team_members", 'String'>
    readonly tmembersummary: FieldRef<"team_members", 'String'>
    readonly tmemberdateadded: FieldRef<"team_members", 'DateTime'>
    readonly tmemberpostedby: FieldRef<"team_members", 'String'>
    readonly tmemberrank: FieldRef<"team_members", 'Int'>
    readonly tmember_email: FieldRef<"team_members", 'String'>
    readonly tmember_phone: FieldRef<"team_members", 'String'>
    readonly tmember_facebook: FieldRef<"team_members", 'String'>
    readonly tmember_twitter: FieldRef<"team_members", 'String'>
    readonly tmember_linkedin: FieldRef<"team_members", 'String'>
    readonly tmember_instagram: FieldRef<"team_members", 'String'>
  }
    

  // Custom InputTypes
  /**
   * team_members findUnique
   */
  export type team_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where: team_membersWhereUniqueInput
  }

  /**
   * team_members findUniqueOrThrow
   */
  export type team_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where: team_membersWhereUniqueInput
  }

  /**
   * team_members findFirst
   */
  export type team_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where?: team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_membersOrderByWithRelationInput | team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_members.
     */
    cursor?: team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_members.
     */
    distinct?: Team_membersScalarFieldEnum | Team_membersScalarFieldEnum[]
  }

  /**
   * team_members findFirstOrThrow
   */
  export type team_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where?: team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_membersOrderByWithRelationInput | team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_members.
     */
    cursor?: team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_members.
     */
    distinct?: Team_membersScalarFieldEnum | Team_membersScalarFieldEnum[]
  }

  /**
   * team_members findMany
   */
  export type team_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where?: team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_membersOrderByWithRelationInput | team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_members.
     */
    cursor?: team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    distinct?: Team_membersScalarFieldEnum | Team_membersScalarFieldEnum[]
  }

  /**
   * team_members create
   */
  export type team_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * The data needed to create a team_members.
     */
    data: XOR<team_membersCreateInput, team_membersUncheckedCreateInput>
  }

  /**
   * team_members createMany
   */
  export type team_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_members.
     */
    data: team_membersCreateManyInput | team_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * team_members update
   */
  export type team_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * The data needed to update a team_members.
     */
    data: XOR<team_membersUpdateInput, team_membersUncheckedUpdateInput>
    /**
     * Choose, which team_members to update.
     */
    where: team_membersWhereUniqueInput
  }

  /**
   * team_members updateMany
   */
  export type team_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_members.
     */
    data: XOR<team_membersUpdateManyMutationInput, team_membersUncheckedUpdateManyInput>
    /**
     * Filter which team_members to update
     */
    where?: team_membersWhereInput
    /**
     * Limit how many team_members to update.
     */
    limit?: number
  }

  /**
   * team_members upsert
   */
  export type team_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * The filter to search for the team_members to update in case it exists.
     */
    where: team_membersWhereUniqueInput
    /**
     * In case the team_members found by the `where` argument doesn't exist, create a new team_members with this data.
     */
    create: XOR<team_membersCreateInput, team_membersUncheckedCreateInput>
    /**
     * In case the team_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_membersUpdateInput, team_membersUncheckedUpdateInput>
  }

  /**
   * team_members delete
   */
  export type team_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
    /**
     * Filter which team_members to delete.
     */
    where: team_membersWhereUniqueInput
  }

  /**
   * team_members deleteMany
   */
  export type team_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_members to delete
     */
    where?: team_membersWhereInput
    /**
     * Limit how many team_members to delete.
     */
    limit?: number
  }

  /**
   * team_members without action
   */
  export type team_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_members
     */
    select?: team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team_members
     */
    omit?: team_membersOmit<ExtArgs> | null
  }


  /**
   * Model testimonials
   */

  export type AggregateTestimonials = {
    _count: TestimonialsCountAggregateOutputType | null
    _avg: TestimonialsAvgAggregateOutputType | null
    _sum: TestimonialsSumAggregateOutputType | null
    _min: TestimonialsMinAggregateOutputType | null
    _max: TestimonialsMaxAggregateOutputType | null
  }

  export type TestimonialsAvgAggregateOutputType = {
    tid: number | null
    tstars: number | null
    tstatus: number | null
  }

  export type TestimonialsSumAggregateOutputType = {
    tid: number | null
    tstars: number | null
    tstatus: number | null
  }

  export type TestimonialsMinAggregateOutputType = {
    tid: number | null
    tcustomer: string | null
    trole: string | null
    tphoto: string | null
    tmessage: string | null
    tstars: number | null
    tdate: Date | null
    tstatus: number | null
  }

  export type TestimonialsMaxAggregateOutputType = {
    tid: number | null
    tcustomer: string | null
    trole: string | null
    tphoto: string | null
    tmessage: string | null
    tstars: number | null
    tdate: Date | null
    tstatus: number | null
  }

  export type TestimonialsCountAggregateOutputType = {
    tid: number
    tcustomer: number
    trole: number
    tphoto: number
    tmessage: number
    tstars: number
    tdate: number
    tstatus: number
    _all: number
  }


  export type TestimonialsAvgAggregateInputType = {
    tid?: true
    tstars?: true
    tstatus?: true
  }

  export type TestimonialsSumAggregateInputType = {
    tid?: true
    tstars?: true
    tstatus?: true
  }

  export type TestimonialsMinAggregateInputType = {
    tid?: true
    tcustomer?: true
    trole?: true
    tphoto?: true
    tmessage?: true
    tstars?: true
    tdate?: true
    tstatus?: true
  }

  export type TestimonialsMaxAggregateInputType = {
    tid?: true
    tcustomer?: true
    trole?: true
    tphoto?: true
    tmessage?: true
    tstars?: true
    tdate?: true
    tstatus?: true
  }

  export type TestimonialsCountAggregateInputType = {
    tid?: true
    tcustomer?: true
    trole?: true
    tphoto?: true
    tmessage?: true
    tstars?: true
    tdate?: true
    tstatus?: true
    _all?: true
  }

  export type TestimonialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonials to aggregate.
     */
    where?: testimonialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialsOrderByWithRelationInput | testimonialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testimonialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testimonials
    **/
    _count?: true | TestimonialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialsMaxAggregateInputType
  }

  export type GetTestimonialsAggregateType<T extends TestimonialsAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonials[P]>
      : GetScalarType<T[P], AggregateTestimonials[P]>
  }




  export type testimonialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialsWhereInput
    orderBy?: testimonialsOrderByWithAggregationInput | testimonialsOrderByWithAggregationInput[]
    by: TestimonialsScalarFieldEnum[] | TestimonialsScalarFieldEnum
    having?: testimonialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialsCountAggregateInputType | true
    _avg?: TestimonialsAvgAggregateInputType
    _sum?: TestimonialsSumAggregateInputType
    _min?: TestimonialsMinAggregateInputType
    _max?: TestimonialsMaxAggregateInputType
  }

  export type TestimonialsGroupByOutputType = {
    tid: number
    tcustomer: string
    trole: string
    tphoto: string
    tmessage: string
    tstars: number
    tdate: Date
    tstatus: number
    _count: TestimonialsCountAggregateOutputType | null
    _avg: TestimonialsAvgAggregateOutputType | null
    _sum: TestimonialsSumAggregateOutputType | null
    _min: TestimonialsMinAggregateOutputType | null
    _max: TestimonialsMaxAggregateOutputType | null
  }

  type GetTestimonialsGroupByPayload<T extends testimonialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialsGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialsGroupByOutputType[P]>
        }
      >
    >


  export type testimonialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tid?: boolean
    tcustomer?: boolean
    trole?: boolean
    tphoto?: boolean
    tmessage?: boolean
    tstars?: boolean
    tdate?: boolean
    tstatus?: boolean
  }, ExtArgs["result"]["testimonials"]>



  export type testimonialsSelectScalar = {
    tid?: boolean
    tcustomer?: boolean
    trole?: boolean
    tphoto?: boolean
    tmessage?: boolean
    tstars?: boolean
    tdate?: boolean
    tstatus?: boolean
  }

  export type testimonialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tid" | "tcustomer" | "trole" | "tphoto" | "tmessage" | "tstars" | "tdate" | "tstatus", ExtArgs["result"]["testimonials"]>

  export type $testimonialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testimonials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tid: number
      tcustomer: string
      trole: string
      tphoto: string
      tmessage: string
      tstars: number
      tdate: Date
      tstatus: number
    }, ExtArgs["result"]["testimonials"]>
    composites: {}
  }

  type testimonialsGetPayload<S extends boolean | null | undefined | testimonialsDefaultArgs> = $Result.GetResult<Prisma.$testimonialsPayload, S>

  type testimonialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testimonialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialsCountAggregateInputType | true
    }

  export interface testimonialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testimonials'], meta: { name: 'testimonials' } }
    /**
     * Find zero or one Testimonials that matches the filter.
     * @param {testimonialsFindUniqueArgs} args - Arguments to find a Testimonials
     * @example
     * // Get one Testimonials
     * const testimonials = await prisma.testimonials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testimonialsFindUniqueArgs>(args: SelectSubset<T, testimonialsFindUniqueArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testimonialsFindUniqueOrThrowArgs} args - Arguments to find a Testimonials
     * @example
     * // Get one Testimonials
     * const testimonials = await prisma.testimonials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testimonialsFindUniqueOrThrowArgs>(args: SelectSubset<T, testimonialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsFindFirstArgs} args - Arguments to find a Testimonials
     * @example
     * // Get one Testimonials
     * const testimonials = await prisma.testimonials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testimonialsFindFirstArgs>(args?: SelectSubset<T, testimonialsFindFirstArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsFindFirstOrThrowArgs} args - Arguments to find a Testimonials
     * @example
     * // Get one Testimonials
     * const testimonials = await prisma.testimonials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testimonialsFindFirstOrThrowArgs>(args?: SelectSubset<T, testimonialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonials.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonials.findMany({ take: 10 })
     * 
     * // Only select the `tid`
     * const testimonialsWithTidOnly = await prisma.testimonials.findMany({ select: { tid: true } })
     * 
     */
    findMany<T extends testimonialsFindManyArgs>(args?: SelectSubset<T, testimonialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonials.
     * @param {testimonialsCreateArgs} args - Arguments to create a Testimonials.
     * @example
     * // Create one Testimonials
     * const Testimonials = await prisma.testimonials.create({
     *   data: {
     *     // ... data to create a Testimonials
     *   }
     * })
     * 
     */
    create<T extends testimonialsCreateArgs>(args: SelectSubset<T, testimonialsCreateArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {testimonialsCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonials = await prisma.testimonials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testimonialsCreateManyArgs>(args?: SelectSubset<T, testimonialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonials.
     * @param {testimonialsDeleteArgs} args - Arguments to delete one Testimonials.
     * @example
     * // Delete one Testimonials
     * const Testimonials = await prisma.testimonials.delete({
     *   where: {
     *     // ... filter to delete one Testimonials
     *   }
     * })
     * 
     */
    delete<T extends testimonialsDeleteArgs>(args: SelectSubset<T, testimonialsDeleteArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonials.
     * @param {testimonialsUpdateArgs} args - Arguments to update one Testimonials.
     * @example
     * // Update one Testimonials
     * const testimonials = await prisma.testimonials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testimonialsUpdateArgs>(args: SelectSubset<T, testimonialsUpdateArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {testimonialsDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testimonialsDeleteManyArgs>(args?: SelectSubset<T, testimonialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonials = await prisma.testimonials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testimonialsUpdateManyArgs>(args: SelectSubset<T, testimonialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonials.
     * @param {testimonialsUpsertArgs} args - Arguments to update or create a Testimonials.
     * @example
     * // Update or create a Testimonials
     * const testimonials = await prisma.testimonials.upsert({
     *   create: {
     *     // ... data to create a Testimonials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonials we want to update
     *   }
     * })
     */
    upsert<T extends testimonialsUpsertArgs>(args: SelectSubset<T, testimonialsUpsertArgs<ExtArgs>>): Prisma__testimonialsClient<$Result.GetResult<Prisma.$testimonialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonials.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends testimonialsCountArgs>(
      args?: Subset<T, testimonialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialsAggregateArgs>(args: Subset<T, TestimonialsAggregateArgs>): Prisma.PrismaPromise<GetTestimonialsAggregateType<T>>

    /**
     * Group by Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testimonialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testimonialsGroupByArgs['orderBy'] }
        : { orderBy?: testimonialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testimonialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testimonials model
   */
  readonly fields: testimonialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testimonials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testimonialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testimonials model
   */
  interface testimonialsFieldRefs {
    readonly tid: FieldRef<"testimonials", 'Int'>
    readonly tcustomer: FieldRef<"testimonials", 'String'>
    readonly trole: FieldRef<"testimonials", 'String'>
    readonly tphoto: FieldRef<"testimonials", 'String'>
    readonly tmessage: FieldRef<"testimonials", 'String'>
    readonly tstars: FieldRef<"testimonials", 'Int'>
    readonly tdate: FieldRef<"testimonials", 'DateTime'>
    readonly tstatus: FieldRef<"testimonials", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * testimonials findUnique
   */
  export type testimonialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where: testimonialsWhereUniqueInput
  }

  /**
   * testimonials findUniqueOrThrow
   */
  export type testimonialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where: testimonialsWhereUniqueInput
  }

  /**
   * testimonials findFirst
   */
  export type testimonialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where?: testimonialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialsOrderByWithRelationInput | testimonialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialsScalarFieldEnum | TestimonialsScalarFieldEnum[]
  }

  /**
   * testimonials findFirstOrThrow
   */
  export type testimonialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where?: testimonialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialsOrderByWithRelationInput | testimonialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialsScalarFieldEnum | TestimonialsScalarFieldEnum[]
  }

  /**
   * testimonials findMany
   */
  export type testimonialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where?: testimonialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialsOrderByWithRelationInput | testimonialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testimonials.
     */
    cursor?: testimonialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    distinct?: TestimonialsScalarFieldEnum | TestimonialsScalarFieldEnum[]
  }

  /**
   * testimonials create
   */
  export type testimonialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * The data needed to create a testimonials.
     */
    data: XOR<testimonialsCreateInput, testimonialsUncheckedCreateInput>
  }

  /**
   * testimonials createMany
   */
  export type testimonialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testimonials.
     */
    data: testimonialsCreateManyInput | testimonialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testimonials update
   */
  export type testimonialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * The data needed to update a testimonials.
     */
    data: XOR<testimonialsUpdateInput, testimonialsUncheckedUpdateInput>
    /**
     * Choose, which testimonials to update.
     */
    where: testimonialsWhereUniqueInput
  }

  /**
   * testimonials updateMany
   */
  export type testimonialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testimonials.
     */
    data: XOR<testimonialsUpdateManyMutationInput, testimonialsUncheckedUpdateManyInput>
    /**
     * Filter which testimonials to update
     */
    where?: testimonialsWhereInput
    /**
     * Limit how many testimonials to update.
     */
    limit?: number
  }

  /**
   * testimonials upsert
   */
  export type testimonialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * The filter to search for the testimonials to update in case it exists.
     */
    where: testimonialsWhereUniqueInput
    /**
     * In case the testimonials found by the `where` argument doesn't exist, create a new testimonials with this data.
     */
    create: XOR<testimonialsCreateInput, testimonialsUncheckedCreateInput>
    /**
     * In case the testimonials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testimonialsUpdateInput, testimonialsUncheckedUpdateInput>
  }

  /**
   * testimonials delete
   */
  export type testimonialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
    /**
     * Filter which testimonials to delete.
     */
    where: testimonialsWhereUniqueInput
  }

  /**
   * testimonials deleteMany
   */
  export type testimonialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonials to delete
     */
    where?: testimonialsWhereInput
    /**
     * Limit how many testimonials to delete.
     */
    limit?: number
  }

  /**
   * testimonials without action
   */
  export type testimonialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonials
     */
    select?: testimonialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonials
     */
    omit?: testimonialsOmit<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    id: number | null
    productid: number | null
    prod_waittime: number | null
    qty: number | null
    howmany: number | null
    amount: number | null
    commission: number | null
    driverfee: number | null
    driverlatitude: Decimal | null
    driverlongitude: Decimal | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    driverdeliverytime: number | null
    customerwaittime: number | null
    commission_paid: number | null
    driverrating: number | null
    views: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    id: number | null
    productid: number | null
    prod_waittime: number | null
    qty: number | null
    howmany: number | null
    amount: number | null
    commission: number | null
    driverfee: number | null
    driverlatitude: Decimal | null
    driverlongitude: Decimal | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    driverdeliverytime: number | null
    customerwaittime: number | null
    commission_paid: number | null
    driverrating: number | null
    views: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderref: string | null
    productid: number | null
    productname: string | null
    prod_waittime: number | null
    product_subscription: string | null
    qty: number | null
    orderdetails: string | null
    req_type: string | null
    task: string | null
    howmany: number | null
    amount: number | null
    commission: number | null
    driverfee: number | null
    driverid: string | null
    drivername: string | null
    driverphone: string | null
    driveremail: string | null
    drivervehicleplateno: string | null
    driverphoto: string | null
    fleetid: string | null
    driverlatitude: Decimal | null
    driverlongitude: Decimal | null
    driveraccept: string | null
    customerid: string | null
    customername: string | null
    customeremail: string | null
    customerphone: string | null
    customeraddress: string | null
    customerarea: string | null
    customerareagroup: string | null
    third_party_delivery: string | null
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    status: string | null
    paymentstatus: string | null
    paymentmode: string | null
    paymenttime: string | null
    driverdeliverystatus: string | null
    driverdeliverystatustime: string | null
    driverdeliverytime: number | null
    customerdeliverystatus: string | null
    customerdeliverystatustime: string | null
    customerwaittime: number | null
    orderprocessed: boolean | null
    commission_paid: number | null
    driverrating: number | null
    driverfeedback: string | null
    notes: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderref: string | null
    productid: number | null
    productname: string | null
    prod_waittime: number | null
    product_subscription: string | null
    qty: number | null
    orderdetails: string | null
    req_type: string | null
    task: string | null
    howmany: number | null
    amount: number | null
    commission: number | null
    driverfee: number | null
    driverid: string | null
    drivername: string | null
    driverphone: string | null
    driveremail: string | null
    drivervehicleplateno: string | null
    driverphoto: string | null
    fleetid: string | null
    driverlatitude: Decimal | null
    driverlongitude: Decimal | null
    driveraccept: string | null
    customerid: string | null
    customername: string | null
    customeremail: string | null
    customerphone: string | null
    customeraddress: string | null
    customerarea: string | null
    customerareagroup: string | null
    third_party_delivery: string | null
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal | null
    customerlongitude: Decimal | null
    status: string | null
    paymentstatus: string | null
    paymentmode: string | null
    paymenttime: string | null
    driverdeliverystatus: string | null
    driverdeliverystatustime: string | null
    driverdeliverytime: number | null
    customerdeliverystatus: string | null
    customerdeliverystatustime: string | null
    customerwaittime: number | null
    orderprocessed: boolean | null
    commission_paid: number | null
    driverrating: number | null
    driverfeedback: string | null
    notes: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    uuid: number
    orderref: number
    productid: number
    productname: number
    prod_waittime: number
    product_subscription: number
    qty: number
    orderdetails: number
    req_type: number
    task: number
    howmany: number
    amount: number
    commission: number
    driverfee: number
    driverid: number
    drivername: number
    driverphone: number
    driveremail: number
    drivervehicleplateno: number
    driverphoto: number
    fleetid: number
    driverlatitude: number
    driverlongitude: number
    driveraccept: number
    customerid: number
    customername: number
    customeremail: number
    customerphone: number
    customeraddress: number
    customerarea: number
    customerareagroup: number
    third_party_delivery: number
    third_party_name: number
    third_party_phone: number
    third_party_areagroup: number
    third_party_address: number
    customerlatitude: number
    customerlongitude: number
    status: number
    paymentstatus: number
    paymentmode: number
    paymenttime: number
    driverdeliverystatus: number
    driverdeliverystatustime: number
    driverdeliverytime: number
    customerdeliverystatus: number
    customerdeliverystatustime: number
    customerwaittime: number
    orderprocessed: number
    commission_paid: number
    driverrating: number
    driverfeedback: number
    notes: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    id?: true
    productid?: true
    prod_waittime?: true
    qty?: true
    howmany?: true
    amount?: true
    commission?: true
    driverfee?: true
    driverlatitude?: true
    driverlongitude?: true
    customerlatitude?: true
    customerlongitude?: true
    driverdeliverytime?: true
    customerwaittime?: true
    commission_paid?: true
    driverrating?: true
    views?: true
  }

  export type TransactionsSumAggregateInputType = {
    id?: true
    productid?: true
    prod_waittime?: true
    qty?: true
    howmany?: true
    amount?: true
    commission?: true
    driverfee?: true
    driverlatitude?: true
    driverlongitude?: true
    customerlatitude?: true
    customerlongitude?: true
    driverdeliverytime?: true
    customerwaittime?: true
    commission_paid?: true
    driverrating?: true
    views?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    uuid?: true
    orderref?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    product_subscription?: true
    qty?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    amount?: true
    commission?: true
    driverfee?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    driverphoto?: true
    fleetid?: true
    driverlatitude?: true
    driverlongitude?: true
    driveraccept?: true
    customerid?: true
    customername?: true
    customeremail?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    status?: true
    paymentstatus?: true
    paymentmode?: true
    paymenttime?: true
    driverdeliverystatus?: true
    driverdeliverystatustime?: true
    driverdeliverytime?: true
    customerdeliverystatus?: true
    customerdeliverystatustime?: true
    customerwaittime?: true
    orderprocessed?: true
    commission_paid?: true
    driverrating?: true
    driverfeedback?: true
    notes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    uuid?: true
    orderref?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    product_subscription?: true
    qty?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    amount?: true
    commission?: true
    driverfee?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    driverphoto?: true
    fleetid?: true
    driverlatitude?: true
    driverlongitude?: true
    driveraccept?: true
    customerid?: true
    customername?: true
    customeremail?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    status?: true
    paymentstatus?: true
    paymentmode?: true
    paymenttime?: true
    driverdeliverystatus?: true
    driverdeliverystatustime?: true
    driverdeliverytime?: true
    customerdeliverystatus?: true
    customerdeliverystatustime?: true
    customerwaittime?: true
    orderprocessed?: true
    commission_paid?: true
    driverrating?: true
    driverfeedback?: true
    notes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    uuid?: true
    orderref?: true
    productid?: true
    productname?: true
    prod_waittime?: true
    product_subscription?: true
    qty?: true
    orderdetails?: true
    req_type?: true
    task?: true
    howmany?: true
    amount?: true
    commission?: true
    driverfee?: true
    driverid?: true
    drivername?: true
    driverphone?: true
    driveremail?: true
    drivervehicleplateno?: true
    driverphoto?: true
    fleetid?: true
    driverlatitude?: true
    driverlongitude?: true
    driveraccept?: true
    customerid?: true
    customername?: true
    customeremail?: true
    customerphone?: true
    customeraddress?: true
    customerarea?: true
    customerareagroup?: true
    third_party_delivery?: true
    third_party_name?: true
    third_party_phone?: true
    third_party_areagroup?: true
    third_party_address?: true
    customerlatitude?: true
    customerlongitude?: true
    status?: true
    paymentstatus?: true
    paymentmode?: true
    paymenttime?: true
    driverdeliverystatus?: true
    driverdeliverystatustime?: true
    driverdeliverytime?: true
    customerdeliverystatus?: true
    customerdeliverystatustime?: true
    customerwaittime?: true
    orderprocessed?: true
    commission_paid?: true
    driverrating?: true
    driverfeedback?: true
    notes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: number
    uuid: string | null
    orderref: string
    productid: number
    productname: string
    prod_waittime: number | null
    product_subscription: string
    qty: number
    orderdetails: string
    req_type: string
    task: string | null
    howmany: number | null
    amount: number
    commission: number
    driverfee: number
    driverid: string | null
    drivername: string
    driverphone: string
    driveremail: string
    drivervehicleplateno: string
    driverphoto: string
    fleetid: string | null
    driverlatitude: Decimal
    driverlongitude: Decimal
    driveraccept: string | null
    customerid: string | null
    customername: string
    customeremail: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup: string | null
    third_party_delivery: string
    third_party_name: string | null
    third_party_phone: string | null
    third_party_areagroup: string | null
    third_party_address: string | null
    customerlatitude: Decimal
    customerlongitude: Decimal
    status: string
    paymentstatus: string
    paymentmode: string
    paymenttime: string | null
    driverdeliverystatus: string
    driverdeliverystatustime: string | null
    driverdeliverytime: number
    customerdeliverystatus: string
    customerdeliverystatustime: string | null
    customerwaittime: number
    orderprocessed: boolean
    commission_paid: number
    driverrating: number | null
    driverfeedback: string | null
    notes: string
    views: number
    createdAt: Date
    updatedAt: Date
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    orderref?: boolean
    productid?: boolean
    productname?: boolean
    prod_waittime?: boolean
    product_subscription?: boolean
    qty?: boolean
    orderdetails?: boolean
    req_type?: boolean
    task?: boolean
    howmany?: boolean
    amount?: boolean
    commission?: boolean
    driverfee?: boolean
    driverid?: boolean
    drivername?: boolean
    driverphone?: boolean
    driveremail?: boolean
    drivervehicleplateno?: boolean
    driverphoto?: boolean
    fleetid?: boolean
    driverlatitude?: boolean
    driverlongitude?: boolean
    driveraccept?: boolean
    customerid?: boolean
    customername?: boolean
    customeremail?: boolean
    customerphone?: boolean
    customeraddress?: boolean
    customerarea?: boolean
    customerareagroup?: boolean
    third_party_delivery?: boolean
    third_party_name?: boolean
    third_party_phone?: boolean
    third_party_areagroup?: boolean
    third_party_address?: boolean
    customerlatitude?: boolean
    customerlongitude?: boolean
    status?: boolean
    paymentstatus?: boolean
    paymentmode?: boolean
    paymenttime?: boolean
    driverdeliverystatus?: boolean
    driverdeliverystatustime?: boolean
    driverdeliverytime?: boolean
    customerdeliverystatus?: boolean
    customerdeliverystatustime?: boolean
    customerwaittime?: boolean
    orderprocessed?: boolean
    commission_paid?: boolean
    driverrating?: boolean
    driverfeedback?: boolean
    notes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactions"]>



  export type transactionsSelectScalar = {
    id?: boolean
    uuid?: boolean
    orderref?: boolean
    productid?: boolean
    productname?: boolean
    prod_waittime?: boolean
    product_subscription?: boolean
    qty?: boolean
    orderdetails?: boolean
    req_type?: boolean
    task?: boolean
    howmany?: boolean
    amount?: boolean
    commission?: boolean
    driverfee?: boolean
    driverid?: boolean
    drivername?: boolean
    driverphone?: boolean
    driveremail?: boolean
    drivervehicleplateno?: boolean
    driverphoto?: boolean
    fleetid?: boolean
    driverlatitude?: boolean
    driverlongitude?: boolean
    driveraccept?: boolean
    customerid?: boolean
    customername?: boolean
    customeremail?: boolean
    customerphone?: boolean
    customeraddress?: boolean
    customerarea?: boolean
    customerareagroup?: boolean
    third_party_delivery?: boolean
    third_party_name?: boolean
    third_party_phone?: boolean
    third_party_areagroup?: boolean
    third_party_address?: boolean
    customerlatitude?: boolean
    customerlongitude?: boolean
    status?: boolean
    paymentstatus?: boolean
    paymentmode?: boolean
    paymenttime?: boolean
    driverdeliverystatus?: boolean
    driverdeliverystatustime?: boolean
    driverdeliverytime?: boolean
    customerdeliverystatus?: boolean
    customerdeliverystatustime?: boolean
    customerwaittime?: boolean
    orderprocessed?: boolean
    commission_paid?: boolean
    driverrating?: boolean
    driverfeedback?: boolean
    notes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "orderref" | "productid" | "productname" | "prod_waittime" | "product_subscription" | "qty" | "orderdetails" | "req_type" | "task" | "howmany" | "amount" | "commission" | "driverfee" | "driverid" | "drivername" | "driverphone" | "driveremail" | "drivervehicleplateno" | "driverphoto" | "fleetid" | "driverlatitude" | "driverlongitude" | "driveraccept" | "customerid" | "customername" | "customeremail" | "customerphone" | "customeraddress" | "customerarea" | "customerareagroup" | "third_party_delivery" | "third_party_name" | "third_party_phone" | "third_party_areagroup" | "third_party_address" | "customerlatitude" | "customerlongitude" | "status" | "paymentstatus" | "paymentmode" | "paymenttime" | "driverdeliverystatus" | "driverdeliverystatustime" | "driverdeliverytime" | "customerdeliverystatus" | "customerdeliverystatustime" | "customerwaittime" | "orderprocessed" | "commission_paid" | "driverrating" | "driverfeedback" | "notes" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["transactions"]>

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      orderref: string
      productid: number
      productname: string
      prod_waittime: number | null
      product_subscription: string
      qty: number
      orderdetails: string
      req_type: string
      task: string | null
      howmany: number | null
      amount: number
      commission: number
      driverfee: number
      driverid: string | null
      drivername: string
      driverphone: string
      driveremail: string
      drivervehicleplateno: string
      driverphoto: string
      fleetid: string | null
      driverlatitude: Prisma.Decimal
      driverlongitude: Prisma.Decimal
      driveraccept: string | null
      customerid: string | null
      customername: string
      customeremail: string
      customerphone: string
      customeraddress: string
      customerarea: string
      customerareagroup: string | null
      third_party_delivery: string
      third_party_name: string | null
      third_party_phone: string | null
      third_party_areagroup: string | null
      third_party_address: string | null
      customerlatitude: Prisma.Decimal
      customerlongitude: Prisma.Decimal
      status: string
      paymentstatus: string
      paymentmode: string
      paymenttime: string | null
      driverdeliverystatus: string
      driverdeliverystatustime: string | null
      driverdeliverytime: number
      customerdeliverystatus: string
      customerdeliverystatustime: string | null
      customerwaittime: number
      orderprocessed: boolean
      commission_paid: number
      driverrating: number | null
      driverfeedback: string | null
      notes: string
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */
  interface transactionsFieldRefs {
    readonly id: FieldRef<"transactions", 'Int'>
    readonly uuid: FieldRef<"transactions", 'String'>
    readonly orderref: FieldRef<"transactions", 'String'>
    readonly productid: FieldRef<"transactions", 'Int'>
    readonly productname: FieldRef<"transactions", 'String'>
    readonly prod_waittime: FieldRef<"transactions", 'Int'>
    readonly product_subscription: FieldRef<"transactions", 'String'>
    readonly qty: FieldRef<"transactions", 'Int'>
    readonly orderdetails: FieldRef<"transactions", 'String'>
    readonly req_type: FieldRef<"transactions", 'String'>
    readonly task: FieldRef<"transactions", 'String'>
    readonly howmany: FieldRef<"transactions", 'Int'>
    readonly amount: FieldRef<"transactions", 'Float'>
    readonly commission: FieldRef<"transactions", 'Float'>
    readonly driverfee: FieldRef<"transactions", 'Float'>
    readonly driverid: FieldRef<"transactions", 'String'>
    readonly drivername: FieldRef<"transactions", 'String'>
    readonly driverphone: FieldRef<"transactions", 'String'>
    readonly driveremail: FieldRef<"transactions", 'String'>
    readonly drivervehicleplateno: FieldRef<"transactions", 'String'>
    readonly driverphoto: FieldRef<"transactions", 'String'>
    readonly fleetid: FieldRef<"transactions", 'String'>
    readonly driverlatitude: FieldRef<"transactions", 'Decimal'>
    readonly driverlongitude: FieldRef<"transactions", 'Decimal'>
    readonly driveraccept: FieldRef<"transactions", 'String'>
    readonly customerid: FieldRef<"transactions", 'String'>
    readonly customername: FieldRef<"transactions", 'String'>
    readonly customeremail: FieldRef<"transactions", 'String'>
    readonly customerphone: FieldRef<"transactions", 'String'>
    readonly customeraddress: FieldRef<"transactions", 'String'>
    readonly customerarea: FieldRef<"transactions", 'String'>
    readonly customerareagroup: FieldRef<"transactions", 'String'>
    readonly third_party_delivery: FieldRef<"transactions", 'String'>
    readonly third_party_name: FieldRef<"transactions", 'String'>
    readonly third_party_phone: FieldRef<"transactions", 'String'>
    readonly third_party_areagroup: FieldRef<"transactions", 'String'>
    readonly third_party_address: FieldRef<"transactions", 'String'>
    readonly customerlatitude: FieldRef<"transactions", 'Decimal'>
    readonly customerlongitude: FieldRef<"transactions", 'Decimal'>
    readonly status: FieldRef<"transactions", 'String'>
    readonly paymentstatus: FieldRef<"transactions", 'String'>
    readonly paymentmode: FieldRef<"transactions", 'String'>
    readonly paymenttime: FieldRef<"transactions", 'String'>
    readonly driverdeliverystatus: FieldRef<"transactions", 'String'>
    readonly driverdeliverystatustime: FieldRef<"transactions", 'String'>
    readonly driverdeliverytime: FieldRef<"transactions", 'Int'>
    readonly customerdeliverystatus: FieldRef<"transactions", 'String'>
    readonly customerdeliverystatustime: FieldRef<"transactions", 'String'>
    readonly customerwaittime: FieldRef<"transactions", 'Int'>
    readonly orderprocessed: FieldRef<"transactions", 'Boolean'>
    readonly commission_paid: FieldRef<"transactions", 'Int'>
    readonly driverrating: FieldRef<"transactions", 'Int'>
    readonly driverfeedback: FieldRef<"transactions", 'String'>
    readonly notes: FieldRef<"transactions", 'String'>
    readonly views: FieldRef<"transactions", 'Int'>
    readonly createdAt: FieldRef<"transactions", 'DateTime'>
    readonly updatedAt: FieldRef<"transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
  }


  /**
   * Model usermessages
   */

  export type AggregateUsermessages = {
    _count: UsermessagesCountAggregateOutputType | null
    _avg: UsermessagesAvgAggregateOutputType | null
    _sum: UsermessagesSumAggregateOutputType | null
    _min: UsermessagesMinAggregateOutputType | null
    _max: UsermessagesMaxAggregateOutputType | null
  }

  export type UsermessagesAvgAggregateOutputType = {
    umsgid: number | null
    umsg_read: number | null
  }

  export type UsermessagesSumAggregateOutputType = {
    umsgid: number | null
    umsg_read: number | null
  }

  export type UsermessagesMinAggregateOutputType = {
    umsgid: number | null
    umsg_user: string | null
    umsg_cat: string | null
    umsg_title: string | null
    umsg_body: string | null
    umsg_read: number | null
    umsg_time: Date | null
    umsg_sender: string | null
  }

  export type UsermessagesMaxAggregateOutputType = {
    umsgid: number | null
    umsg_user: string | null
    umsg_cat: string | null
    umsg_title: string | null
    umsg_body: string | null
    umsg_read: number | null
    umsg_time: Date | null
    umsg_sender: string | null
  }

  export type UsermessagesCountAggregateOutputType = {
    umsgid: number
    umsg_user: number
    umsg_cat: number
    umsg_title: number
    umsg_body: number
    umsg_read: number
    umsg_time: number
    umsg_sender: number
    _all: number
  }


  export type UsermessagesAvgAggregateInputType = {
    umsgid?: true
    umsg_read?: true
  }

  export type UsermessagesSumAggregateInputType = {
    umsgid?: true
    umsg_read?: true
  }

  export type UsermessagesMinAggregateInputType = {
    umsgid?: true
    umsg_user?: true
    umsg_cat?: true
    umsg_title?: true
    umsg_body?: true
    umsg_read?: true
    umsg_time?: true
    umsg_sender?: true
  }

  export type UsermessagesMaxAggregateInputType = {
    umsgid?: true
    umsg_user?: true
    umsg_cat?: true
    umsg_title?: true
    umsg_body?: true
    umsg_read?: true
    umsg_time?: true
    umsg_sender?: true
  }

  export type UsermessagesCountAggregateInputType = {
    umsgid?: true
    umsg_user?: true
    umsg_cat?: true
    umsg_title?: true
    umsg_body?: true
    umsg_read?: true
    umsg_time?: true
    umsg_sender?: true
    _all?: true
  }

  export type UsermessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usermessages to aggregate.
     */
    where?: usermessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usermessages to fetch.
     */
    orderBy?: usermessagesOrderByWithRelationInput | usermessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usermessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usermessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usermessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usermessages
    **/
    _count?: true | UsermessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsermessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsermessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsermessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsermessagesMaxAggregateInputType
  }

  export type GetUsermessagesAggregateType<T extends UsermessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsermessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsermessages[P]>
      : GetScalarType<T[P], AggregateUsermessages[P]>
  }




  export type usermessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usermessagesWhereInput
    orderBy?: usermessagesOrderByWithAggregationInput | usermessagesOrderByWithAggregationInput[]
    by: UsermessagesScalarFieldEnum[] | UsermessagesScalarFieldEnum
    having?: usermessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsermessagesCountAggregateInputType | true
    _avg?: UsermessagesAvgAggregateInputType
    _sum?: UsermessagesSumAggregateInputType
    _min?: UsermessagesMinAggregateInputType
    _max?: UsermessagesMaxAggregateInputType
  }

  export type UsermessagesGroupByOutputType = {
    umsgid: number
    umsg_user: string
    umsg_cat: string
    umsg_title: string
    umsg_body: string
    umsg_read: number
    umsg_time: Date
    umsg_sender: string
    _count: UsermessagesCountAggregateOutputType | null
    _avg: UsermessagesAvgAggregateOutputType | null
    _sum: UsermessagesSumAggregateOutputType | null
    _min: UsermessagesMinAggregateOutputType | null
    _max: UsermessagesMaxAggregateOutputType | null
  }

  type GetUsermessagesGroupByPayload<T extends usermessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsermessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsermessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsermessagesGroupByOutputType[P]>
            : GetScalarType<T[P], UsermessagesGroupByOutputType[P]>
        }
      >
    >


  export type usermessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    umsgid?: boolean
    umsg_user?: boolean
    umsg_cat?: boolean
    umsg_title?: boolean
    umsg_body?: boolean
    umsg_read?: boolean
    umsg_time?: boolean
    umsg_sender?: boolean
  }, ExtArgs["result"]["usermessages"]>



  export type usermessagesSelectScalar = {
    umsgid?: boolean
    umsg_user?: boolean
    umsg_cat?: boolean
    umsg_title?: boolean
    umsg_body?: boolean
    umsg_read?: boolean
    umsg_time?: boolean
    umsg_sender?: boolean
  }

  export type usermessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"umsgid" | "umsg_user" | "umsg_cat" | "umsg_title" | "umsg_body" | "umsg_read" | "umsg_time" | "umsg_sender", ExtArgs["result"]["usermessages"]>

  export type $usermessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usermessages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      umsgid: number
      umsg_user: string
      umsg_cat: string
      umsg_title: string
      umsg_body: string
      umsg_read: number
      umsg_time: Date
      umsg_sender: string
    }, ExtArgs["result"]["usermessages"]>
    composites: {}
  }

  type usermessagesGetPayload<S extends boolean | null | undefined | usermessagesDefaultArgs> = $Result.GetResult<Prisma.$usermessagesPayload, S>

  type usermessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usermessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsermessagesCountAggregateInputType | true
    }

  export interface usermessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usermessages'], meta: { name: 'usermessages' } }
    /**
     * Find zero or one Usermessages that matches the filter.
     * @param {usermessagesFindUniqueArgs} args - Arguments to find a Usermessages
     * @example
     * // Get one Usermessages
     * const usermessages = await prisma.usermessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usermessagesFindUniqueArgs>(args: SelectSubset<T, usermessagesFindUniqueArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usermessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usermessagesFindUniqueOrThrowArgs} args - Arguments to find a Usermessages
     * @example
     * // Get one Usermessages
     * const usermessages = await prisma.usermessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usermessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, usermessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usermessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesFindFirstArgs} args - Arguments to find a Usermessages
     * @example
     * // Get one Usermessages
     * const usermessages = await prisma.usermessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usermessagesFindFirstArgs>(args?: SelectSubset<T, usermessagesFindFirstArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usermessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesFindFirstOrThrowArgs} args - Arguments to find a Usermessages
     * @example
     * // Get one Usermessages
     * const usermessages = await prisma.usermessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usermessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, usermessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usermessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usermessages
     * const usermessages = await prisma.usermessages.findMany()
     * 
     * // Get first 10 Usermessages
     * const usermessages = await prisma.usermessages.findMany({ take: 10 })
     * 
     * // Only select the `umsgid`
     * const usermessagesWithUmsgidOnly = await prisma.usermessages.findMany({ select: { umsgid: true } })
     * 
     */
    findMany<T extends usermessagesFindManyArgs>(args?: SelectSubset<T, usermessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usermessages.
     * @param {usermessagesCreateArgs} args - Arguments to create a Usermessages.
     * @example
     * // Create one Usermessages
     * const Usermessages = await prisma.usermessages.create({
     *   data: {
     *     // ... data to create a Usermessages
     *   }
     * })
     * 
     */
    create<T extends usermessagesCreateArgs>(args: SelectSubset<T, usermessagesCreateArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usermessages.
     * @param {usermessagesCreateManyArgs} args - Arguments to create many Usermessages.
     * @example
     * // Create many Usermessages
     * const usermessages = await prisma.usermessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usermessagesCreateManyArgs>(args?: SelectSubset<T, usermessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usermessages.
     * @param {usermessagesDeleteArgs} args - Arguments to delete one Usermessages.
     * @example
     * // Delete one Usermessages
     * const Usermessages = await prisma.usermessages.delete({
     *   where: {
     *     // ... filter to delete one Usermessages
     *   }
     * })
     * 
     */
    delete<T extends usermessagesDeleteArgs>(args: SelectSubset<T, usermessagesDeleteArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usermessages.
     * @param {usermessagesUpdateArgs} args - Arguments to update one Usermessages.
     * @example
     * // Update one Usermessages
     * const usermessages = await prisma.usermessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usermessagesUpdateArgs>(args: SelectSubset<T, usermessagesUpdateArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usermessages.
     * @param {usermessagesDeleteManyArgs} args - Arguments to filter Usermessages to delete.
     * @example
     * // Delete a few Usermessages
     * const { count } = await prisma.usermessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usermessagesDeleteManyArgs>(args?: SelectSubset<T, usermessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usermessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usermessages
     * const usermessages = await prisma.usermessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usermessagesUpdateManyArgs>(args: SelectSubset<T, usermessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usermessages.
     * @param {usermessagesUpsertArgs} args - Arguments to update or create a Usermessages.
     * @example
     * // Update or create a Usermessages
     * const usermessages = await prisma.usermessages.upsert({
     *   create: {
     *     // ... data to create a Usermessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usermessages we want to update
     *   }
     * })
     */
    upsert<T extends usermessagesUpsertArgs>(args: SelectSubset<T, usermessagesUpsertArgs<ExtArgs>>): Prisma__usermessagesClient<$Result.GetResult<Prisma.$usermessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usermessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesCountArgs} args - Arguments to filter Usermessages to count.
     * @example
     * // Count the number of Usermessages
     * const count = await prisma.usermessages.count({
     *   where: {
     *     // ... the filter for the Usermessages we want to count
     *   }
     * })
    **/
    count<T extends usermessagesCountArgs>(
      args?: Subset<T, usermessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsermessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usermessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsermessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsermessagesAggregateArgs>(args: Subset<T, UsermessagesAggregateArgs>): Prisma.PrismaPromise<GetUsermessagesAggregateType<T>>

    /**
     * Group by Usermessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usermessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usermessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usermessagesGroupByArgs['orderBy'] }
        : { orderBy?: usermessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usermessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsermessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usermessages model
   */
  readonly fields: usermessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usermessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usermessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usermessages model
   */
  interface usermessagesFieldRefs {
    readonly umsgid: FieldRef<"usermessages", 'Int'>
    readonly umsg_user: FieldRef<"usermessages", 'String'>
    readonly umsg_cat: FieldRef<"usermessages", 'String'>
    readonly umsg_title: FieldRef<"usermessages", 'String'>
    readonly umsg_body: FieldRef<"usermessages", 'String'>
    readonly umsg_read: FieldRef<"usermessages", 'Int'>
    readonly umsg_time: FieldRef<"usermessages", 'DateTime'>
    readonly umsg_sender: FieldRef<"usermessages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usermessages findUnique
   */
  export type usermessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter, which usermessages to fetch.
     */
    where: usermessagesWhereUniqueInput
  }

  /**
   * usermessages findUniqueOrThrow
   */
  export type usermessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter, which usermessages to fetch.
     */
    where: usermessagesWhereUniqueInput
  }

  /**
   * usermessages findFirst
   */
  export type usermessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter, which usermessages to fetch.
     */
    where?: usermessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usermessages to fetch.
     */
    orderBy?: usermessagesOrderByWithRelationInput | usermessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usermessages.
     */
    cursor?: usermessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usermessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usermessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usermessages.
     */
    distinct?: UsermessagesScalarFieldEnum | UsermessagesScalarFieldEnum[]
  }

  /**
   * usermessages findFirstOrThrow
   */
  export type usermessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter, which usermessages to fetch.
     */
    where?: usermessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usermessages to fetch.
     */
    orderBy?: usermessagesOrderByWithRelationInput | usermessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usermessages.
     */
    cursor?: usermessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usermessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usermessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usermessages.
     */
    distinct?: UsermessagesScalarFieldEnum | UsermessagesScalarFieldEnum[]
  }

  /**
   * usermessages findMany
   */
  export type usermessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter, which usermessages to fetch.
     */
    where?: usermessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usermessages to fetch.
     */
    orderBy?: usermessagesOrderByWithRelationInput | usermessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usermessages.
     */
    cursor?: usermessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usermessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usermessages.
     */
    skip?: number
    distinct?: UsermessagesScalarFieldEnum | UsermessagesScalarFieldEnum[]
  }

  /**
   * usermessages create
   */
  export type usermessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * The data needed to create a usermessages.
     */
    data: XOR<usermessagesCreateInput, usermessagesUncheckedCreateInput>
  }

  /**
   * usermessages createMany
   */
  export type usermessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usermessages.
     */
    data: usermessagesCreateManyInput | usermessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usermessages update
   */
  export type usermessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * The data needed to update a usermessages.
     */
    data: XOR<usermessagesUpdateInput, usermessagesUncheckedUpdateInput>
    /**
     * Choose, which usermessages to update.
     */
    where: usermessagesWhereUniqueInput
  }

  /**
   * usermessages updateMany
   */
  export type usermessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usermessages.
     */
    data: XOR<usermessagesUpdateManyMutationInput, usermessagesUncheckedUpdateManyInput>
    /**
     * Filter which usermessages to update
     */
    where?: usermessagesWhereInput
    /**
     * Limit how many usermessages to update.
     */
    limit?: number
  }

  /**
   * usermessages upsert
   */
  export type usermessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * The filter to search for the usermessages to update in case it exists.
     */
    where: usermessagesWhereUniqueInput
    /**
     * In case the usermessages found by the `where` argument doesn't exist, create a new usermessages with this data.
     */
    create: XOR<usermessagesCreateInput, usermessagesUncheckedCreateInput>
    /**
     * In case the usermessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usermessagesUpdateInput, usermessagesUncheckedUpdateInput>
  }

  /**
   * usermessages delete
   */
  export type usermessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
    /**
     * Filter which usermessages to delete.
     */
    where: usermessagesWhereUniqueInput
  }

  /**
   * usermessages deleteMany
   */
  export type usermessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usermessages to delete
     */
    where?: usermessagesWhereInput
    /**
     * Limit how many usermessages to delete.
     */
    limit?: number
  }

  /**
   * usermessages without action
   */
  export type usermessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usermessages
     */
    select?: usermessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usermessages
     */
    omit?: usermessagesOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    fleetid: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    commissions_outstanding: number | null
    wm_wait_list: number | null
    views: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    fleetid: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    commissions_outstanding: number | null
    wm_wait_list: number | null
    views: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    fleetid: number | null
    name: string | null
    first_name: string | null
    last_name: string | null
    username: string | null
    email: string | null
    password: string | null
    phone: string | null
    dob: string | null
    subscription_plan: string | null
    subscription_end: Date | null
    address: string | null
    area: string | null
    areagroup: string | null
    residencestate: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    role: string | null
    user_type: string | null
    expotoken: string | null
    photo: string | null
    identification: string | null
    identification_back: string | null
    drv_license: string | null
    drv_license_back: string | null
    drv_vehicle_license_plate_no: string | null
    drv_vehicle_capacity: string | null
    drv_vehicle_make: string | null
    drv_vehicle_meterid: string | null
    drv_account_name: string | null
    drv_account_no: string | null
    drv_bank: string | null
    psv_customer_name: string | null
    psv_account_name: string | null
    psv_account_number: string | null
    psv_bank: string | null
    isverified: boolean | null
    verifiedby: string | null
    isavailable: boolean | null
    isavailable_by: string | null
    isavailable_reason: string | null
    commissions_outstanding: number | null
    commission_payment_ref: string | null
    isactive: boolean | null
    isadmin: boolean | null
    terms: boolean | null
    enable2fa: string | null
    code2fa: string | null
    expiry2fa: string | null
    signupotp: string | null
    wm_wait_list: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    fleetid: number | null
    name: string | null
    first_name: string | null
    last_name: string | null
    username: string | null
    email: string | null
    password: string | null
    phone: string | null
    dob: string | null
    subscription_plan: string | null
    subscription_end: Date | null
    address: string | null
    area: string | null
    areagroup: string | null
    residencestate: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    role: string | null
    user_type: string | null
    expotoken: string | null
    photo: string | null
    identification: string | null
    identification_back: string | null
    drv_license: string | null
    drv_license_back: string | null
    drv_vehicle_license_plate_no: string | null
    drv_vehicle_capacity: string | null
    drv_vehicle_make: string | null
    drv_vehicle_meterid: string | null
    drv_account_name: string | null
    drv_account_no: string | null
    drv_bank: string | null
    psv_customer_name: string | null
    psv_account_name: string | null
    psv_account_number: string | null
    psv_bank: string | null
    isverified: boolean | null
    verifiedby: string | null
    isavailable: boolean | null
    isavailable_by: string | null
    isavailable_reason: string | null
    commissions_outstanding: number | null
    commission_payment_ref: string | null
    isactive: boolean | null
    isadmin: boolean | null
    terms: boolean | null
    enable2fa: string | null
    code2fa: string | null
    expiry2fa: string | null
    signupotp: string | null
    wm_wait_list: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    uuid: number
    fleetid: number
    name: number
    first_name: number
    last_name: number
    username: number
    email: number
    password: number
    phone: number
    dob: number
    subscription_plan: number
    subscription_end: number
    address: number
    area: number
    areagroup: number
    residencestate: number
    latitude: number
    longitude: number
    role: number
    user_type: number
    expotoken: number
    photo: number
    identification: number
    identification_back: number
    drv_license: number
    drv_license_back: number
    drv_vehicle_license_plate_no: number
    drv_vehicle_capacity: number
    drv_vehicle_make: number
    drv_vehicle_meterid: number
    drv_account_name: number
    drv_account_no: number
    drv_bank: number
    psv_customer_name: number
    psv_account_name: number
    psv_account_number: number
    psv_bank: number
    isverified: number
    verifiedby: number
    isavailable: number
    isavailable_by: number
    isavailable_reason: number
    commissions_outstanding: number
    commission_payment_ref: number
    isactive: number
    isadmin: number
    terms: number
    enable2fa: number
    code2fa: number
    expiry2fa: number
    signupotp: number
    wm_wait_list: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    fleetid?: true
    latitude?: true
    longitude?: true
    commissions_outstanding?: true
    wm_wait_list?: true
    views?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    fleetid?: true
    latitude?: true
    longitude?: true
    commissions_outstanding?: true
    wm_wait_list?: true
    views?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    uuid?: true
    fleetid?: true
    name?: true
    first_name?: true
    last_name?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    dob?: true
    subscription_plan?: true
    subscription_end?: true
    address?: true
    area?: true
    areagroup?: true
    residencestate?: true
    latitude?: true
    longitude?: true
    role?: true
    user_type?: true
    expotoken?: true
    photo?: true
    identification?: true
    identification_back?: true
    drv_license?: true
    drv_license_back?: true
    drv_vehicle_license_plate_no?: true
    drv_vehicle_capacity?: true
    drv_vehicle_make?: true
    drv_vehicle_meterid?: true
    drv_account_name?: true
    drv_account_no?: true
    drv_bank?: true
    psv_customer_name?: true
    psv_account_name?: true
    psv_account_number?: true
    psv_bank?: true
    isverified?: true
    verifiedby?: true
    isavailable?: true
    isavailable_by?: true
    isavailable_reason?: true
    commissions_outstanding?: true
    commission_payment_ref?: true
    isactive?: true
    isadmin?: true
    terms?: true
    enable2fa?: true
    code2fa?: true
    expiry2fa?: true
    signupotp?: true
    wm_wait_list?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    uuid?: true
    fleetid?: true
    name?: true
    first_name?: true
    last_name?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    dob?: true
    subscription_plan?: true
    subscription_end?: true
    address?: true
    area?: true
    areagroup?: true
    residencestate?: true
    latitude?: true
    longitude?: true
    role?: true
    user_type?: true
    expotoken?: true
    photo?: true
    identification?: true
    identification_back?: true
    drv_license?: true
    drv_license_back?: true
    drv_vehicle_license_plate_no?: true
    drv_vehicle_capacity?: true
    drv_vehicle_make?: true
    drv_vehicle_meterid?: true
    drv_account_name?: true
    drv_account_no?: true
    drv_bank?: true
    psv_customer_name?: true
    psv_account_name?: true
    psv_account_number?: true
    psv_bank?: true
    isverified?: true
    verifiedby?: true
    isavailable?: true
    isavailable_by?: true
    isavailable_reason?: true
    commissions_outstanding?: true
    commission_payment_ref?: true
    isactive?: true
    isadmin?: true
    terms?: true
    enable2fa?: true
    code2fa?: true
    expiry2fa?: true
    signupotp?: true
    wm_wait_list?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    uuid?: true
    fleetid?: true
    name?: true
    first_name?: true
    last_name?: true
    username?: true
    email?: true
    password?: true
    phone?: true
    dob?: true
    subscription_plan?: true
    subscription_end?: true
    address?: true
    area?: true
    areagroup?: true
    residencestate?: true
    latitude?: true
    longitude?: true
    role?: true
    user_type?: true
    expotoken?: true
    photo?: true
    identification?: true
    identification_back?: true
    drv_license?: true
    drv_license_back?: true
    drv_vehicle_license_plate_no?: true
    drv_vehicle_capacity?: true
    drv_vehicle_make?: true
    drv_vehicle_meterid?: true
    drv_account_name?: true
    drv_account_no?: true
    drv_bank?: true
    psv_customer_name?: true
    psv_account_name?: true
    psv_account_number?: true
    psv_bank?: true
    isverified?: true
    verifiedby?: true
    isavailable?: true
    isavailable_by?: true
    isavailable_reason?: true
    commissions_outstanding?: true
    commission_payment_ref?: true
    isactive?: true
    isadmin?: true
    terms?: true
    enable2fa?: true
    code2fa?: true
    expiry2fa?: true
    signupotp?: true
    wm_wait_list?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    uuid: string | null
    fleetid: number | null
    name: string
    first_name: string | null
    last_name: string | null
    username: string
    email: string
    password: string
    phone: string | null
    dob: string | null
    subscription_plan: string
    subscription_end: Date | null
    address: string | null
    area: string | null
    areagroup: string | null
    residencestate: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    role: string
    user_type: string | null
    expotoken: string | null
    photo: string | null
    identification: string | null
    identification_back: string | null
    drv_license: string | null
    drv_license_back: string | null
    drv_vehicle_license_plate_no: string | null
    drv_vehicle_capacity: string | null
    drv_vehicle_make: string | null
    drv_vehicle_meterid: string | null
    drv_account_name: string | null
    drv_account_no: string | null
    drv_bank: string | null
    psv_customer_name: string | null
    psv_account_name: string | null
    psv_account_number: string | null
    psv_bank: string | null
    isverified: boolean | null
    verifiedby: string | null
    isavailable: boolean | null
    isavailable_by: string | null
    isavailable_reason: string | null
    commissions_outstanding: number | null
    commission_payment_ref: string | null
    isactive: boolean | null
    isadmin: boolean | null
    terms: boolean | null
    enable2fa: string
    code2fa: string | null
    expiry2fa: string | null
    signupotp: string | null
    wm_wait_list: number
    views: number
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    fleetid?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dob?: boolean
    subscription_plan?: boolean
    subscription_end?: boolean
    address?: boolean
    area?: boolean
    areagroup?: boolean
    residencestate?: boolean
    latitude?: boolean
    longitude?: boolean
    role?: boolean
    user_type?: boolean
    expotoken?: boolean
    photo?: boolean
    identification?: boolean
    identification_back?: boolean
    drv_license?: boolean
    drv_license_back?: boolean
    drv_vehicle_license_plate_no?: boolean
    drv_vehicle_capacity?: boolean
    drv_vehicle_make?: boolean
    drv_vehicle_meterid?: boolean
    drv_account_name?: boolean
    drv_account_no?: boolean
    drv_bank?: boolean
    psv_customer_name?: boolean
    psv_account_name?: boolean
    psv_account_number?: boolean
    psv_bank?: boolean
    isverified?: boolean
    verifiedby?: boolean
    isavailable?: boolean
    isavailable_by?: boolean
    isavailable_reason?: boolean
    commissions_outstanding?: boolean
    commission_payment_ref?: boolean
    isactive?: boolean
    isadmin?: boolean
    terms?: boolean
    enable2fa?: boolean
    code2fa?: boolean
    expiry2fa?: boolean
    signupotp?: boolean
    wm_wait_list?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    first_meter_readings?: boolean | users$first_meter_readingsArgs<ExtArgs>
    afternoon_meter_readings?: boolean | users$afternoon_meter_readingsArgs<ExtArgs>
    last_meter_readings?: boolean | users$last_meter_readingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    uuid?: boolean
    fleetid?: boolean
    name?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    dob?: boolean
    subscription_plan?: boolean
    subscription_end?: boolean
    address?: boolean
    area?: boolean
    areagroup?: boolean
    residencestate?: boolean
    latitude?: boolean
    longitude?: boolean
    role?: boolean
    user_type?: boolean
    expotoken?: boolean
    photo?: boolean
    identification?: boolean
    identification_back?: boolean
    drv_license?: boolean
    drv_license_back?: boolean
    drv_vehicle_license_plate_no?: boolean
    drv_vehicle_capacity?: boolean
    drv_vehicle_make?: boolean
    drv_vehicle_meterid?: boolean
    drv_account_name?: boolean
    drv_account_no?: boolean
    drv_bank?: boolean
    psv_customer_name?: boolean
    psv_account_name?: boolean
    psv_account_number?: boolean
    psv_bank?: boolean
    isverified?: boolean
    verifiedby?: boolean
    isavailable?: boolean
    isavailable_by?: boolean
    isavailable_reason?: boolean
    commissions_outstanding?: boolean
    commission_payment_ref?: boolean
    isactive?: boolean
    isadmin?: boolean
    terms?: boolean
    enable2fa?: boolean
    code2fa?: boolean
    expiry2fa?: boolean
    signupotp?: boolean
    wm_wait_list?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "fleetid" | "name" | "first_name" | "last_name" | "username" | "email" | "password" | "phone" | "dob" | "subscription_plan" | "subscription_end" | "address" | "area" | "areagroup" | "residencestate" | "latitude" | "longitude" | "role" | "user_type" | "expotoken" | "photo" | "identification" | "identification_back" | "drv_license" | "drv_license_back" | "drv_vehicle_license_plate_no" | "drv_vehicle_capacity" | "drv_vehicle_make" | "drv_vehicle_meterid" | "drv_account_name" | "drv_account_no" | "drv_bank" | "psv_customer_name" | "psv_account_name" | "psv_account_number" | "psv_bank" | "isverified" | "verifiedby" | "isavailable" | "isavailable_by" | "isavailable_reason" | "commissions_outstanding" | "commission_payment_ref" | "isactive" | "isadmin" | "terms" | "enable2fa" | "code2fa" | "expiry2fa" | "signupotp" | "wm_wait_list" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    first_meter_readings?: boolean | users$first_meter_readingsArgs<ExtArgs>
    afternoon_meter_readings?: boolean | users$afternoon_meter_readingsArgs<ExtArgs>
    last_meter_readings?: boolean | users$last_meter_readingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      first_meter_readings: Prisma.$MeterReadingsPayload<ExtArgs>[]
      afternoon_meter_readings: Prisma.$MeterReadingsPayload<ExtArgs>[]
      last_meter_readings: Prisma.$MeterReadingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      fleetid: number | null
      name: string
      first_name: string | null
      last_name: string | null
      username: string
      email: string
      password: string
      phone: string | null
      dob: string | null
      subscription_plan: string
      subscription_end: Date | null
      address: string | null
      area: string | null
      areagroup: string | null
      residencestate: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      role: string
      user_type: string | null
      expotoken: string | null
      photo: string | null
      identification: string | null
      identification_back: string | null
      drv_license: string | null
      drv_license_back: string | null
      drv_vehicle_license_plate_no: string | null
      drv_vehicle_capacity: string | null
      drv_vehicle_make: string | null
      drv_vehicle_meterid: string | null
      drv_account_name: string | null
      drv_account_no: string | null
      drv_bank: string | null
      psv_customer_name: string | null
      psv_account_name: string | null
      psv_account_number: string | null
      psv_bank: string | null
      isverified: boolean | null
      verifiedby: string | null
      isavailable: boolean | null
      isavailable_by: string | null
      isavailable_reason: string | null
      commissions_outstanding: number | null
      commission_payment_ref: string | null
      isactive: boolean | null
      isadmin: boolean | null
      terms: boolean | null
      enable2fa: string
      code2fa: string | null
      expiry2fa: string | null
      signupotp: string | null
      wm_wait_list: number
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    first_meter_readings<T extends users$first_meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, users$first_meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    afternoon_meter_readings<T extends users$afternoon_meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, users$afternoon_meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    last_meter_readings<T extends users$last_meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, users$last_meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly uuid: FieldRef<"users", 'String'>
    readonly fleetid: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly dob: FieldRef<"users", 'String'>
    readonly subscription_plan: FieldRef<"users", 'String'>
    readonly subscription_end: FieldRef<"users", 'DateTime'>
    readonly address: FieldRef<"users", 'String'>
    readonly area: FieldRef<"users", 'String'>
    readonly areagroup: FieldRef<"users", 'String'>
    readonly residencestate: FieldRef<"users", 'String'>
    readonly latitude: FieldRef<"users", 'Decimal'>
    readonly longitude: FieldRef<"users", 'Decimal'>
    readonly role: FieldRef<"users", 'String'>
    readonly user_type: FieldRef<"users", 'String'>
    readonly expotoken: FieldRef<"users", 'String'>
    readonly photo: FieldRef<"users", 'String'>
    readonly identification: FieldRef<"users", 'String'>
    readonly identification_back: FieldRef<"users", 'String'>
    readonly drv_license: FieldRef<"users", 'String'>
    readonly drv_license_back: FieldRef<"users", 'String'>
    readonly drv_vehicle_license_plate_no: FieldRef<"users", 'String'>
    readonly drv_vehicle_capacity: FieldRef<"users", 'String'>
    readonly drv_vehicle_make: FieldRef<"users", 'String'>
    readonly drv_vehicle_meterid: FieldRef<"users", 'String'>
    readonly drv_account_name: FieldRef<"users", 'String'>
    readonly drv_account_no: FieldRef<"users", 'String'>
    readonly drv_bank: FieldRef<"users", 'String'>
    readonly psv_customer_name: FieldRef<"users", 'String'>
    readonly psv_account_name: FieldRef<"users", 'String'>
    readonly psv_account_number: FieldRef<"users", 'String'>
    readonly psv_bank: FieldRef<"users", 'String'>
    readonly isverified: FieldRef<"users", 'Boolean'>
    readonly verifiedby: FieldRef<"users", 'String'>
    readonly isavailable: FieldRef<"users", 'Boolean'>
    readonly isavailable_by: FieldRef<"users", 'String'>
    readonly isavailable_reason: FieldRef<"users", 'String'>
    readonly commissions_outstanding: FieldRef<"users", 'Float'>
    readonly commission_payment_ref: FieldRef<"users", 'String'>
    readonly isactive: FieldRef<"users", 'Boolean'>
    readonly isadmin: FieldRef<"users", 'Boolean'>
    readonly terms: FieldRef<"users", 'Boolean'>
    readonly enable2fa: FieldRef<"users", 'String'>
    readonly code2fa: FieldRef<"users", 'String'>
    readonly expiry2fa: FieldRef<"users", 'String'>
    readonly signupotp: FieldRef<"users", 'String'>
    readonly wm_wait_list: FieldRef<"users", 'Int'>
    readonly views: FieldRef<"users", 'Int'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.first_meter_readings
   */
  export type users$first_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    where?: MeterReadingsWhereInput
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    cursor?: MeterReadingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * users.afternoon_meter_readings
   */
  export type users$afternoon_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    where?: MeterReadingsWhereInput
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    cursor?: MeterReadingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * users.last_meter_readings
   */
  export type users$last_meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    where?: MeterReadingsWhereInput
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    cursor?: MeterReadingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model videocat
   */

  export type AggregateVideocat = {
    _count: VideocatCountAggregateOutputType | null
    _avg: VideocatAvgAggregateOutputType | null
    _sum: VideocatSumAggregateOutputType | null
    _min: VideocatMinAggregateOutputType | null
    _max: VideocatMaxAggregateOutputType | null
  }

  export type VideocatAvgAggregateOutputType = {
    vidcatid: number | null
  }

  export type VideocatSumAggregateOutputType = {
    vidcatid: number | null
  }

  export type VideocatMinAggregateOutputType = {
    vidcatid: number | null
    vidcat: string | null
  }

  export type VideocatMaxAggregateOutputType = {
    vidcatid: number | null
    vidcat: string | null
  }

  export type VideocatCountAggregateOutputType = {
    vidcatid: number
    vidcat: number
    _all: number
  }


  export type VideocatAvgAggregateInputType = {
    vidcatid?: true
  }

  export type VideocatSumAggregateInputType = {
    vidcatid?: true
  }

  export type VideocatMinAggregateInputType = {
    vidcatid?: true
    vidcat?: true
  }

  export type VideocatMaxAggregateInputType = {
    vidcatid?: true
    vidcat?: true
  }

  export type VideocatCountAggregateInputType = {
    vidcatid?: true
    vidcat?: true
    _all?: true
  }

  export type VideocatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videocat to aggregate.
     */
    where?: videocatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videocats to fetch.
     */
    orderBy?: videocatOrderByWithRelationInput | videocatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videocatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videocats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videocats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videocats
    **/
    _count?: true | VideocatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideocatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideocatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideocatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideocatMaxAggregateInputType
  }

  export type GetVideocatAggregateType<T extends VideocatAggregateArgs> = {
        [P in keyof T & keyof AggregateVideocat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideocat[P]>
      : GetScalarType<T[P], AggregateVideocat[P]>
  }




  export type videocatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videocatWhereInput
    orderBy?: videocatOrderByWithAggregationInput | videocatOrderByWithAggregationInput[]
    by: VideocatScalarFieldEnum[] | VideocatScalarFieldEnum
    having?: videocatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideocatCountAggregateInputType | true
    _avg?: VideocatAvgAggregateInputType
    _sum?: VideocatSumAggregateInputType
    _min?: VideocatMinAggregateInputType
    _max?: VideocatMaxAggregateInputType
  }

  export type VideocatGroupByOutputType = {
    vidcatid: number
    vidcat: string
    _count: VideocatCountAggregateOutputType | null
    _avg: VideocatAvgAggregateOutputType | null
    _sum: VideocatSumAggregateOutputType | null
    _min: VideocatMinAggregateOutputType | null
    _max: VideocatMaxAggregateOutputType | null
  }

  type GetVideocatGroupByPayload<T extends videocatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideocatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideocatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideocatGroupByOutputType[P]>
            : GetScalarType<T[P], VideocatGroupByOutputType[P]>
        }
      >
    >


  export type videocatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vidcatid?: boolean
    vidcat?: boolean
  }, ExtArgs["result"]["videocat"]>



  export type videocatSelectScalar = {
    vidcatid?: boolean
    vidcat?: boolean
  }

  export type videocatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vidcatid" | "vidcat", ExtArgs["result"]["videocat"]>

  export type $videocatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videocat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      vidcatid: number
      vidcat: string
    }, ExtArgs["result"]["videocat"]>
    composites: {}
  }

  type videocatGetPayload<S extends boolean | null | undefined | videocatDefaultArgs> = $Result.GetResult<Prisma.$videocatPayload, S>

  type videocatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videocatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideocatCountAggregateInputType | true
    }

  export interface videocatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videocat'], meta: { name: 'videocat' } }
    /**
     * Find zero or one Videocat that matches the filter.
     * @param {videocatFindUniqueArgs} args - Arguments to find a Videocat
     * @example
     * // Get one Videocat
     * const videocat = await prisma.videocat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videocatFindUniqueArgs>(args: SelectSubset<T, videocatFindUniqueArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videocat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videocatFindUniqueOrThrowArgs} args - Arguments to find a Videocat
     * @example
     * // Get one Videocat
     * const videocat = await prisma.videocat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videocatFindUniqueOrThrowArgs>(args: SelectSubset<T, videocatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videocat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatFindFirstArgs} args - Arguments to find a Videocat
     * @example
     * // Get one Videocat
     * const videocat = await prisma.videocat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videocatFindFirstArgs>(args?: SelectSubset<T, videocatFindFirstArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videocat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatFindFirstOrThrowArgs} args - Arguments to find a Videocat
     * @example
     * // Get one Videocat
     * const videocat = await prisma.videocat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videocatFindFirstOrThrowArgs>(args?: SelectSubset<T, videocatFindFirstOrThrowArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videocats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videocats
     * const videocats = await prisma.videocat.findMany()
     * 
     * // Get first 10 Videocats
     * const videocats = await prisma.videocat.findMany({ take: 10 })
     * 
     * // Only select the `vidcatid`
     * const videocatWithVidcatidOnly = await prisma.videocat.findMany({ select: { vidcatid: true } })
     * 
     */
    findMany<T extends videocatFindManyArgs>(args?: SelectSubset<T, videocatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videocat.
     * @param {videocatCreateArgs} args - Arguments to create a Videocat.
     * @example
     * // Create one Videocat
     * const Videocat = await prisma.videocat.create({
     *   data: {
     *     // ... data to create a Videocat
     *   }
     * })
     * 
     */
    create<T extends videocatCreateArgs>(args: SelectSubset<T, videocatCreateArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videocats.
     * @param {videocatCreateManyArgs} args - Arguments to create many Videocats.
     * @example
     * // Create many Videocats
     * const videocat = await prisma.videocat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videocatCreateManyArgs>(args?: SelectSubset<T, videocatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videocat.
     * @param {videocatDeleteArgs} args - Arguments to delete one Videocat.
     * @example
     * // Delete one Videocat
     * const Videocat = await prisma.videocat.delete({
     *   where: {
     *     // ... filter to delete one Videocat
     *   }
     * })
     * 
     */
    delete<T extends videocatDeleteArgs>(args: SelectSubset<T, videocatDeleteArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videocat.
     * @param {videocatUpdateArgs} args - Arguments to update one Videocat.
     * @example
     * // Update one Videocat
     * const videocat = await prisma.videocat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videocatUpdateArgs>(args: SelectSubset<T, videocatUpdateArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videocats.
     * @param {videocatDeleteManyArgs} args - Arguments to filter Videocats to delete.
     * @example
     * // Delete a few Videocats
     * const { count } = await prisma.videocat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videocatDeleteManyArgs>(args?: SelectSubset<T, videocatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videocats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videocats
     * const videocat = await prisma.videocat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videocatUpdateManyArgs>(args: SelectSubset<T, videocatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videocat.
     * @param {videocatUpsertArgs} args - Arguments to update or create a Videocat.
     * @example
     * // Update or create a Videocat
     * const videocat = await prisma.videocat.upsert({
     *   create: {
     *     // ... data to create a Videocat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videocat we want to update
     *   }
     * })
     */
    upsert<T extends videocatUpsertArgs>(args: SelectSubset<T, videocatUpsertArgs<ExtArgs>>): Prisma__videocatClient<$Result.GetResult<Prisma.$videocatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videocats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatCountArgs} args - Arguments to filter Videocats to count.
     * @example
     * // Count the number of Videocats
     * const count = await prisma.videocat.count({
     *   where: {
     *     // ... the filter for the Videocats we want to count
     *   }
     * })
    **/
    count<T extends videocatCountArgs>(
      args?: Subset<T, videocatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideocatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videocat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideocatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideocatAggregateArgs>(args: Subset<T, VideocatAggregateArgs>): Prisma.PrismaPromise<GetVideocatAggregateType<T>>

    /**
     * Group by Videocat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videocatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videocatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videocatGroupByArgs['orderBy'] }
        : { orderBy?: videocatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videocatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideocatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videocat model
   */
  readonly fields: videocatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videocat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videocatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videocat model
   */
  interface videocatFieldRefs {
    readonly vidcatid: FieldRef<"videocat", 'Int'>
    readonly vidcat: FieldRef<"videocat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * videocat findUnique
   */
  export type videocatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter, which videocat to fetch.
     */
    where: videocatWhereUniqueInput
  }

  /**
   * videocat findUniqueOrThrow
   */
  export type videocatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter, which videocat to fetch.
     */
    where: videocatWhereUniqueInput
  }

  /**
   * videocat findFirst
   */
  export type videocatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter, which videocat to fetch.
     */
    where?: videocatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videocats to fetch.
     */
    orderBy?: videocatOrderByWithRelationInput | videocatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videocats.
     */
    cursor?: videocatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videocats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videocats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videocats.
     */
    distinct?: VideocatScalarFieldEnum | VideocatScalarFieldEnum[]
  }

  /**
   * videocat findFirstOrThrow
   */
  export type videocatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter, which videocat to fetch.
     */
    where?: videocatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videocats to fetch.
     */
    orderBy?: videocatOrderByWithRelationInput | videocatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videocats.
     */
    cursor?: videocatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videocats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videocats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videocats.
     */
    distinct?: VideocatScalarFieldEnum | VideocatScalarFieldEnum[]
  }

  /**
   * videocat findMany
   */
  export type videocatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter, which videocats to fetch.
     */
    where?: videocatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videocats to fetch.
     */
    orderBy?: videocatOrderByWithRelationInput | videocatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videocats.
     */
    cursor?: videocatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videocats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videocats.
     */
    skip?: number
    distinct?: VideocatScalarFieldEnum | VideocatScalarFieldEnum[]
  }

  /**
   * videocat create
   */
  export type videocatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * The data needed to create a videocat.
     */
    data: XOR<videocatCreateInput, videocatUncheckedCreateInput>
  }

  /**
   * videocat createMany
   */
  export type videocatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videocats.
     */
    data: videocatCreateManyInput | videocatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videocat update
   */
  export type videocatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * The data needed to update a videocat.
     */
    data: XOR<videocatUpdateInput, videocatUncheckedUpdateInput>
    /**
     * Choose, which videocat to update.
     */
    where: videocatWhereUniqueInput
  }

  /**
   * videocat updateMany
   */
  export type videocatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videocats.
     */
    data: XOR<videocatUpdateManyMutationInput, videocatUncheckedUpdateManyInput>
    /**
     * Filter which videocats to update
     */
    where?: videocatWhereInput
    /**
     * Limit how many videocats to update.
     */
    limit?: number
  }

  /**
   * videocat upsert
   */
  export type videocatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * The filter to search for the videocat to update in case it exists.
     */
    where: videocatWhereUniqueInput
    /**
     * In case the videocat found by the `where` argument doesn't exist, create a new videocat with this data.
     */
    create: XOR<videocatCreateInput, videocatUncheckedCreateInput>
    /**
     * In case the videocat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videocatUpdateInput, videocatUncheckedUpdateInput>
  }

  /**
   * videocat delete
   */
  export type videocatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
    /**
     * Filter which videocat to delete.
     */
    where: videocatWhereUniqueInput
  }

  /**
   * videocat deleteMany
   */
  export type videocatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videocats to delete
     */
    where?: videocatWhereInput
    /**
     * Limit how many videocats to delete.
     */
    limit?: number
  }

  /**
   * videocat without action
   */
  export type videocatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videocat
     */
    select?: videocatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videocat
     */
    omit?: videocatOmit<ExtArgs> | null
  }


  /**
   * Model videos
   */

  export type AggregateVideos = {
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  export type VideosAvgAggregateOutputType = {
    videntryid: number | null
    vcatid: number | null
    vidhits: number | null
  }

  export type VideosSumAggregateOutputType = {
    videntryid: number | null
    vcatid: number | null
    vidhits: number | null
  }

  export type VideosMinAggregateOutputType = {
    videntryid: number | null
    vcatid: number | null
    vidcategory: string | null
    vidtitle: string | null
    viddesc: string | null
    vidurl: string | null
    vidembed: string | null
    vidpostedby: string | null
    vidtimeposted: Date | null
    vidhits: number | null
    vidextra: string | null
  }

  export type VideosMaxAggregateOutputType = {
    videntryid: number | null
    vcatid: number | null
    vidcategory: string | null
    vidtitle: string | null
    viddesc: string | null
    vidurl: string | null
    vidembed: string | null
    vidpostedby: string | null
    vidtimeposted: Date | null
    vidhits: number | null
    vidextra: string | null
  }

  export type VideosCountAggregateOutputType = {
    videntryid: number
    vcatid: number
    vidcategory: number
    vidtitle: number
    viddesc: number
    vidurl: number
    vidembed: number
    vidpostedby: number
    vidtimeposted: number
    vidhits: number
    vidextra: number
    _all: number
  }


  export type VideosAvgAggregateInputType = {
    videntryid?: true
    vcatid?: true
    vidhits?: true
  }

  export type VideosSumAggregateInputType = {
    videntryid?: true
    vcatid?: true
    vidhits?: true
  }

  export type VideosMinAggregateInputType = {
    videntryid?: true
    vcatid?: true
    vidcategory?: true
    vidtitle?: true
    viddesc?: true
    vidurl?: true
    vidembed?: true
    vidpostedby?: true
    vidtimeposted?: true
    vidhits?: true
    vidextra?: true
  }

  export type VideosMaxAggregateInputType = {
    videntryid?: true
    vcatid?: true
    vidcategory?: true
    vidtitle?: true
    viddesc?: true
    vidurl?: true
    vidembed?: true
    vidpostedby?: true
    vidtimeposted?: true
    vidhits?: true
    vidextra?: true
  }

  export type VideosCountAggregateInputType = {
    videntryid?: true
    vcatid?: true
    vidcategory?: true
    vidtitle?: true
    viddesc?: true
    vidurl?: true
    vidembed?: true
    vidpostedby?: true
    vidtimeposted?: true
    vidhits?: true
    vidextra?: true
    _all?: true
  }

  export type VideosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to aggregate.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videos
    **/
    _count?: true | VideosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideosMaxAggregateInputType
  }

  export type GetVideosAggregateType<T extends VideosAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos[P]>
      : GetScalarType<T[P], AggregateVideos[P]>
  }




  export type videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videosWhereInput
    orderBy?: videosOrderByWithAggregationInput | videosOrderByWithAggregationInput[]
    by: VideosScalarFieldEnum[] | VideosScalarFieldEnum
    having?: videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideosCountAggregateInputType | true
    _avg?: VideosAvgAggregateInputType
    _sum?: VideosSumAggregateInputType
    _min?: VideosMinAggregateInputType
    _max?: VideosMaxAggregateInputType
  }

  export type VideosGroupByOutputType = {
    videntryid: number
    vcatid: number
    vidcategory: string
    vidtitle: string
    viddesc: string
    vidurl: string
    vidembed: string
    vidpostedby: string
    vidtimeposted: Date
    vidhits: number
    vidextra: string
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  type GetVideosGroupByPayload<T extends videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideosGroupByOutputType[P]>
            : GetScalarType<T[P], VideosGroupByOutputType[P]>
        }
      >
    >


  export type videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videntryid?: boolean
    vcatid?: boolean
    vidcategory?: boolean
    vidtitle?: boolean
    viddesc?: boolean
    vidurl?: boolean
    vidembed?: boolean
    vidpostedby?: boolean
    vidtimeposted?: boolean
    vidhits?: boolean
    vidextra?: boolean
  }, ExtArgs["result"]["videos"]>



  export type videosSelectScalar = {
    videntryid?: boolean
    vcatid?: boolean
    vidcategory?: boolean
    vidtitle?: boolean
    viddesc?: boolean
    vidurl?: boolean
    vidembed?: boolean
    vidpostedby?: boolean
    vidtimeposted?: boolean
    vidhits?: boolean
    vidextra?: boolean
  }

  export type videosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"videntryid" | "vcatid" | "vidcategory" | "vidtitle" | "viddesc" | "vidurl" | "vidembed" | "vidpostedby" | "vidtimeposted" | "vidhits" | "vidextra", ExtArgs["result"]["videos"]>

  export type $videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      videntryid: number
      vcatid: number
      vidcategory: string
      vidtitle: string
      viddesc: string
      vidurl: string
      vidembed: string
      vidpostedby: string
      vidtimeposted: Date
      vidhits: number
      vidextra: string
    }, ExtArgs["result"]["videos"]>
    composites: {}
  }

  type videosGetPayload<S extends boolean | null | undefined | videosDefaultArgs> = $Result.GetResult<Prisma.$videosPayload, S>

  type videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<videosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideosCountAggregateInputType | true
    }

  export interface videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videos'], meta: { name: 'videos' } }
    /**
     * Find zero or one Videos that matches the filter.
     * @param {videosFindUniqueArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends videosFindUniqueArgs>(args: SelectSubset<T, videosFindUniqueArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {videosFindUniqueOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends videosFindUniqueOrThrowArgs>(args: SelectSubset<T, videosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends videosFindFirstArgs>(args?: SelectSubset<T, videosFindFirstArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindFirstOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends videosFindFirstOrThrowArgs>(args?: SelectSubset<T, videosFindFirstOrThrowArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.videos.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.videos.findMany({ take: 10 })
     * 
     * // Only select the `videntryid`
     * const videosWithVidentryidOnly = await prisma.videos.findMany({ select: { videntryid: true } })
     * 
     */
    findMany<T extends videosFindManyArgs>(args?: SelectSubset<T, videosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos.
     * @param {videosCreateArgs} args - Arguments to create a Videos.
     * @example
     * // Create one Videos
     * const Videos = await prisma.videos.create({
     *   data: {
     *     // ... data to create a Videos
     *   }
     * })
     * 
     */
    create<T extends videosCreateArgs>(args: SelectSubset<T, videosCreateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {videosCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const videos = await prisma.videos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends videosCreateManyArgs>(args?: SelectSubset<T, videosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Videos.
     * @param {videosDeleteArgs} args - Arguments to delete one Videos.
     * @example
     * // Delete one Videos
     * const Videos = await prisma.videos.delete({
     *   where: {
     *     // ... filter to delete one Videos
     *   }
     * })
     * 
     */
    delete<T extends videosDeleteArgs>(args: SelectSubset<T, videosDeleteArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos.
     * @param {videosUpdateArgs} args - Arguments to update one Videos.
     * @example
     * // Update one Videos
     * const videos = await prisma.videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends videosUpdateArgs>(args: SelectSubset<T, videosUpdateArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {videosDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends videosDeleteManyArgs>(args?: SelectSubset<T, videosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends videosUpdateManyArgs>(args: SelectSubset<T, videosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videos.
     * @param {videosUpsertArgs} args - Arguments to update or create a Videos.
     * @example
     * // Update or create a Videos
     * const videos = await prisma.videos.upsert({
     *   create: {
     *     // ... data to create a Videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos we want to update
     *   }
     * })
     */
    upsert<T extends videosUpsertArgs>(args: SelectSubset<T, videosUpsertArgs<ExtArgs>>): Prisma__videosClient<$Result.GetResult<Prisma.$videosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.videos.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends videosCountArgs>(
      args?: Subset<T, videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideosAggregateArgs>(args: Subset<T, VideosAggregateArgs>): Prisma.PrismaPromise<GetVideosAggregateType<T>>

    /**
     * Group by Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videosGroupByArgs['orderBy'] }
        : { orderBy?: videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videos model
   */
  readonly fields: videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the videos model
   */
  interface videosFieldRefs {
    readonly videntryid: FieldRef<"videos", 'Int'>
    readonly vcatid: FieldRef<"videos", 'Int'>
    readonly vidcategory: FieldRef<"videos", 'String'>
    readonly vidtitle: FieldRef<"videos", 'String'>
    readonly viddesc: FieldRef<"videos", 'String'>
    readonly vidurl: FieldRef<"videos", 'String'>
    readonly vidembed: FieldRef<"videos", 'String'>
    readonly vidpostedby: FieldRef<"videos", 'String'>
    readonly vidtimeposted: FieldRef<"videos", 'DateTime'>
    readonly vidhits: FieldRef<"videos", 'Int'>
    readonly vidextra: FieldRef<"videos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * videos findUnique
   */
  export type videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findUniqueOrThrow
   */
  export type videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos findFirst
   */
  export type videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findFirstOrThrow
   */
  export type videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos findMany
   */
  export type videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter, which videos to fetch.
     */
    where?: videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videos to fetch.
     */
    orderBy?: videosOrderByWithRelationInput | videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videos.
     */
    cursor?: videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videos.
     */
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * videos create
   */
  export type videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * The data needed to create a videos.
     */
    data: XOR<videosCreateInput, videosUncheckedCreateInput>
  }

  /**
   * videos createMany
   */
  export type videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videos.
     */
    data: videosCreateManyInput | videosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videos update
   */
  export type videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * The data needed to update a videos.
     */
    data: XOR<videosUpdateInput, videosUncheckedUpdateInput>
    /**
     * Choose, which videos to update.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos updateMany
   */
  export type videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videos.
     */
    data: XOR<videosUpdateManyMutationInput, videosUncheckedUpdateManyInput>
    /**
     * Filter which videos to update
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to update.
     */
    limit?: number
  }

  /**
   * videos upsert
   */
  export type videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * The filter to search for the videos to update in case it exists.
     */
    where: videosWhereUniqueInput
    /**
     * In case the videos found by the `where` argument doesn't exist, create a new videos with this data.
     */
    create: XOR<videosCreateInput, videosUncheckedCreateInput>
    /**
     * In case the videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videosUpdateInput, videosUncheckedUpdateInput>
  }

  /**
   * videos delete
   */
  export type videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
    /**
     * Filter which videos to delete.
     */
    where: videosWhereUniqueInput
  }

  /**
   * videos deleteMany
   */
  export type videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videos to delete
     */
    where?: videosWhereInput
    /**
     * Limit how many videos to delete.
     */
    limit?: number
  }

  /**
   * videos without action
   */
  export type videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videos
     */
    select?: videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the videos
     */
    omit?: videosOmit<ExtArgs> | null
  }


  /**
   * Model meter_domestic_entries
   */

  export type AggregateMeter_domestic_entries = {
    _count: Meter_domestic_entriesCountAggregateOutputType | null
    _avg: Meter_domestic_entriesAvgAggregateOutputType | null
    _sum: Meter_domestic_entriesSumAggregateOutputType | null
    _min: Meter_domestic_entriesMinAggregateOutputType | null
    _max: Meter_domestic_entriesMaxAggregateOutputType | null
  }

  export type Meter_domestic_entriesAvgAggregateOutputType = {
    mdid: number | null
    md_volume_received: number | null
  }

  export type Meter_domestic_entriesSumAggregateOutputType = {
    mdid: number | null
    md_volume_received: number | null
  }

  export type Meter_domestic_entriesMinAggregateOutputType = {
    mdid: number | null
    md_unique_id: string | null
    md_userid: string | null
    md_area: string | null
    md_consumption_rate: string | null
    md_volume_received: number | null
    md_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_domestic_entriesMaxAggregateOutputType = {
    mdid: number | null
    md_unique_id: string | null
    md_userid: string | null
    md_area: string | null
    md_consumption_rate: string | null
    md_volume_received: number | null
    md_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_domestic_entriesCountAggregateOutputType = {
    mdid: number
    md_unique_id: number
    md_userid: number
    md_area: number
    md_consumption_rate: number
    md_volume_received: number
    md_valve_state: number
    createdAt: number
    _all: number
  }


  export type Meter_domestic_entriesAvgAggregateInputType = {
    mdid?: true
    md_volume_received?: true
  }

  export type Meter_domestic_entriesSumAggregateInputType = {
    mdid?: true
    md_volume_received?: true
  }

  export type Meter_domestic_entriesMinAggregateInputType = {
    mdid?: true
    md_unique_id?: true
    md_userid?: true
    md_area?: true
    md_consumption_rate?: true
    md_volume_received?: true
    md_valve_state?: true
    createdAt?: true
  }

  export type Meter_domestic_entriesMaxAggregateInputType = {
    mdid?: true
    md_unique_id?: true
    md_userid?: true
    md_area?: true
    md_consumption_rate?: true
    md_volume_received?: true
    md_valve_state?: true
    createdAt?: true
  }

  export type Meter_domestic_entriesCountAggregateInputType = {
    mdid?: true
    md_unique_id?: true
    md_userid?: true
    md_area?: true
    md_consumption_rate?: true
    md_volume_received?: true
    md_valve_state?: true
    createdAt?: true
    _all?: true
  }

  export type Meter_domestic_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_domestic_entries to aggregate.
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_domestic_entries to fetch.
     */
    orderBy?: meter_domestic_entriesOrderByWithRelationInput | meter_domestic_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_domestic_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_domestic_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_domestic_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_domestic_entries
    **/
    _count?: true | Meter_domestic_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_domestic_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_domestic_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_domestic_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_domestic_entriesMaxAggregateInputType
  }

  export type GetMeter_domestic_entriesAggregateType<T extends Meter_domestic_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_domestic_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_domestic_entries[P]>
      : GetScalarType<T[P], AggregateMeter_domestic_entries[P]>
  }




  export type meter_domestic_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_domestic_entriesWhereInput
    orderBy?: meter_domestic_entriesOrderByWithAggregationInput | meter_domestic_entriesOrderByWithAggregationInput[]
    by: Meter_domestic_entriesScalarFieldEnum[] | Meter_domestic_entriesScalarFieldEnum
    having?: meter_domestic_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_domestic_entriesCountAggregateInputType | true
    _avg?: Meter_domestic_entriesAvgAggregateInputType
    _sum?: Meter_domestic_entriesSumAggregateInputType
    _min?: Meter_domestic_entriesMinAggregateInputType
    _max?: Meter_domestic_entriesMaxAggregateInputType
  }

  export type Meter_domestic_entriesGroupByOutputType = {
    mdid: number
    md_unique_id: string
    md_userid: string | null
    md_area: string | null
    md_consumption_rate: string
    md_volume_received: number
    md_valve_state: string
    createdAt: Date
    _count: Meter_domestic_entriesCountAggregateOutputType | null
    _avg: Meter_domestic_entriesAvgAggregateOutputType | null
    _sum: Meter_domestic_entriesSumAggregateOutputType | null
    _min: Meter_domestic_entriesMinAggregateOutputType | null
    _max: Meter_domestic_entriesMaxAggregateOutputType | null
  }

  type GetMeter_domestic_entriesGroupByPayload<T extends meter_domestic_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_domestic_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_domestic_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_domestic_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_domestic_entriesGroupByOutputType[P]>
        }
      >
    >


  export type meter_domestic_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mdid?: boolean
    md_unique_id?: boolean
    md_userid?: boolean
    md_area?: boolean
    md_consumption_rate?: boolean
    md_volume_received?: boolean
    md_valve_state?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meter_domestic_entries"]>



  export type meter_domestic_entriesSelectScalar = {
    mdid?: boolean
    md_unique_id?: boolean
    md_userid?: boolean
    md_area?: boolean
    md_consumption_rate?: boolean
    md_volume_received?: boolean
    md_valve_state?: boolean
    createdAt?: boolean
  }

  export type meter_domestic_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mdid" | "md_unique_id" | "md_userid" | "md_area" | "md_consumption_rate" | "md_volume_received" | "md_valve_state" | "createdAt", ExtArgs["result"]["meter_domestic_entries"]>

  export type $meter_domestic_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_domestic_entries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      mdid: number
      md_unique_id: string
      md_userid: string | null
      md_area: string | null
      md_consumption_rate: string
      md_volume_received: number
      md_valve_state: string
      createdAt: Date
    }, ExtArgs["result"]["meter_domestic_entries"]>
    composites: {}
  }

  type meter_domestic_entriesGetPayload<S extends boolean | null | undefined | meter_domestic_entriesDefaultArgs> = $Result.GetResult<Prisma.$meter_domestic_entriesPayload, S>

  type meter_domestic_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meter_domestic_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Meter_domestic_entriesCountAggregateInputType | true
    }

  export interface meter_domestic_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_domestic_entries'], meta: { name: 'meter_domestic_entries' } }
    /**
     * Find zero or one Meter_domestic_entries that matches the filter.
     * @param {meter_domestic_entriesFindUniqueArgs} args - Arguments to find a Meter_domestic_entries
     * @example
     * // Get one Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_domestic_entriesFindUniqueArgs>(args: SelectSubset<T, meter_domestic_entriesFindUniqueArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meter_domestic_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meter_domestic_entriesFindUniqueOrThrowArgs} args - Arguments to find a Meter_domestic_entries
     * @example
     * // Get one Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_domestic_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_domestic_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_domestic_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesFindFirstArgs} args - Arguments to find a Meter_domestic_entries
     * @example
     * // Get one Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_domestic_entriesFindFirstArgs>(args?: SelectSubset<T, meter_domestic_entriesFindFirstArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_domestic_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesFindFirstOrThrowArgs} args - Arguments to find a Meter_domestic_entries
     * @example
     * // Get one Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_domestic_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_domestic_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meter_domestic_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findMany()
     * 
     * // Get first 10 Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.findMany({ take: 10 })
     * 
     * // Only select the `mdid`
     * const meter_domestic_entriesWithMdidOnly = await prisma.meter_domestic_entries.findMany({ select: { mdid: true } })
     * 
     */
    findMany<T extends meter_domestic_entriesFindManyArgs>(args?: SelectSubset<T, meter_domestic_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meter_domestic_entries.
     * @param {meter_domestic_entriesCreateArgs} args - Arguments to create a Meter_domestic_entries.
     * @example
     * // Create one Meter_domestic_entries
     * const Meter_domestic_entries = await prisma.meter_domestic_entries.create({
     *   data: {
     *     // ... data to create a Meter_domestic_entries
     *   }
     * })
     * 
     */
    create<T extends meter_domestic_entriesCreateArgs>(args: SelectSubset<T, meter_domestic_entriesCreateArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meter_domestic_entries.
     * @param {meter_domestic_entriesCreateManyArgs} args - Arguments to create many Meter_domestic_entries.
     * @example
     * // Create many Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_domestic_entriesCreateManyArgs>(args?: SelectSubset<T, meter_domestic_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meter_domestic_entries.
     * @param {meter_domestic_entriesDeleteArgs} args - Arguments to delete one Meter_domestic_entries.
     * @example
     * // Delete one Meter_domestic_entries
     * const Meter_domestic_entries = await prisma.meter_domestic_entries.delete({
     *   where: {
     *     // ... filter to delete one Meter_domestic_entries
     *   }
     * })
     * 
     */
    delete<T extends meter_domestic_entriesDeleteArgs>(args: SelectSubset<T, meter_domestic_entriesDeleteArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meter_domestic_entries.
     * @param {meter_domestic_entriesUpdateArgs} args - Arguments to update one Meter_domestic_entries.
     * @example
     * // Update one Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_domestic_entriesUpdateArgs>(args: SelectSubset<T, meter_domestic_entriesUpdateArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meter_domestic_entries.
     * @param {meter_domestic_entriesDeleteManyArgs} args - Arguments to filter Meter_domestic_entries to delete.
     * @example
     * // Delete a few Meter_domestic_entries
     * const { count } = await prisma.meter_domestic_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_domestic_entriesDeleteManyArgs>(args?: SelectSubset<T, meter_domestic_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_domestic_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_domestic_entriesUpdateManyArgs>(args: SelectSubset<T, meter_domestic_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_domestic_entries.
     * @param {meter_domestic_entriesUpsertArgs} args - Arguments to update or create a Meter_domestic_entries.
     * @example
     * // Update or create a Meter_domestic_entries
     * const meter_domestic_entries = await prisma.meter_domestic_entries.upsert({
     *   create: {
     *     // ... data to create a Meter_domestic_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_domestic_entries we want to update
     *   }
     * })
     */
    upsert<T extends meter_domestic_entriesUpsertArgs>(args: SelectSubset<T, meter_domestic_entriesUpsertArgs<ExtArgs>>): Prisma__meter_domestic_entriesClient<$Result.GetResult<Prisma.$meter_domestic_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meter_domestic_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesCountArgs} args - Arguments to filter Meter_domestic_entries to count.
     * @example
     * // Count the number of Meter_domestic_entries
     * const count = await prisma.meter_domestic_entries.count({
     *   where: {
     *     // ... the filter for the Meter_domestic_entries we want to count
     *   }
     * })
    **/
    count<T extends meter_domestic_entriesCountArgs>(
      args?: Subset<T, meter_domestic_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_domestic_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_domestic_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_domestic_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_domestic_entriesAggregateArgs>(args: Subset<T, Meter_domestic_entriesAggregateArgs>): Prisma.PrismaPromise<GetMeter_domestic_entriesAggregateType<T>>

    /**
     * Group by Meter_domestic_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_domestic_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_domestic_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_domestic_entriesGroupByArgs['orderBy'] }
        : { orderBy?: meter_domestic_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_domestic_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_domestic_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_domestic_entries model
   */
  readonly fields: meter_domestic_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_domestic_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_domestic_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_domestic_entries model
   */
  interface meter_domestic_entriesFieldRefs {
    readonly mdid: FieldRef<"meter_domestic_entries", 'Int'>
    readonly md_unique_id: FieldRef<"meter_domestic_entries", 'String'>
    readonly md_userid: FieldRef<"meter_domestic_entries", 'String'>
    readonly md_area: FieldRef<"meter_domestic_entries", 'String'>
    readonly md_consumption_rate: FieldRef<"meter_domestic_entries", 'String'>
    readonly md_volume_received: FieldRef<"meter_domestic_entries", 'Int'>
    readonly md_valve_state: FieldRef<"meter_domestic_entries", 'String'>
    readonly createdAt: FieldRef<"meter_domestic_entries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meter_domestic_entries findUnique
   */
  export type meter_domestic_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_domestic_entries to fetch.
     */
    where: meter_domestic_entriesWhereUniqueInput
  }

  /**
   * meter_domestic_entries findUniqueOrThrow
   */
  export type meter_domestic_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_domestic_entries to fetch.
     */
    where: meter_domestic_entriesWhereUniqueInput
  }

  /**
   * meter_domestic_entries findFirst
   */
  export type meter_domestic_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_domestic_entries to fetch.
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_domestic_entries to fetch.
     */
    orderBy?: meter_domestic_entriesOrderByWithRelationInput | meter_domestic_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_domestic_entries.
     */
    cursor?: meter_domestic_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_domestic_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_domestic_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_domestic_entries.
     */
    distinct?: Meter_domestic_entriesScalarFieldEnum | Meter_domestic_entriesScalarFieldEnum[]
  }

  /**
   * meter_domestic_entries findFirstOrThrow
   */
  export type meter_domestic_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_domestic_entries to fetch.
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_domestic_entries to fetch.
     */
    orderBy?: meter_domestic_entriesOrderByWithRelationInput | meter_domestic_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_domestic_entries.
     */
    cursor?: meter_domestic_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_domestic_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_domestic_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_domestic_entries.
     */
    distinct?: Meter_domestic_entriesScalarFieldEnum | Meter_domestic_entriesScalarFieldEnum[]
  }

  /**
   * meter_domestic_entries findMany
   */
  export type meter_domestic_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_domestic_entries to fetch.
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_domestic_entries to fetch.
     */
    orderBy?: meter_domestic_entriesOrderByWithRelationInput | meter_domestic_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_domestic_entries.
     */
    cursor?: meter_domestic_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_domestic_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_domestic_entries.
     */
    skip?: number
    distinct?: Meter_domestic_entriesScalarFieldEnum | Meter_domestic_entriesScalarFieldEnum[]
  }

  /**
   * meter_domestic_entries create
   */
  export type meter_domestic_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a meter_domestic_entries.
     */
    data: XOR<meter_domestic_entriesCreateInput, meter_domestic_entriesUncheckedCreateInput>
  }

  /**
   * meter_domestic_entries createMany
   */
  export type meter_domestic_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_domestic_entries.
     */
    data: meter_domestic_entriesCreateManyInput | meter_domestic_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_domestic_entries update
   */
  export type meter_domestic_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a meter_domestic_entries.
     */
    data: XOR<meter_domestic_entriesUpdateInput, meter_domestic_entriesUncheckedUpdateInput>
    /**
     * Choose, which meter_domestic_entries to update.
     */
    where: meter_domestic_entriesWhereUniqueInput
  }

  /**
   * meter_domestic_entries updateMany
   */
  export type meter_domestic_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_domestic_entries.
     */
    data: XOR<meter_domestic_entriesUpdateManyMutationInput, meter_domestic_entriesUncheckedUpdateManyInput>
    /**
     * Filter which meter_domestic_entries to update
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * Limit how many meter_domestic_entries to update.
     */
    limit?: number
  }

  /**
   * meter_domestic_entries upsert
   */
  export type meter_domestic_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the meter_domestic_entries to update in case it exists.
     */
    where: meter_domestic_entriesWhereUniqueInput
    /**
     * In case the meter_domestic_entries found by the `where` argument doesn't exist, create a new meter_domestic_entries with this data.
     */
    create: XOR<meter_domestic_entriesCreateInput, meter_domestic_entriesUncheckedCreateInput>
    /**
     * In case the meter_domestic_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_domestic_entriesUpdateInput, meter_domestic_entriesUncheckedUpdateInput>
  }

  /**
   * meter_domestic_entries delete
   */
  export type meter_domestic_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
    /**
     * Filter which meter_domestic_entries to delete.
     */
    where: meter_domestic_entriesWhereUniqueInput
  }

  /**
   * meter_domestic_entries deleteMany
   */
  export type meter_domestic_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_domestic_entries to delete
     */
    where?: meter_domestic_entriesWhereInput
    /**
     * Limit how many meter_domestic_entries to delete.
     */
    limit?: number
  }

  /**
   * meter_domestic_entries without action
   */
  export type meter_domestic_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_domestic_entries
     */
    select?: meter_domestic_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_domestic_entries
     */
    omit?: meter_domestic_entriesOmit<ExtArgs> | null
  }


  /**
   * Model meter_supply_entries
   */

  export type AggregateMeter_supply_entries = {
    _count: Meter_supply_entriesCountAggregateOutputType | null
    _avg: Meter_supply_entriesAvgAggregateOutputType | null
    _sum: Meter_supply_entriesSumAggregateOutputType | null
    _min: Meter_supply_entriesMinAggregateOutputType | null
    _max: Meter_supply_entriesMaxAggregateOutputType | null
  }

  export type Meter_supply_entriesAvgAggregateOutputType = {
    msid: number | null
    ms_volume_supplied: number | null
  }

  export type Meter_supply_entriesSumAggregateOutputType = {
    msid: number | null
    ms_volume_supplied: number | null
  }

  export type Meter_supply_entriesMinAggregateOutputType = {
    msid: number | null
    ms_unique_id: string | null
    ms_userid: string | null
    ms_supply_rate: string | null
    ms_volume_supplied: number | null
    ms_temperature_c: string | null
    ms_temperature_f: string | null
    ms_turbidity_level: string | null
    ms_ph_level: string | null
    ms_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_supply_entriesMaxAggregateOutputType = {
    msid: number | null
    ms_unique_id: string | null
    ms_userid: string | null
    ms_supply_rate: string | null
    ms_volume_supplied: number | null
    ms_temperature_c: string | null
    ms_temperature_f: string | null
    ms_turbidity_level: string | null
    ms_ph_level: string | null
    ms_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_supply_entriesCountAggregateOutputType = {
    msid: number
    ms_unique_id: number
    ms_userid: number
    ms_supply_rate: number
    ms_volume_supplied: number
    ms_temperature_c: number
    ms_temperature_f: number
    ms_turbidity_level: number
    ms_ph_level: number
    ms_valve_state: number
    createdAt: number
    _all: number
  }


  export type Meter_supply_entriesAvgAggregateInputType = {
    msid?: true
    ms_volume_supplied?: true
  }

  export type Meter_supply_entriesSumAggregateInputType = {
    msid?: true
    ms_volume_supplied?: true
  }

  export type Meter_supply_entriesMinAggregateInputType = {
    msid?: true
    ms_unique_id?: true
    ms_userid?: true
    ms_supply_rate?: true
    ms_volume_supplied?: true
    ms_temperature_c?: true
    ms_temperature_f?: true
    ms_turbidity_level?: true
    ms_ph_level?: true
    ms_valve_state?: true
    createdAt?: true
  }

  export type Meter_supply_entriesMaxAggregateInputType = {
    msid?: true
    ms_unique_id?: true
    ms_userid?: true
    ms_supply_rate?: true
    ms_volume_supplied?: true
    ms_temperature_c?: true
    ms_temperature_f?: true
    ms_turbidity_level?: true
    ms_ph_level?: true
    ms_valve_state?: true
    createdAt?: true
  }

  export type Meter_supply_entriesCountAggregateInputType = {
    msid?: true
    ms_unique_id?: true
    ms_userid?: true
    ms_supply_rate?: true
    ms_volume_supplied?: true
    ms_temperature_c?: true
    ms_temperature_f?: true
    ms_turbidity_level?: true
    ms_ph_level?: true
    ms_valve_state?: true
    createdAt?: true
    _all?: true
  }

  export type Meter_supply_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_supply_entries to aggregate.
     */
    where?: meter_supply_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_supply_entries to fetch.
     */
    orderBy?: meter_supply_entriesOrderByWithRelationInput | meter_supply_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_supply_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_supply_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_supply_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_supply_entries
    **/
    _count?: true | Meter_supply_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_supply_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_supply_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_supply_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_supply_entriesMaxAggregateInputType
  }

  export type GetMeter_supply_entriesAggregateType<T extends Meter_supply_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_supply_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_supply_entries[P]>
      : GetScalarType<T[P], AggregateMeter_supply_entries[P]>
  }




  export type meter_supply_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_supply_entriesWhereInput
    orderBy?: meter_supply_entriesOrderByWithAggregationInput | meter_supply_entriesOrderByWithAggregationInput[]
    by: Meter_supply_entriesScalarFieldEnum[] | Meter_supply_entriesScalarFieldEnum
    having?: meter_supply_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_supply_entriesCountAggregateInputType | true
    _avg?: Meter_supply_entriesAvgAggregateInputType
    _sum?: Meter_supply_entriesSumAggregateInputType
    _min?: Meter_supply_entriesMinAggregateInputType
    _max?: Meter_supply_entriesMaxAggregateInputType
  }

  export type Meter_supply_entriesGroupByOutputType = {
    msid: number
    ms_unique_id: string
    ms_userid: string | null
    ms_supply_rate: string
    ms_volume_supplied: number
    ms_temperature_c: string
    ms_temperature_f: string
    ms_turbidity_level: string
    ms_ph_level: string
    ms_valve_state: string
    createdAt: Date
    _count: Meter_supply_entriesCountAggregateOutputType | null
    _avg: Meter_supply_entriesAvgAggregateOutputType | null
    _sum: Meter_supply_entriesSumAggregateOutputType | null
    _min: Meter_supply_entriesMinAggregateOutputType | null
    _max: Meter_supply_entriesMaxAggregateOutputType | null
  }

  type GetMeter_supply_entriesGroupByPayload<T extends meter_supply_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_supply_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_supply_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_supply_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_supply_entriesGroupByOutputType[P]>
        }
      >
    >


  export type meter_supply_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    msid?: boolean
    ms_unique_id?: boolean
    ms_userid?: boolean
    ms_supply_rate?: boolean
    ms_volume_supplied?: boolean
    ms_temperature_c?: boolean
    ms_temperature_f?: boolean
    ms_turbidity_level?: boolean
    ms_ph_level?: boolean
    ms_valve_state?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meter_supply_entries"]>



  export type meter_supply_entriesSelectScalar = {
    msid?: boolean
    ms_unique_id?: boolean
    ms_userid?: boolean
    ms_supply_rate?: boolean
    ms_volume_supplied?: boolean
    ms_temperature_c?: boolean
    ms_temperature_f?: boolean
    ms_turbidity_level?: boolean
    ms_ph_level?: boolean
    ms_valve_state?: boolean
    createdAt?: boolean
  }

  export type meter_supply_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"msid" | "ms_unique_id" | "ms_userid" | "ms_supply_rate" | "ms_volume_supplied" | "ms_temperature_c" | "ms_temperature_f" | "ms_turbidity_level" | "ms_ph_level" | "ms_valve_state" | "createdAt", ExtArgs["result"]["meter_supply_entries"]>

  export type $meter_supply_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_supply_entries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      msid: number
      ms_unique_id: string
      ms_userid: string | null
      ms_supply_rate: string
      ms_volume_supplied: number
      ms_temperature_c: string
      ms_temperature_f: string
      ms_turbidity_level: string
      ms_ph_level: string
      ms_valve_state: string
      createdAt: Date
    }, ExtArgs["result"]["meter_supply_entries"]>
    composites: {}
  }

  type meter_supply_entriesGetPayload<S extends boolean | null | undefined | meter_supply_entriesDefaultArgs> = $Result.GetResult<Prisma.$meter_supply_entriesPayload, S>

  type meter_supply_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meter_supply_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Meter_supply_entriesCountAggregateInputType | true
    }

  export interface meter_supply_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_supply_entries'], meta: { name: 'meter_supply_entries' } }
    /**
     * Find zero or one Meter_supply_entries that matches the filter.
     * @param {meter_supply_entriesFindUniqueArgs} args - Arguments to find a Meter_supply_entries
     * @example
     * // Get one Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_supply_entriesFindUniqueArgs>(args: SelectSubset<T, meter_supply_entriesFindUniqueArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meter_supply_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meter_supply_entriesFindUniqueOrThrowArgs} args - Arguments to find a Meter_supply_entries
     * @example
     * // Get one Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_supply_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_supply_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_supply_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesFindFirstArgs} args - Arguments to find a Meter_supply_entries
     * @example
     * // Get one Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_supply_entriesFindFirstArgs>(args?: SelectSubset<T, meter_supply_entriesFindFirstArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_supply_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesFindFirstOrThrowArgs} args - Arguments to find a Meter_supply_entries
     * @example
     * // Get one Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_supply_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_supply_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meter_supply_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findMany()
     * 
     * // Get first 10 Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.findMany({ take: 10 })
     * 
     * // Only select the `msid`
     * const meter_supply_entriesWithMsidOnly = await prisma.meter_supply_entries.findMany({ select: { msid: true } })
     * 
     */
    findMany<T extends meter_supply_entriesFindManyArgs>(args?: SelectSubset<T, meter_supply_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meter_supply_entries.
     * @param {meter_supply_entriesCreateArgs} args - Arguments to create a Meter_supply_entries.
     * @example
     * // Create one Meter_supply_entries
     * const Meter_supply_entries = await prisma.meter_supply_entries.create({
     *   data: {
     *     // ... data to create a Meter_supply_entries
     *   }
     * })
     * 
     */
    create<T extends meter_supply_entriesCreateArgs>(args: SelectSubset<T, meter_supply_entriesCreateArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meter_supply_entries.
     * @param {meter_supply_entriesCreateManyArgs} args - Arguments to create many Meter_supply_entries.
     * @example
     * // Create many Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_supply_entriesCreateManyArgs>(args?: SelectSubset<T, meter_supply_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meter_supply_entries.
     * @param {meter_supply_entriesDeleteArgs} args - Arguments to delete one Meter_supply_entries.
     * @example
     * // Delete one Meter_supply_entries
     * const Meter_supply_entries = await prisma.meter_supply_entries.delete({
     *   where: {
     *     // ... filter to delete one Meter_supply_entries
     *   }
     * })
     * 
     */
    delete<T extends meter_supply_entriesDeleteArgs>(args: SelectSubset<T, meter_supply_entriesDeleteArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meter_supply_entries.
     * @param {meter_supply_entriesUpdateArgs} args - Arguments to update one Meter_supply_entries.
     * @example
     * // Update one Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_supply_entriesUpdateArgs>(args: SelectSubset<T, meter_supply_entriesUpdateArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meter_supply_entries.
     * @param {meter_supply_entriesDeleteManyArgs} args - Arguments to filter Meter_supply_entries to delete.
     * @example
     * // Delete a few Meter_supply_entries
     * const { count } = await prisma.meter_supply_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_supply_entriesDeleteManyArgs>(args?: SelectSubset<T, meter_supply_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_supply_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_supply_entriesUpdateManyArgs>(args: SelectSubset<T, meter_supply_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_supply_entries.
     * @param {meter_supply_entriesUpsertArgs} args - Arguments to update or create a Meter_supply_entries.
     * @example
     * // Update or create a Meter_supply_entries
     * const meter_supply_entries = await prisma.meter_supply_entries.upsert({
     *   create: {
     *     // ... data to create a Meter_supply_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_supply_entries we want to update
     *   }
     * })
     */
    upsert<T extends meter_supply_entriesUpsertArgs>(args: SelectSubset<T, meter_supply_entriesUpsertArgs<ExtArgs>>): Prisma__meter_supply_entriesClient<$Result.GetResult<Prisma.$meter_supply_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meter_supply_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesCountArgs} args - Arguments to filter Meter_supply_entries to count.
     * @example
     * // Count the number of Meter_supply_entries
     * const count = await prisma.meter_supply_entries.count({
     *   where: {
     *     // ... the filter for the Meter_supply_entries we want to count
     *   }
     * })
    **/
    count<T extends meter_supply_entriesCountArgs>(
      args?: Subset<T, meter_supply_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_supply_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_supply_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_supply_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_supply_entriesAggregateArgs>(args: Subset<T, Meter_supply_entriesAggregateArgs>): Prisma.PrismaPromise<GetMeter_supply_entriesAggregateType<T>>

    /**
     * Group by Meter_supply_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_supply_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_supply_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_supply_entriesGroupByArgs['orderBy'] }
        : { orderBy?: meter_supply_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_supply_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_supply_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_supply_entries model
   */
  readonly fields: meter_supply_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_supply_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_supply_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_supply_entries model
   */
  interface meter_supply_entriesFieldRefs {
    readonly msid: FieldRef<"meter_supply_entries", 'Int'>
    readonly ms_unique_id: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_userid: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_supply_rate: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_volume_supplied: FieldRef<"meter_supply_entries", 'Int'>
    readonly ms_temperature_c: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_temperature_f: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_turbidity_level: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_ph_level: FieldRef<"meter_supply_entries", 'String'>
    readonly ms_valve_state: FieldRef<"meter_supply_entries", 'String'>
    readonly createdAt: FieldRef<"meter_supply_entries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meter_supply_entries findUnique
   */
  export type meter_supply_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_supply_entries to fetch.
     */
    where: meter_supply_entriesWhereUniqueInput
  }

  /**
   * meter_supply_entries findUniqueOrThrow
   */
  export type meter_supply_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_supply_entries to fetch.
     */
    where: meter_supply_entriesWhereUniqueInput
  }

  /**
   * meter_supply_entries findFirst
   */
  export type meter_supply_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_supply_entries to fetch.
     */
    where?: meter_supply_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_supply_entries to fetch.
     */
    orderBy?: meter_supply_entriesOrderByWithRelationInput | meter_supply_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_supply_entries.
     */
    cursor?: meter_supply_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_supply_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_supply_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_supply_entries.
     */
    distinct?: Meter_supply_entriesScalarFieldEnum | Meter_supply_entriesScalarFieldEnum[]
  }

  /**
   * meter_supply_entries findFirstOrThrow
   */
  export type meter_supply_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_supply_entries to fetch.
     */
    where?: meter_supply_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_supply_entries to fetch.
     */
    orderBy?: meter_supply_entriesOrderByWithRelationInput | meter_supply_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_supply_entries.
     */
    cursor?: meter_supply_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_supply_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_supply_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_supply_entries.
     */
    distinct?: Meter_supply_entriesScalarFieldEnum | Meter_supply_entriesScalarFieldEnum[]
  }

  /**
   * meter_supply_entries findMany
   */
  export type meter_supply_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_supply_entries to fetch.
     */
    where?: meter_supply_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_supply_entries to fetch.
     */
    orderBy?: meter_supply_entriesOrderByWithRelationInput | meter_supply_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_supply_entries.
     */
    cursor?: meter_supply_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_supply_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_supply_entries.
     */
    skip?: number
    distinct?: Meter_supply_entriesScalarFieldEnum | Meter_supply_entriesScalarFieldEnum[]
  }

  /**
   * meter_supply_entries create
   */
  export type meter_supply_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a meter_supply_entries.
     */
    data: XOR<meter_supply_entriesCreateInput, meter_supply_entriesUncheckedCreateInput>
  }

  /**
   * meter_supply_entries createMany
   */
  export type meter_supply_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_supply_entries.
     */
    data: meter_supply_entriesCreateManyInput | meter_supply_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_supply_entries update
   */
  export type meter_supply_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a meter_supply_entries.
     */
    data: XOR<meter_supply_entriesUpdateInput, meter_supply_entriesUncheckedUpdateInput>
    /**
     * Choose, which meter_supply_entries to update.
     */
    where: meter_supply_entriesWhereUniqueInput
  }

  /**
   * meter_supply_entries updateMany
   */
  export type meter_supply_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_supply_entries.
     */
    data: XOR<meter_supply_entriesUpdateManyMutationInput, meter_supply_entriesUncheckedUpdateManyInput>
    /**
     * Filter which meter_supply_entries to update
     */
    where?: meter_supply_entriesWhereInput
    /**
     * Limit how many meter_supply_entries to update.
     */
    limit?: number
  }

  /**
   * meter_supply_entries upsert
   */
  export type meter_supply_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the meter_supply_entries to update in case it exists.
     */
    where: meter_supply_entriesWhereUniqueInput
    /**
     * In case the meter_supply_entries found by the `where` argument doesn't exist, create a new meter_supply_entries with this data.
     */
    create: XOR<meter_supply_entriesCreateInput, meter_supply_entriesUncheckedCreateInput>
    /**
     * In case the meter_supply_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_supply_entriesUpdateInput, meter_supply_entriesUncheckedUpdateInput>
  }

  /**
   * meter_supply_entries delete
   */
  export type meter_supply_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
    /**
     * Filter which meter_supply_entries to delete.
     */
    where: meter_supply_entriesWhereUniqueInput
  }

  /**
   * meter_supply_entries deleteMany
   */
  export type meter_supply_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_supply_entries to delete
     */
    where?: meter_supply_entriesWhereInput
    /**
     * Limit how many meter_supply_entries to delete.
     */
    limit?: number
  }

  /**
   * meter_supply_entries without action
   */
  export type meter_supply_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_supply_entries
     */
    select?: meter_supply_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_supply_entries
     */
    omit?: meter_supply_entriesOmit<ExtArgs> | null
  }


  /**
   * Model meter_tanker_entries
   */

  export type AggregateMeter_tanker_entries = {
    _count: Meter_tanker_entriesCountAggregateOutputType | null
    _avg: Meter_tanker_entriesAvgAggregateOutputType | null
    _sum: Meter_tanker_entriesSumAggregateOutputType | null
    _min: Meter_tanker_entriesMinAggregateOutputType | null
    _max: Meter_tanker_entriesMaxAggregateOutputType | null
  }

  export type Meter_tanker_entriesAvgAggregateOutputType = {
    mtid: number | null
    mt_volume_delivered: number | null
  }

  export type Meter_tanker_entriesSumAggregateOutputType = {
    mtid: number | null
    mt_volume_delivered: number | null
  }

  export type Meter_tanker_entriesMinAggregateOutputType = {
    mtid: number | null
    mt_unique_id: string | null
    mt_tankerid: string | null
    mt_delivery_rate: string | null
    mt_volume_delivered: number | null
    mt_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_tanker_entriesMaxAggregateOutputType = {
    mtid: number | null
    mt_unique_id: string | null
    mt_tankerid: string | null
    mt_delivery_rate: string | null
    mt_volume_delivered: number | null
    mt_valve_state: string | null
    createdAt: Date | null
  }

  export type Meter_tanker_entriesCountAggregateOutputType = {
    mtid: number
    mt_unique_id: number
    mt_tankerid: number
    mt_delivery_rate: number
    mt_volume_delivered: number
    mt_valve_state: number
    createdAt: number
    _all: number
  }


  export type Meter_tanker_entriesAvgAggregateInputType = {
    mtid?: true
    mt_volume_delivered?: true
  }

  export type Meter_tanker_entriesSumAggregateInputType = {
    mtid?: true
    mt_volume_delivered?: true
  }

  export type Meter_tanker_entriesMinAggregateInputType = {
    mtid?: true
    mt_unique_id?: true
    mt_tankerid?: true
    mt_delivery_rate?: true
    mt_volume_delivered?: true
    mt_valve_state?: true
    createdAt?: true
  }

  export type Meter_tanker_entriesMaxAggregateInputType = {
    mtid?: true
    mt_unique_id?: true
    mt_tankerid?: true
    mt_delivery_rate?: true
    mt_volume_delivered?: true
    mt_valve_state?: true
    createdAt?: true
  }

  export type Meter_tanker_entriesCountAggregateInputType = {
    mtid?: true
    mt_unique_id?: true
    mt_tankerid?: true
    mt_delivery_rate?: true
    mt_volume_delivered?: true
    mt_valve_state?: true
    createdAt?: true
    _all?: true
  }

  export type Meter_tanker_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_tanker_entries to aggregate.
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_tanker_entries to fetch.
     */
    orderBy?: meter_tanker_entriesOrderByWithRelationInput | meter_tanker_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_tanker_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_tanker_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_tanker_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_tanker_entries
    **/
    _count?: true | Meter_tanker_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_tanker_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_tanker_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_tanker_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_tanker_entriesMaxAggregateInputType
  }

  export type GetMeter_tanker_entriesAggregateType<T extends Meter_tanker_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_tanker_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_tanker_entries[P]>
      : GetScalarType<T[P], AggregateMeter_tanker_entries[P]>
  }




  export type meter_tanker_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_tanker_entriesWhereInput
    orderBy?: meter_tanker_entriesOrderByWithAggregationInput | meter_tanker_entriesOrderByWithAggregationInput[]
    by: Meter_tanker_entriesScalarFieldEnum[] | Meter_tanker_entriesScalarFieldEnum
    having?: meter_tanker_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_tanker_entriesCountAggregateInputType | true
    _avg?: Meter_tanker_entriesAvgAggregateInputType
    _sum?: Meter_tanker_entriesSumAggregateInputType
    _min?: Meter_tanker_entriesMinAggregateInputType
    _max?: Meter_tanker_entriesMaxAggregateInputType
  }

  export type Meter_tanker_entriesGroupByOutputType = {
    mtid: number
    mt_unique_id: string
    mt_tankerid: string | null
    mt_delivery_rate: string
    mt_volume_delivered: number
    mt_valve_state: string
    createdAt: Date
    _count: Meter_tanker_entriesCountAggregateOutputType | null
    _avg: Meter_tanker_entriesAvgAggregateOutputType | null
    _sum: Meter_tanker_entriesSumAggregateOutputType | null
    _min: Meter_tanker_entriesMinAggregateOutputType | null
    _max: Meter_tanker_entriesMaxAggregateOutputType | null
  }

  type GetMeter_tanker_entriesGroupByPayload<T extends meter_tanker_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_tanker_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_tanker_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_tanker_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_tanker_entriesGroupByOutputType[P]>
        }
      >
    >


  export type meter_tanker_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mtid?: boolean
    mt_unique_id?: boolean
    mt_tankerid?: boolean
    mt_delivery_rate?: boolean
    mt_volume_delivered?: boolean
    mt_valve_state?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meter_tanker_entries"]>



  export type meter_tanker_entriesSelectScalar = {
    mtid?: boolean
    mt_unique_id?: boolean
    mt_tankerid?: boolean
    mt_delivery_rate?: boolean
    mt_volume_delivered?: boolean
    mt_valve_state?: boolean
    createdAt?: boolean
  }

  export type meter_tanker_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mtid" | "mt_unique_id" | "mt_tankerid" | "mt_delivery_rate" | "mt_volume_delivered" | "mt_valve_state" | "createdAt", ExtArgs["result"]["meter_tanker_entries"]>

  export type $meter_tanker_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_tanker_entries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      mtid: number
      mt_unique_id: string
      mt_tankerid: string | null
      mt_delivery_rate: string
      mt_volume_delivered: number
      mt_valve_state: string
      createdAt: Date
    }, ExtArgs["result"]["meter_tanker_entries"]>
    composites: {}
  }

  type meter_tanker_entriesGetPayload<S extends boolean | null | undefined | meter_tanker_entriesDefaultArgs> = $Result.GetResult<Prisma.$meter_tanker_entriesPayload, S>

  type meter_tanker_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meter_tanker_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Meter_tanker_entriesCountAggregateInputType | true
    }

  export interface meter_tanker_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_tanker_entries'], meta: { name: 'meter_tanker_entries' } }
    /**
     * Find zero or one Meter_tanker_entries that matches the filter.
     * @param {meter_tanker_entriesFindUniqueArgs} args - Arguments to find a Meter_tanker_entries
     * @example
     * // Get one Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_tanker_entriesFindUniqueArgs>(args: SelectSubset<T, meter_tanker_entriesFindUniqueArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meter_tanker_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meter_tanker_entriesFindUniqueOrThrowArgs} args - Arguments to find a Meter_tanker_entries
     * @example
     * // Get one Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_tanker_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_tanker_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_tanker_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesFindFirstArgs} args - Arguments to find a Meter_tanker_entries
     * @example
     * // Get one Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_tanker_entriesFindFirstArgs>(args?: SelectSubset<T, meter_tanker_entriesFindFirstArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_tanker_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesFindFirstOrThrowArgs} args - Arguments to find a Meter_tanker_entries
     * @example
     * // Get one Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_tanker_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_tanker_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meter_tanker_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findMany()
     * 
     * // Get first 10 Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.findMany({ take: 10 })
     * 
     * // Only select the `mtid`
     * const meter_tanker_entriesWithMtidOnly = await prisma.meter_tanker_entries.findMany({ select: { mtid: true } })
     * 
     */
    findMany<T extends meter_tanker_entriesFindManyArgs>(args?: SelectSubset<T, meter_tanker_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meter_tanker_entries.
     * @param {meter_tanker_entriesCreateArgs} args - Arguments to create a Meter_tanker_entries.
     * @example
     * // Create one Meter_tanker_entries
     * const Meter_tanker_entries = await prisma.meter_tanker_entries.create({
     *   data: {
     *     // ... data to create a Meter_tanker_entries
     *   }
     * })
     * 
     */
    create<T extends meter_tanker_entriesCreateArgs>(args: SelectSubset<T, meter_tanker_entriesCreateArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meter_tanker_entries.
     * @param {meter_tanker_entriesCreateManyArgs} args - Arguments to create many Meter_tanker_entries.
     * @example
     * // Create many Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_tanker_entriesCreateManyArgs>(args?: SelectSubset<T, meter_tanker_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meter_tanker_entries.
     * @param {meter_tanker_entriesDeleteArgs} args - Arguments to delete one Meter_tanker_entries.
     * @example
     * // Delete one Meter_tanker_entries
     * const Meter_tanker_entries = await prisma.meter_tanker_entries.delete({
     *   where: {
     *     // ... filter to delete one Meter_tanker_entries
     *   }
     * })
     * 
     */
    delete<T extends meter_tanker_entriesDeleteArgs>(args: SelectSubset<T, meter_tanker_entriesDeleteArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meter_tanker_entries.
     * @param {meter_tanker_entriesUpdateArgs} args - Arguments to update one Meter_tanker_entries.
     * @example
     * // Update one Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_tanker_entriesUpdateArgs>(args: SelectSubset<T, meter_tanker_entriesUpdateArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meter_tanker_entries.
     * @param {meter_tanker_entriesDeleteManyArgs} args - Arguments to filter Meter_tanker_entries to delete.
     * @example
     * // Delete a few Meter_tanker_entries
     * const { count } = await prisma.meter_tanker_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_tanker_entriesDeleteManyArgs>(args?: SelectSubset<T, meter_tanker_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_tanker_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_tanker_entriesUpdateManyArgs>(args: SelectSubset<T, meter_tanker_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_tanker_entries.
     * @param {meter_tanker_entriesUpsertArgs} args - Arguments to update or create a Meter_tanker_entries.
     * @example
     * // Update or create a Meter_tanker_entries
     * const meter_tanker_entries = await prisma.meter_tanker_entries.upsert({
     *   create: {
     *     // ... data to create a Meter_tanker_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_tanker_entries we want to update
     *   }
     * })
     */
    upsert<T extends meter_tanker_entriesUpsertArgs>(args: SelectSubset<T, meter_tanker_entriesUpsertArgs<ExtArgs>>): Prisma__meter_tanker_entriesClient<$Result.GetResult<Prisma.$meter_tanker_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meter_tanker_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesCountArgs} args - Arguments to filter Meter_tanker_entries to count.
     * @example
     * // Count the number of Meter_tanker_entries
     * const count = await prisma.meter_tanker_entries.count({
     *   where: {
     *     // ... the filter for the Meter_tanker_entries we want to count
     *   }
     * })
    **/
    count<T extends meter_tanker_entriesCountArgs>(
      args?: Subset<T, meter_tanker_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_tanker_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_tanker_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_tanker_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_tanker_entriesAggregateArgs>(args: Subset<T, Meter_tanker_entriesAggregateArgs>): Prisma.PrismaPromise<GetMeter_tanker_entriesAggregateType<T>>

    /**
     * Group by Meter_tanker_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_tanker_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_tanker_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_tanker_entriesGroupByArgs['orderBy'] }
        : { orderBy?: meter_tanker_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_tanker_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_tanker_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_tanker_entries model
   */
  readonly fields: meter_tanker_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_tanker_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_tanker_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_tanker_entries model
   */
  interface meter_tanker_entriesFieldRefs {
    readonly mtid: FieldRef<"meter_tanker_entries", 'Int'>
    readonly mt_unique_id: FieldRef<"meter_tanker_entries", 'String'>
    readonly mt_tankerid: FieldRef<"meter_tanker_entries", 'String'>
    readonly mt_delivery_rate: FieldRef<"meter_tanker_entries", 'String'>
    readonly mt_volume_delivered: FieldRef<"meter_tanker_entries", 'Int'>
    readonly mt_valve_state: FieldRef<"meter_tanker_entries", 'String'>
    readonly createdAt: FieldRef<"meter_tanker_entries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meter_tanker_entries findUnique
   */
  export type meter_tanker_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_tanker_entries to fetch.
     */
    where: meter_tanker_entriesWhereUniqueInput
  }

  /**
   * meter_tanker_entries findUniqueOrThrow
   */
  export type meter_tanker_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_tanker_entries to fetch.
     */
    where: meter_tanker_entriesWhereUniqueInput
  }

  /**
   * meter_tanker_entries findFirst
   */
  export type meter_tanker_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_tanker_entries to fetch.
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_tanker_entries to fetch.
     */
    orderBy?: meter_tanker_entriesOrderByWithRelationInput | meter_tanker_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_tanker_entries.
     */
    cursor?: meter_tanker_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_tanker_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_tanker_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_tanker_entries.
     */
    distinct?: Meter_tanker_entriesScalarFieldEnum | Meter_tanker_entriesScalarFieldEnum[]
  }

  /**
   * meter_tanker_entries findFirstOrThrow
   */
  export type meter_tanker_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_tanker_entries to fetch.
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_tanker_entries to fetch.
     */
    orderBy?: meter_tanker_entriesOrderByWithRelationInput | meter_tanker_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_tanker_entries.
     */
    cursor?: meter_tanker_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_tanker_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_tanker_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_tanker_entries.
     */
    distinct?: Meter_tanker_entriesScalarFieldEnum | Meter_tanker_entriesScalarFieldEnum[]
  }

  /**
   * meter_tanker_entries findMany
   */
  export type meter_tanker_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter, which meter_tanker_entries to fetch.
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_tanker_entries to fetch.
     */
    orderBy?: meter_tanker_entriesOrderByWithRelationInput | meter_tanker_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_tanker_entries.
     */
    cursor?: meter_tanker_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_tanker_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_tanker_entries.
     */
    skip?: number
    distinct?: Meter_tanker_entriesScalarFieldEnum | Meter_tanker_entriesScalarFieldEnum[]
  }

  /**
   * meter_tanker_entries create
   */
  export type meter_tanker_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a meter_tanker_entries.
     */
    data: XOR<meter_tanker_entriesCreateInput, meter_tanker_entriesUncheckedCreateInput>
  }

  /**
   * meter_tanker_entries createMany
   */
  export type meter_tanker_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_tanker_entries.
     */
    data: meter_tanker_entriesCreateManyInput | meter_tanker_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_tanker_entries update
   */
  export type meter_tanker_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a meter_tanker_entries.
     */
    data: XOR<meter_tanker_entriesUpdateInput, meter_tanker_entriesUncheckedUpdateInput>
    /**
     * Choose, which meter_tanker_entries to update.
     */
    where: meter_tanker_entriesWhereUniqueInput
  }

  /**
   * meter_tanker_entries updateMany
   */
  export type meter_tanker_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_tanker_entries.
     */
    data: XOR<meter_tanker_entriesUpdateManyMutationInput, meter_tanker_entriesUncheckedUpdateManyInput>
    /**
     * Filter which meter_tanker_entries to update
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * Limit how many meter_tanker_entries to update.
     */
    limit?: number
  }

  /**
   * meter_tanker_entries upsert
   */
  export type meter_tanker_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the meter_tanker_entries to update in case it exists.
     */
    where: meter_tanker_entriesWhereUniqueInput
    /**
     * In case the meter_tanker_entries found by the `where` argument doesn't exist, create a new meter_tanker_entries with this data.
     */
    create: XOR<meter_tanker_entriesCreateInput, meter_tanker_entriesUncheckedCreateInput>
    /**
     * In case the meter_tanker_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_tanker_entriesUpdateInput, meter_tanker_entriesUncheckedUpdateInput>
  }

  /**
   * meter_tanker_entries delete
   */
  export type meter_tanker_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
    /**
     * Filter which meter_tanker_entries to delete.
     */
    where: meter_tanker_entriesWhereUniqueInput
  }

  /**
   * meter_tanker_entries deleteMany
   */
  export type meter_tanker_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_tanker_entries to delete
     */
    where?: meter_tanker_entriesWhereInput
    /**
     * Limit how many meter_tanker_entries to delete.
     */
    limit?: number
  }

  /**
   * meter_tanker_entries without action
   */
  export type meter_tanker_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_tanker_entries
     */
    select?: meter_tanker_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_tanker_entries
     */
    omit?: meter_tanker_entriesOmit<ExtArgs> | null
  }


  /**
   * Model meters
   */

  export type AggregateMeters = {
    _count: MetersCountAggregateOutputType | null
    _avg: MetersAvgAggregateOutputType | null
    _sum: MetersSumAggregateOutputType | null
    _min: MetersMinAggregateOutputType | null
    _max: MetersMaxAggregateOutputType | null
  }

  export type MetersAvgAggregateOutputType = {
    meterid: number | null
    m_water_unit_price: number | null
  }

  export type MetersSumAggregateOutputType = {
    meterid: number | null
    m_water_unit_price: number | null
  }

  export type MetersMinAggregateOutputType = {
    meterid: number | null
    m_account_number: string | null
    m_unique_id: string | null
    m_for: string | null
    m_assigned: string | null
    m_assigned_to: string | null
    m_assigned_name: string | null
    m_assigned_phone: string | null
    m_assigned_address: string | null
    m_area: string | null
    m_status: string | null
    m_valve_state: string | null
    m_water_unit_price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetersMaxAggregateOutputType = {
    meterid: number | null
    m_account_number: string | null
    m_unique_id: string | null
    m_for: string | null
    m_assigned: string | null
    m_assigned_to: string | null
    m_assigned_name: string | null
    m_assigned_phone: string | null
    m_assigned_address: string | null
    m_area: string | null
    m_status: string | null
    m_valve_state: string | null
    m_water_unit_price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetersCountAggregateOutputType = {
    meterid: number
    m_account_number: number
    m_unique_id: number
    m_for: number
    m_assigned: number
    m_assigned_to: number
    m_assigned_name: number
    m_assigned_phone: number
    m_assigned_address: number
    m_area: number
    m_status: number
    m_valve_state: number
    m_water_unit_price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetersAvgAggregateInputType = {
    meterid?: true
    m_water_unit_price?: true
  }

  export type MetersSumAggregateInputType = {
    meterid?: true
    m_water_unit_price?: true
  }

  export type MetersMinAggregateInputType = {
    meterid?: true
    m_account_number?: true
    m_unique_id?: true
    m_for?: true
    m_assigned?: true
    m_assigned_to?: true
    m_assigned_name?: true
    m_assigned_phone?: true
    m_assigned_address?: true
    m_area?: true
    m_status?: true
    m_valve_state?: true
    m_water_unit_price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetersMaxAggregateInputType = {
    meterid?: true
    m_account_number?: true
    m_unique_id?: true
    m_for?: true
    m_assigned?: true
    m_assigned_to?: true
    m_assigned_name?: true
    m_assigned_phone?: true
    m_assigned_address?: true
    m_area?: true
    m_status?: true
    m_valve_state?: true
    m_water_unit_price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetersCountAggregateInputType = {
    meterid?: true
    m_account_number?: true
    m_unique_id?: true
    m_for?: true
    m_assigned?: true
    m_assigned_to?: true
    m_assigned_name?: true
    m_assigned_phone?: true
    m_assigned_address?: true
    m_area?: true
    m_status?: true
    m_valve_state?: true
    m_water_unit_price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meters to aggregate.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meters
    **/
    _count?: true | MetersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetersMaxAggregateInputType
  }

  export type GetMetersAggregateType<T extends MetersAggregateArgs> = {
        [P in keyof T & keyof AggregateMeters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeters[P]>
      : GetScalarType<T[P], AggregateMeters[P]>
  }




  export type metersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metersWhereInput
    orderBy?: metersOrderByWithAggregationInput | metersOrderByWithAggregationInput[]
    by: MetersScalarFieldEnum[] | MetersScalarFieldEnum
    having?: metersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetersCountAggregateInputType | true
    _avg?: MetersAvgAggregateInputType
    _sum?: MetersSumAggregateInputType
    _min?: MetersMinAggregateInputType
    _max?: MetersMaxAggregateInputType
  }

  export type MetersGroupByOutputType = {
    meterid: number
    m_account_number: string | null
    m_unique_id: string
    m_for: string
    m_assigned: string
    m_assigned_to: string | null
    m_assigned_name: string | null
    m_assigned_phone: string | null
    m_assigned_address: string | null
    m_area: string | null
    m_status: string
    m_valve_state: string
    m_water_unit_price: number
    createdAt: Date
    updatedAt: Date
    _count: MetersCountAggregateOutputType | null
    _avg: MetersAvgAggregateOutputType | null
    _sum: MetersSumAggregateOutputType | null
    _min: MetersMinAggregateOutputType | null
    _max: MetersMaxAggregateOutputType | null
  }

  type GetMetersGroupByPayload<T extends metersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetersGroupByOutputType[P]>
            : GetScalarType<T[P], MetersGroupByOutputType[P]>
        }
      >
    >


  export type metersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    meterid?: boolean
    m_account_number?: boolean
    m_unique_id?: boolean
    m_for?: boolean
    m_assigned?: boolean
    m_assigned_to?: boolean
    m_assigned_name?: boolean
    m_assigned_phone?: boolean
    m_assigned_address?: boolean
    m_area?: boolean
    m_status?: boolean
    m_valve_state?: boolean
    m_water_unit_price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meter_readings?: boolean | meters$meter_readingsArgs<ExtArgs>
    _count?: boolean | MetersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meters"]>



  export type metersSelectScalar = {
    meterid?: boolean
    m_account_number?: boolean
    m_unique_id?: boolean
    m_for?: boolean
    m_assigned?: boolean
    m_assigned_to?: boolean
    m_assigned_name?: boolean
    m_assigned_phone?: boolean
    m_assigned_address?: boolean
    m_area?: boolean
    m_status?: boolean
    m_valve_state?: boolean
    m_water_unit_price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type metersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"meterid" | "m_account_number" | "m_unique_id" | "m_for" | "m_assigned" | "m_assigned_to" | "m_assigned_name" | "m_assigned_phone" | "m_assigned_address" | "m_area" | "m_status" | "m_valve_state" | "m_water_unit_price" | "createdAt" | "updatedAt", ExtArgs["result"]["meters"]>
  export type metersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meter_readings?: boolean | meters$meter_readingsArgs<ExtArgs>
    _count?: boolean | MetersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $metersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meters"
    objects: {
      meter_readings: Prisma.$MeterReadingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      meterid: number
      m_account_number: string | null
      m_unique_id: string
      m_for: string
      m_assigned: string
      m_assigned_to: string | null
      m_assigned_name: string | null
      m_assigned_phone: string | null
      m_assigned_address: string | null
      m_area: string | null
      m_status: string
      m_valve_state: string
      m_water_unit_price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meters"]>
    composites: {}
  }

  type metersGetPayload<S extends boolean | null | undefined | metersDefaultArgs> = $Result.GetResult<Prisma.$metersPayload, S>

  type metersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<metersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetersCountAggregateInputType | true
    }

  export interface metersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meters'], meta: { name: 'meters' } }
    /**
     * Find zero or one Meters that matches the filter.
     * @param {metersFindUniqueArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metersFindUniqueArgs>(args: SelectSubset<T, metersFindUniqueArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metersFindUniqueOrThrowArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metersFindUniqueOrThrowArgs>(args: SelectSubset<T, metersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindFirstArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metersFindFirstArgs>(args?: SelectSubset<T, metersFindFirstArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindFirstOrThrowArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metersFindFirstOrThrowArgs>(args?: SelectSubset<T, metersFindFirstOrThrowArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meters
     * const meters = await prisma.meters.findMany()
     * 
     * // Get first 10 Meters
     * const meters = await prisma.meters.findMany({ take: 10 })
     * 
     * // Only select the `meterid`
     * const metersWithMeteridOnly = await prisma.meters.findMany({ select: { meterid: true } })
     * 
     */
    findMany<T extends metersFindManyArgs>(args?: SelectSubset<T, metersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meters.
     * @param {metersCreateArgs} args - Arguments to create a Meters.
     * @example
     * // Create one Meters
     * const Meters = await prisma.meters.create({
     *   data: {
     *     // ... data to create a Meters
     *   }
     * })
     * 
     */
    create<T extends metersCreateArgs>(args: SelectSubset<T, metersCreateArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meters.
     * @param {metersCreateManyArgs} args - Arguments to create many Meters.
     * @example
     * // Create many Meters
     * const meters = await prisma.meters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metersCreateManyArgs>(args?: SelectSubset<T, metersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meters.
     * @param {metersDeleteArgs} args - Arguments to delete one Meters.
     * @example
     * // Delete one Meters
     * const Meters = await prisma.meters.delete({
     *   where: {
     *     // ... filter to delete one Meters
     *   }
     * })
     * 
     */
    delete<T extends metersDeleteArgs>(args: SelectSubset<T, metersDeleteArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meters.
     * @param {metersUpdateArgs} args - Arguments to update one Meters.
     * @example
     * // Update one Meters
     * const meters = await prisma.meters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metersUpdateArgs>(args: SelectSubset<T, metersUpdateArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meters.
     * @param {metersDeleteManyArgs} args - Arguments to filter Meters to delete.
     * @example
     * // Delete a few Meters
     * const { count } = await prisma.meters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metersDeleteManyArgs>(args?: SelectSubset<T, metersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meters
     * const meters = await prisma.meters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metersUpdateManyArgs>(args: SelectSubset<T, metersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meters.
     * @param {metersUpsertArgs} args - Arguments to update or create a Meters.
     * @example
     * // Update or create a Meters
     * const meters = await prisma.meters.upsert({
     *   create: {
     *     // ... data to create a Meters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meters we want to update
     *   }
     * })
     */
    upsert<T extends metersUpsertArgs>(args: SelectSubset<T, metersUpsertArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersCountArgs} args - Arguments to filter Meters to count.
     * @example
     * // Count the number of Meters
     * const count = await prisma.meters.count({
     *   where: {
     *     // ... the filter for the Meters we want to count
     *   }
     * })
    **/
    count<T extends metersCountArgs>(
      args?: Subset<T, metersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetersAggregateArgs>(args: Subset<T, MetersAggregateArgs>): Prisma.PrismaPromise<GetMetersAggregateType<T>>

    /**
     * Group by Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metersGroupByArgs['orderBy'] }
        : { orderBy?: metersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meters model
   */
  readonly fields: metersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meter_readings<T extends meters$meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, meters$meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meters model
   */
  interface metersFieldRefs {
    readonly meterid: FieldRef<"meters", 'Int'>
    readonly m_account_number: FieldRef<"meters", 'String'>
    readonly m_unique_id: FieldRef<"meters", 'String'>
    readonly m_for: FieldRef<"meters", 'String'>
    readonly m_assigned: FieldRef<"meters", 'String'>
    readonly m_assigned_to: FieldRef<"meters", 'String'>
    readonly m_assigned_name: FieldRef<"meters", 'String'>
    readonly m_assigned_phone: FieldRef<"meters", 'String'>
    readonly m_assigned_address: FieldRef<"meters", 'String'>
    readonly m_area: FieldRef<"meters", 'String'>
    readonly m_status: FieldRef<"meters", 'String'>
    readonly m_valve_state: FieldRef<"meters", 'String'>
    readonly m_water_unit_price: FieldRef<"meters", 'Float'>
    readonly createdAt: FieldRef<"meters", 'DateTime'>
    readonly updatedAt: FieldRef<"meters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meters findUnique
   */
  export type metersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters findUniqueOrThrow
   */
  export type metersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters findFirst
   */
  export type metersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meters.
     */
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters findFirstOrThrow
   */
  export type metersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meters.
     */
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters findMany
   */
  export type metersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters create
   */
  export type metersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The data needed to create a meters.
     */
    data: XOR<metersCreateInput, metersUncheckedCreateInput>
  }

  /**
   * meters createMany
   */
  export type metersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meters.
     */
    data: metersCreateManyInput | metersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meters update
   */
  export type metersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The data needed to update a meters.
     */
    data: XOR<metersUpdateInput, metersUncheckedUpdateInput>
    /**
     * Choose, which meters to update.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters updateMany
   */
  export type metersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meters.
     */
    data: XOR<metersUpdateManyMutationInput, metersUncheckedUpdateManyInput>
    /**
     * Filter which meters to update
     */
    where?: metersWhereInput
    /**
     * Limit how many meters to update.
     */
    limit?: number
  }

  /**
   * meters upsert
   */
  export type metersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The filter to search for the meters to update in case it exists.
     */
    where: metersWhereUniqueInput
    /**
     * In case the meters found by the `where` argument doesn't exist, create a new meters with this data.
     */
    create: XOR<metersCreateInput, metersUncheckedCreateInput>
    /**
     * In case the meters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metersUpdateInput, metersUncheckedUpdateInput>
  }

  /**
   * meters delete
   */
  export type metersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter which meters to delete.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters deleteMany
   */
  export type metersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meters to delete
     */
    where?: metersWhereInput
    /**
     * Limit how many meters to delete.
     */
    limit?: number
  }

  /**
   * meters.meter_readings
   */
  export type meters$meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    where?: MeterReadingsWhereInput
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    cursor?: MeterReadingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * meters without action
   */
  export type metersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meters
     */
    omit?: metersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
  }


  /**
   * Model contact_messages
   */

  export type AggregateContact_messages = {
    _count: Contact_messagesCountAggregateOutputType | null
    _avg: Contact_messagesAvgAggregateOutputType | null
    _sum: Contact_messagesSumAggregateOutputType | null
    _min: Contact_messagesMinAggregateOutputType | null
    _max: Contact_messagesMaxAggregateOutputType | null
  }

  export type Contact_messagesAvgAggregateOutputType = {
    cid: number | null
  }

  export type Contact_messagesSumAggregateOutputType = {
    cid: number | null
  }

  export type Contact_messagesMinAggregateOutputType = {
    cid: number | null
    cname: string | null
    cphone: string | null
    cemail: string | null
    csubject: string | null
    cmessage: string | null
    cstatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Contact_messagesMaxAggregateOutputType = {
    cid: number | null
    cname: string | null
    cphone: string | null
    cemail: string | null
    csubject: string | null
    cmessage: string | null
    cstatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Contact_messagesCountAggregateOutputType = {
    cid: number
    cname: number
    cphone: number
    cemail: number
    csubject: number
    cmessage: number
    cstatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Contact_messagesAvgAggregateInputType = {
    cid?: true
  }

  export type Contact_messagesSumAggregateInputType = {
    cid?: true
  }

  export type Contact_messagesMinAggregateInputType = {
    cid?: true
    cname?: true
    cphone?: true
    cemail?: true
    csubject?: true
    cmessage?: true
    cstatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Contact_messagesMaxAggregateInputType = {
    cid?: true
    cname?: true
    cphone?: true
    cemail?: true
    csubject?: true
    cmessage?: true
    cstatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Contact_messagesCountAggregateInputType = {
    cid?: true
    cname?: true
    cphone?: true
    cemail?: true
    csubject?: true
    cmessage?: true
    cstatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Contact_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_messages to aggregate.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contact_messages
    **/
    _count?: true | Contact_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_messagesMaxAggregateInputType
  }

  export type GetContact_messagesAggregateType<T extends Contact_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_messages[P]>
      : GetScalarType<T[P], AggregateContact_messages[P]>
  }




  export type contact_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contact_messagesWhereInput
    orderBy?: contact_messagesOrderByWithAggregationInput | contact_messagesOrderByWithAggregationInput[]
    by: Contact_messagesScalarFieldEnum[] | Contact_messagesScalarFieldEnum
    having?: contact_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_messagesCountAggregateInputType | true
    _avg?: Contact_messagesAvgAggregateInputType
    _sum?: Contact_messagesSumAggregateInputType
    _min?: Contact_messagesMinAggregateInputType
    _max?: Contact_messagesMaxAggregateInputType
  }

  export type Contact_messagesGroupByOutputType = {
    cid: number
    cname: string
    cphone: string
    cemail: string
    csubject: string
    cmessage: string
    cstatus: string
    createdAt: Date
    updatedAt: Date
    _count: Contact_messagesCountAggregateOutputType | null
    _avg: Contact_messagesAvgAggregateOutputType | null
    _sum: Contact_messagesSumAggregateOutputType | null
    _min: Contact_messagesMinAggregateOutputType | null
    _max: Contact_messagesMaxAggregateOutputType | null
  }

  type GetContact_messagesGroupByPayload<T extends contact_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_messagesGroupByOutputType[P]>
        }
      >
    >


  export type contact_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cid?: boolean
    cname?: boolean
    cphone?: boolean
    cemail?: boolean
    csubject?: boolean
    cmessage?: boolean
    cstatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact_messages"]>



  export type contact_messagesSelectScalar = {
    cid?: boolean
    cname?: boolean
    cphone?: boolean
    cemail?: boolean
    csubject?: boolean
    cmessage?: boolean
    cstatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type contact_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cid" | "cname" | "cphone" | "cemail" | "csubject" | "cmessage" | "cstatus" | "createdAt" | "updatedAt", ExtArgs["result"]["contact_messages"]>

  export type $contact_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact_messages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cid: number
      cname: string
      cphone: string
      cemail: string
      csubject: string
      cmessage: string
      cstatus: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact_messages"]>
    composites: {}
  }

  type contact_messagesGetPayload<S extends boolean | null | undefined | contact_messagesDefaultArgs> = $Result.GetResult<Prisma.$contact_messagesPayload, S>

  type contact_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contact_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Contact_messagesCountAggregateInputType | true
    }

  export interface contact_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact_messages'], meta: { name: 'contact_messages' } }
    /**
     * Find zero or one Contact_messages that matches the filter.
     * @param {contact_messagesFindUniqueArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contact_messagesFindUniqueArgs>(args: SelectSubset<T, contact_messagesFindUniqueArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contact_messagesFindUniqueOrThrowArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contact_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, contact_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindFirstArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contact_messagesFindFirstArgs>(args?: SelectSubset<T, contact_messagesFindFirstArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindFirstOrThrowArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contact_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, contact_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contact_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_messages
     * const contact_messages = await prisma.contact_messages.findMany()
     * 
     * // Get first 10 Contact_messages
     * const contact_messages = await prisma.contact_messages.findMany({ take: 10 })
     * 
     * // Only select the `cid`
     * const contact_messagesWithCidOnly = await prisma.contact_messages.findMany({ select: { cid: true } })
     * 
     */
    findMany<T extends contact_messagesFindManyArgs>(args?: SelectSubset<T, contact_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact_messages.
     * @param {contact_messagesCreateArgs} args - Arguments to create a Contact_messages.
     * @example
     * // Create one Contact_messages
     * const Contact_messages = await prisma.contact_messages.create({
     *   data: {
     *     // ... data to create a Contact_messages
     *   }
     * })
     * 
     */
    create<T extends contact_messagesCreateArgs>(args: SelectSubset<T, contact_messagesCreateArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contact_messages.
     * @param {contact_messagesCreateManyArgs} args - Arguments to create many Contact_messages.
     * @example
     * // Create many Contact_messages
     * const contact_messages = await prisma.contact_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contact_messagesCreateManyArgs>(args?: SelectSubset<T, contact_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact_messages.
     * @param {contact_messagesDeleteArgs} args - Arguments to delete one Contact_messages.
     * @example
     * // Delete one Contact_messages
     * const Contact_messages = await prisma.contact_messages.delete({
     *   where: {
     *     // ... filter to delete one Contact_messages
     *   }
     * })
     * 
     */
    delete<T extends contact_messagesDeleteArgs>(args: SelectSubset<T, contact_messagesDeleteArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact_messages.
     * @param {contact_messagesUpdateArgs} args - Arguments to update one Contact_messages.
     * @example
     * // Update one Contact_messages
     * const contact_messages = await prisma.contact_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contact_messagesUpdateArgs>(args: SelectSubset<T, contact_messagesUpdateArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contact_messages.
     * @param {contact_messagesDeleteManyArgs} args - Arguments to filter Contact_messages to delete.
     * @example
     * // Delete a few Contact_messages
     * const { count } = await prisma.contact_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contact_messagesDeleteManyArgs>(args?: SelectSubset<T, contact_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_messages
     * const contact_messages = await prisma.contact_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contact_messagesUpdateManyArgs>(args: SelectSubset<T, contact_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_messages.
     * @param {contact_messagesUpsertArgs} args - Arguments to update or create a Contact_messages.
     * @example
     * // Update or create a Contact_messages
     * const contact_messages = await prisma.contact_messages.upsert({
     *   create: {
     *     // ... data to create a Contact_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_messages we want to update
     *   }
     * })
     */
    upsert<T extends contact_messagesUpsertArgs>(args: SelectSubset<T, contact_messagesUpsertArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesCountArgs} args - Arguments to filter Contact_messages to count.
     * @example
     * // Count the number of Contact_messages
     * const count = await prisma.contact_messages.count({
     *   where: {
     *     // ... the filter for the Contact_messages we want to count
     *   }
     * })
    **/
    count<T extends contact_messagesCountArgs>(
      args?: Subset<T, contact_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_messagesAggregateArgs>(args: Subset<T, Contact_messagesAggregateArgs>): Prisma.PrismaPromise<GetContact_messagesAggregateType<T>>

    /**
     * Group by Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contact_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contact_messagesGroupByArgs['orderBy'] }
        : { orderBy?: contact_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contact_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact_messages model
   */
  readonly fields: contact_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contact_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact_messages model
   */
  interface contact_messagesFieldRefs {
    readonly cid: FieldRef<"contact_messages", 'Int'>
    readonly cname: FieldRef<"contact_messages", 'String'>
    readonly cphone: FieldRef<"contact_messages", 'String'>
    readonly cemail: FieldRef<"contact_messages", 'String'>
    readonly csubject: FieldRef<"contact_messages", 'String'>
    readonly cmessage: FieldRef<"contact_messages", 'String'>
    readonly cstatus: FieldRef<"contact_messages", 'String'>
    readonly createdAt: FieldRef<"contact_messages", 'DateTime'>
    readonly updatedAt: FieldRef<"contact_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact_messages findUnique
   */
  export type contact_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages findUniqueOrThrow
   */
  export type contact_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages findFirst
   */
  export type contact_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_messages.
     */
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages findFirstOrThrow
   */
  export type contact_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_messages.
     */
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages findMany
   */
  export type contact_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages create
   */
  export type contact_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * The data needed to create a contact_messages.
     */
    data: XOR<contact_messagesCreateInput, contact_messagesUncheckedCreateInput>
  }

  /**
   * contact_messages createMany
   */
  export type contact_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contact_messages.
     */
    data: contact_messagesCreateManyInput | contact_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact_messages update
   */
  export type contact_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * The data needed to update a contact_messages.
     */
    data: XOR<contact_messagesUpdateInput, contact_messagesUncheckedUpdateInput>
    /**
     * Choose, which contact_messages to update.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages updateMany
   */
  export type contact_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contact_messages.
     */
    data: XOR<contact_messagesUpdateManyMutationInput, contact_messagesUncheckedUpdateManyInput>
    /**
     * Filter which contact_messages to update
     */
    where?: contact_messagesWhereInput
    /**
     * Limit how many contact_messages to update.
     */
    limit?: number
  }

  /**
   * contact_messages upsert
   */
  export type contact_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * The filter to search for the contact_messages to update in case it exists.
     */
    where: contact_messagesWhereUniqueInput
    /**
     * In case the contact_messages found by the `where` argument doesn't exist, create a new contact_messages with this data.
     */
    create: XOR<contact_messagesCreateInput, contact_messagesUncheckedCreateInput>
    /**
     * In case the contact_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contact_messagesUpdateInput, contact_messagesUncheckedUpdateInput>
  }

  /**
   * contact_messages delete
   */
  export type contact_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
    /**
     * Filter which contact_messages to delete.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages deleteMany
   */
  export type contact_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_messages to delete
     */
    where?: contact_messagesWhereInput
    /**
     * Limit how many contact_messages to delete.
     */
    limit?: number
  }

  /**
   * contact_messages without action
   */
  export type contact_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact_messages
     */
    omit?: contact_messagesOmit<ExtArgs> | null
  }


  /**
   * Model meter_numbers
   */

  export type AggregateMeter_numbers = {
    _count: Meter_numbersCountAggregateOutputType | null
    _avg: Meter_numbersAvgAggregateOutputType | null
    _sum: Meter_numbersSumAggregateOutputType | null
    _min: Meter_numbersMinAggregateOutputType | null
    _max: Meter_numbersMaxAggregateOutputType | null
  }

  export type Meter_numbersAvgAggregateOutputType = {
    meter_uuid_id: number | null
  }

  export type Meter_numbersSumAggregateOutputType = {
    meter_uuid_id: number | null
  }

  export type Meter_numbersMinAggregateOutputType = {
    meter_uuid_id: number | null
    meter_type: string | null
    meter_uuid: string | null
    meter_uuid_used: string | null
    meter_assigned: string | null
    createdAt: Date | null
  }

  export type Meter_numbersMaxAggregateOutputType = {
    meter_uuid_id: number | null
    meter_type: string | null
    meter_uuid: string | null
    meter_uuid_used: string | null
    meter_assigned: string | null
    createdAt: Date | null
  }

  export type Meter_numbersCountAggregateOutputType = {
    meter_uuid_id: number
    meter_type: number
    meter_uuid: number
    meter_uuid_used: number
    meter_assigned: number
    createdAt: number
    _all: number
  }


  export type Meter_numbersAvgAggregateInputType = {
    meter_uuid_id?: true
  }

  export type Meter_numbersSumAggregateInputType = {
    meter_uuid_id?: true
  }

  export type Meter_numbersMinAggregateInputType = {
    meter_uuid_id?: true
    meter_type?: true
    meter_uuid?: true
    meter_uuid_used?: true
    meter_assigned?: true
    createdAt?: true
  }

  export type Meter_numbersMaxAggregateInputType = {
    meter_uuid_id?: true
    meter_type?: true
    meter_uuid?: true
    meter_uuid_used?: true
    meter_assigned?: true
    createdAt?: true
  }

  export type Meter_numbersCountAggregateInputType = {
    meter_uuid_id?: true
    meter_type?: true
    meter_uuid?: true
    meter_uuid_used?: true
    meter_assigned?: true
    createdAt?: true
    _all?: true
  }

  export type Meter_numbersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_numbers to aggregate.
     */
    where?: meter_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_numbers to fetch.
     */
    orderBy?: meter_numbersOrderByWithRelationInput | meter_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_numbers
    **/
    _count?: true | Meter_numbersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_numbersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_numbersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_numbersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_numbersMaxAggregateInputType
  }

  export type GetMeter_numbersAggregateType<T extends Meter_numbersAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_numbers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_numbers[P]>
      : GetScalarType<T[P], AggregateMeter_numbers[P]>
  }




  export type meter_numbersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_numbersWhereInput
    orderBy?: meter_numbersOrderByWithAggregationInput | meter_numbersOrderByWithAggregationInput[]
    by: Meter_numbersScalarFieldEnum[] | Meter_numbersScalarFieldEnum
    having?: meter_numbersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_numbersCountAggregateInputType | true
    _avg?: Meter_numbersAvgAggregateInputType
    _sum?: Meter_numbersSumAggregateInputType
    _min?: Meter_numbersMinAggregateInputType
    _max?: Meter_numbersMaxAggregateInputType
  }

  export type Meter_numbersGroupByOutputType = {
    meter_uuid_id: number
    meter_type: string
    meter_uuid: string
    meter_uuid_used: string
    meter_assigned: string
    createdAt: Date
    _count: Meter_numbersCountAggregateOutputType | null
    _avg: Meter_numbersAvgAggregateOutputType | null
    _sum: Meter_numbersSumAggregateOutputType | null
    _min: Meter_numbersMinAggregateOutputType | null
    _max: Meter_numbersMaxAggregateOutputType | null
  }

  type GetMeter_numbersGroupByPayload<T extends meter_numbersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_numbersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_numbersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_numbersGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_numbersGroupByOutputType[P]>
        }
      >
    >


  export type meter_numbersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    meter_uuid_id?: boolean
    meter_type?: boolean
    meter_uuid?: boolean
    meter_uuid_used?: boolean
    meter_assigned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meter_numbers"]>



  export type meter_numbersSelectScalar = {
    meter_uuid_id?: boolean
    meter_type?: boolean
    meter_uuid?: boolean
    meter_uuid_used?: boolean
    meter_assigned?: boolean
    createdAt?: boolean
  }

  export type meter_numbersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"meter_uuid_id" | "meter_type" | "meter_uuid" | "meter_uuid_used" | "meter_assigned" | "createdAt", ExtArgs["result"]["meter_numbers"]>

  export type $meter_numbersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_numbers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      meter_uuid_id: number
      meter_type: string
      meter_uuid: string
      meter_uuid_used: string
      meter_assigned: string
      createdAt: Date
    }, ExtArgs["result"]["meter_numbers"]>
    composites: {}
  }

  type meter_numbersGetPayload<S extends boolean | null | undefined | meter_numbersDefaultArgs> = $Result.GetResult<Prisma.$meter_numbersPayload, S>

  type meter_numbersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meter_numbersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Meter_numbersCountAggregateInputType | true
    }

  export interface meter_numbersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_numbers'], meta: { name: 'meter_numbers' } }
    /**
     * Find zero or one Meter_numbers that matches the filter.
     * @param {meter_numbersFindUniqueArgs} args - Arguments to find a Meter_numbers
     * @example
     * // Get one Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_numbersFindUniqueArgs>(args: SelectSubset<T, meter_numbersFindUniqueArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meter_numbers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meter_numbersFindUniqueOrThrowArgs} args - Arguments to find a Meter_numbers
     * @example
     * // Get one Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_numbersFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_numbersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersFindFirstArgs} args - Arguments to find a Meter_numbers
     * @example
     * // Get one Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_numbersFindFirstArgs>(args?: SelectSubset<T, meter_numbersFindFirstArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meter_numbers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersFindFirstOrThrowArgs} args - Arguments to find a Meter_numbers
     * @example
     * // Get one Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_numbersFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_numbersFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meter_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findMany()
     * 
     * // Get first 10 Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.findMany({ take: 10 })
     * 
     * // Only select the `meter_uuid_id`
     * const meter_numbersWithMeter_uuid_idOnly = await prisma.meter_numbers.findMany({ select: { meter_uuid_id: true } })
     * 
     */
    findMany<T extends meter_numbersFindManyArgs>(args?: SelectSubset<T, meter_numbersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meter_numbers.
     * @param {meter_numbersCreateArgs} args - Arguments to create a Meter_numbers.
     * @example
     * // Create one Meter_numbers
     * const Meter_numbers = await prisma.meter_numbers.create({
     *   data: {
     *     // ... data to create a Meter_numbers
     *   }
     * })
     * 
     */
    create<T extends meter_numbersCreateArgs>(args: SelectSubset<T, meter_numbersCreateArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meter_numbers.
     * @param {meter_numbersCreateManyArgs} args - Arguments to create many Meter_numbers.
     * @example
     * // Create many Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_numbersCreateManyArgs>(args?: SelectSubset<T, meter_numbersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meter_numbers.
     * @param {meter_numbersDeleteArgs} args - Arguments to delete one Meter_numbers.
     * @example
     * // Delete one Meter_numbers
     * const Meter_numbers = await prisma.meter_numbers.delete({
     *   where: {
     *     // ... filter to delete one Meter_numbers
     *   }
     * })
     * 
     */
    delete<T extends meter_numbersDeleteArgs>(args: SelectSubset<T, meter_numbersDeleteArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meter_numbers.
     * @param {meter_numbersUpdateArgs} args - Arguments to update one Meter_numbers.
     * @example
     * // Update one Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_numbersUpdateArgs>(args: SelectSubset<T, meter_numbersUpdateArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meter_numbers.
     * @param {meter_numbersDeleteManyArgs} args - Arguments to filter Meter_numbers to delete.
     * @example
     * // Delete a few Meter_numbers
     * const { count } = await prisma.meter_numbers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_numbersDeleteManyArgs>(args?: SelectSubset<T, meter_numbersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_numbersUpdateManyArgs>(args: SelectSubset<T, meter_numbersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_numbers.
     * @param {meter_numbersUpsertArgs} args - Arguments to update or create a Meter_numbers.
     * @example
     * // Update or create a Meter_numbers
     * const meter_numbers = await prisma.meter_numbers.upsert({
     *   create: {
     *     // ... data to create a Meter_numbers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_numbers we want to update
     *   }
     * })
     */
    upsert<T extends meter_numbersUpsertArgs>(args: SelectSubset<T, meter_numbersUpsertArgs<ExtArgs>>): Prisma__meter_numbersClient<$Result.GetResult<Prisma.$meter_numbersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meter_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersCountArgs} args - Arguments to filter Meter_numbers to count.
     * @example
     * // Count the number of Meter_numbers
     * const count = await prisma.meter_numbers.count({
     *   where: {
     *     // ... the filter for the Meter_numbers we want to count
     *   }
     * })
    **/
    count<T extends meter_numbersCountArgs>(
      args?: Subset<T, meter_numbersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_numbersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_numbersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_numbersAggregateArgs>(args: Subset<T, Meter_numbersAggregateArgs>): Prisma.PrismaPromise<GetMeter_numbersAggregateType<T>>

    /**
     * Group by Meter_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_numbersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_numbersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_numbersGroupByArgs['orderBy'] }
        : { orderBy?: meter_numbersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_numbersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_numbersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_numbers model
   */
  readonly fields: meter_numbersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_numbers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_numbersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_numbers model
   */
  interface meter_numbersFieldRefs {
    readonly meter_uuid_id: FieldRef<"meter_numbers", 'Int'>
    readonly meter_type: FieldRef<"meter_numbers", 'String'>
    readonly meter_uuid: FieldRef<"meter_numbers", 'String'>
    readonly meter_uuid_used: FieldRef<"meter_numbers", 'String'>
    readonly meter_assigned: FieldRef<"meter_numbers", 'String'>
    readonly createdAt: FieldRef<"meter_numbers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meter_numbers findUnique
   */
  export type meter_numbersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter, which meter_numbers to fetch.
     */
    where: meter_numbersWhereUniqueInput
  }

  /**
   * meter_numbers findUniqueOrThrow
   */
  export type meter_numbersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter, which meter_numbers to fetch.
     */
    where: meter_numbersWhereUniqueInput
  }

  /**
   * meter_numbers findFirst
   */
  export type meter_numbersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter, which meter_numbers to fetch.
     */
    where?: meter_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_numbers to fetch.
     */
    orderBy?: meter_numbersOrderByWithRelationInput | meter_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_numbers.
     */
    cursor?: meter_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_numbers.
     */
    distinct?: Meter_numbersScalarFieldEnum | Meter_numbersScalarFieldEnum[]
  }

  /**
   * meter_numbers findFirstOrThrow
   */
  export type meter_numbersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter, which meter_numbers to fetch.
     */
    where?: meter_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_numbers to fetch.
     */
    orderBy?: meter_numbersOrderByWithRelationInput | meter_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_numbers.
     */
    cursor?: meter_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_numbers.
     */
    distinct?: Meter_numbersScalarFieldEnum | Meter_numbersScalarFieldEnum[]
  }

  /**
   * meter_numbers findMany
   */
  export type meter_numbersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter, which meter_numbers to fetch.
     */
    where?: meter_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_numbers to fetch.
     */
    orderBy?: meter_numbersOrderByWithRelationInput | meter_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_numbers.
     */
    cursor?: meter_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_numbers.
     */
    skip?: number
    distinct?: Meter_numbersScalarFieldEnum | Meter_numbersScalarFieldEnum[]
  }

  /**
   * meter_numbers create
   */
  export type meter_numbersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * The data needed to create a meter_numbers.
     */
    data: XOR<meter_numbersCreateInput, meter_numbersUncheckedCreateInput>
  }

  /**
   * meter_numbers createMany
   */
  export type meter_numbersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_numbers.
     */
    data: meter_numbersCreateManyInput | meter_numbersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_numbers update
   */
  export type meter_numbersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * The data needed to update a meter_numbers.
     */
    data: XOR<meter_numbersUpdateInput, meter_numbersUncheckedUpdateInput>
    /**
     * Choose, which meter_numbers to update.
     */
    where: meter_numbersWhereUniqueInput
  }

  /**
   * meter_numbers updateMany
   */
  export type meter_numbersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_numbers.
     */
    data: XOR<meter_numbersUpdateManyMutationInput, meter_numbersUncheckedUpdateManyInput>
    /**
     * Filter which meter_numbers to update
     */
    where?: meter_numbersWhereInput
    /**
     * Limit how many meter_numbers to update.
     */
    limit?: number
  }

  /**
   * meter_numbers upsert
   */
  export type meter_numbersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * The filter to search for the meter_numbers to update in case it exists.
     */
    where: meter_numbersWhereUniqueInput
    /**
     * In case the meter_numbers found by the `where` argument doesn't exist, create a new meter_numbers with this data.
     */
    create: XOR<meter_numbersCreateInput, meter_numbersUncheckedCreateInput>
    /**
     * In case the meter_numbers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_numbersUpdateInput, meter_numbersUncheckedUpdateInput>
  }

  /**
   * meter_numbers delete
   */
  export type meter_numbersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
    /**
     * Filter which meter_numbers to delete.
     */
    where: meter_numbersWhereUniqueInput
  }

  /**
   * meter_numbers deleteMany
   */
  export type meter_numbersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_numbers to delete
     */
    where?: meter_numbersWhereInput
    /**
     * Limit how many meter_numbers to delete.
     */
    limit?: number
  }

  /**
   * meter_numbers without action
   */
  export type meter_numbersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_numbers
     */
    select?: meter_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meter_numbers
     */
    omit?: meter_numbersOmit<ExtArgs> | null
  }


  /**
   * Model driverequests
   */

  export type AggregateDriverequests = {
    _count: DriverequestsCountAggregateOutputType | null
    _avg: DriverequestsAvgAggregateOutputType | null
    _sum: DriverequestsSumAggregateOutputType | null
    _min: DriverequestsMinAggregateOutputType | null
    _max: DriverequestsMaxAggregateOutputType | null
  }

  export type DriverequestsAvgAggregateOutputType = {
    id: number | null
    orderid: number | null
    customerid: number | null
    driverid: number | null
  }

  export type DriverequestsSumAggregateOutputType = {
    id: number | null
    orderid: number | null
    customerid: number | null
    driverid: number | null
  }

  export type DriverequestsMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: number | null
    customerid: number | null
    address: string | null
    driverid: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverequestsMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: number | null
    customerid: number | null
    address: string | null
    driverid: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverequestsCountAggregateOutputType = {
    id: number
    uuid: number
    orderid: number
    customerid: number
    address: number
    driverid: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverequestsAvgAggregateInputType = {
    id?: true
    orderid?: true
    customerid?: true
    driverid?: true
  }

  export type DriverequestsSumAggregateInputType = {
    id?: true
    orderid?: true
    customerid?: true
    driverid?: true
  }

  export type DriverequestsMinAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    customerid?: true
    address?: true
    driverid?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverequestsMaxAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    customerid?: true
    address?: true
    driverid?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverequestsCountAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    customerid?: true
    address?: true
    driverid?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which driverequests to aggregate.
     */
    where?: driverequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driverequests to fetch.
     */
    orderBy?: driverequestsOrderByWithRelationInput | driverequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driverequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driverequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driverequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned driverequests
    **/
    _count?: true | DriverequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverequestsMaxAggregateInputType
  }

  export type GetDriverequestsAggregateType<T extends DriverequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverequests[P]>
      : GetScalarType<T[P], AggregateDriverequests[P]>
  }




  export type driverequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: driverequestsWhereInput
    orderBy?: driverequestsOrderByWithAggregationInput | driverequestsOrderByWithAggregationInput[]
    by: DriverequestsScalarFieldEnum[] | DriverequestsScalarFieldEnum
    having?: driverequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverequestsCountAggregateInputType | true
    _avg?: DriverequestsAvgAggregateInputType
    _sum?: DriverequestsSumAggregateInputType
    _min?: DriverequestsMinAggregateInputType
    _max?: DriverequestsMaxAggregateInputType
  }

  export type DriverequestsGroupByOutputType = {
    id: number
    uuid: string | null
    orderid: number
    customerid: number
    address: string
    driverid: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: DriverequestsCountAggregateOutputType | null
    _avg: DriverequestsAvgAggregateOutputType | null
    _sum: DriverequestsSumAggregateOutputType | null
    _min: DriverequestsMinAggregateOutputType | null
    _max: DriverequestsMaxAggregateOutputType | null
  }

  type GetDriverequestsGroupByPayload<T extends driverequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverequestsGroupByOutputType[P]>
            : GetScalarType<T[P], DriverequestsGroupByOutputType[P]>
        }
      >
    >


  export type driverequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    customerid?: boolean
    address?: boolean
    driverid?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["driverequests"]>



  export type driverequestsSelectScalar = {
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    customerid?: boolean
    address?: boolean
    driverid?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type driverequestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "orderid" | "customerid" | "address" | "driverid" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["driverequests"]>

  export type $driverequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "driverequests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      orderid: number
      customerid: number
      address: string
      driverid: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driverequests"]>
    composites: {}
  }

  type driverequestsGetPayload<S extends boolean | null | undefined | driverequestsDefaultArgs> = $Result.GetResult<Prisma.$driverequestsPayload, S>

  type driverequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<driverequestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverequestsCountAggregateInputType | true
    }

  export interface driverequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['driverequests'], meta: { name: 'driverequests' } }
    /**
     * Find zero or one Driverequests that matches the filter.
     * @param {driverequestsFindUniqueArgs} args - Arguments to find a Driverequests
     * @example
     * // Get one Driverequests
     * const driverequests = await prisma.driverequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends driverequestsFindUniqueArgs>(args: SelectSubset<T, driverequestsFindUniqueArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driverequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {driverequestsFindUniqueOrThrowArgs} args - Arguments to find a Driverequests
     * @example
     * // Get one Driverequests
     * const driverequests = await prisma.driverequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends driverequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, driverequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driverequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsFindFirstArgs} args - Arguments to find a Driverequests
     * @example
     * // Get one Driverequests
     * const driverequests = await prisma.driverequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends driverequestsFindFirstArgs>(args?: SelectSubset<T, driverequestsFindFirstArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driverequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsFindFirstOrThrowArgs} args - Arguments to find a Driverequests
     * @example
     * // Get one Driverequests
     * const driverequests = await prisma.driverequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends driverequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, driverequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Driverequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Driverequests
     * const driverequests = await prisma.driverequests.findMany()
     * 
     * // Get first 10 Driverequests
     * const driverequests = await prisma.driverequests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverequestsWithIdOnly = await prisma.driverequests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends driverequestsFindManyArgs>(args?: SelectSubset<T, driverequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driverequests.
     * @param {driverequestsCreateArgs} args - Arguments to create a Driverequests.
     * @example
     * // Create one Driverequests
     * const Driverequests = await prisma.driverequests.create({
     *   data: {
     *     // ... data to create a Driverequests
     *   }
     * })
     * 
     */
    create<T extends driverequestsCreateArgs>(args: SelectSubset<T, driverequestsCreateArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Driverequests.
     * @param {driverequestsCreateManyArgs} args - Arguments to create many Driverequests.
     * @example
     * // Create many Driverequests
     * const driverequests = await prisma.driverequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends driverequestsCreateManyArgs>(args?: SelectSubset<T, driverequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Driverequests.
     * @param {driverequestsDeleteArgs} args - Arguments to delete one Driverequests.
     * @example
     * // Delete one Driverequests
     * const Driverequests = await prisma.driverequests.delete({
     *   where: {
     *     // ... filter to delete one Driverequests
     *   }
     * })
     * 
     */
    delete<T extends driverequestsDeleteArgs>(args: SelectSubset<T, driverequestsDeleteArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driverequests.
     * @param {driverequestsUpdateArgs} args - Arguments to update one Driverequests.
     * @example
     * // Update one Driverequests
     * const driverequests = await prisma.driverequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends driverequestsUpdateArgs>(args: SelectSubset<T, driverequestsUpdateArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Driverequests.
     * @param {driverequestsDeleteManyArgs} args - Arguments to filter Driverequests to delete.
     * @example
     * // Delete a few Driverequests
     * const { count } = await prisma.driverequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends driverequestsDeleteManyArgs>(args?: SelectSubset<T, driverequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Driverequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Driverequests
     * const driverequests = await prisma.driverequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends driverequestsUpdateManyArgs>(args: SelectSubset<T, driverequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driverequests.
     * @param {driverequestsUpsertArgs} args - Arguments to update or create a Driverequests.
     * @example
     * // Update or create a Driverequests
     * const driverequests = await prisma.driverequests.upsert({
     *   create: {
     *     // ... data to create a Driverequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driverequests we want to update
     *   }
     * })
     */
    upsert<T extends driverequestsUpsertArgs>(args: SelectSubset<T, driverequestsUpsertArgs<ExtArgs>>): Prisma__driverequestsClient<$Result.GetResult<Prisma.$driverequestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Driverequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsCountArgs} args - Arguments to filter Driverequests to count.
     * @example
     * // Count the number of Driverequests
     * const count = await prisma.driverequests.count({
     *   where: {
     *     // ... the filter for the Driverequests we want to count
     *   }
     * })
    **/
    count<T extends driverequestsCountArgs>(
      args?: Subset<T, driverequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driverequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverequestsAggregateArgs>(args: Subset<T, DriverequestsAggregateArgs>): Prisma.PrismaPromise<GetDriverequestsAggregateType<T>>

    /**
     * Group by Driverequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends driverequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: driverequestsGroupByArgs['orderBy'] }
        : { orderBy?: driverequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, driverequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the driverequests model
   */
  readonly fields: driverequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for driverequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__driverequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the driverequests model
   */
  interface driverequestsFieldRefs {
    readonly id: FieldRef<"driverequests", 'Int'>
    readonly uuid: FieldRef<"driverequests", 'String'>
    readonly orderid: FieldRef<"driverequests", 'Int'>
    readonly customerid: FieldRef<"driverequests", 'Int'>
    readonly address: FieldRef<"driverequests", 'String'>
    readonly driverid: FieldRef<"driverequests", 'Int'>
    readonly status: FieldRef<"driverequests", 'String'>
    readonly createdAt: FieldRef<"driverequests", 'DateTime'>
    readonly updatedAt: FieldRef<"driverequests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * driverequests findUnique
   */
  export type driverequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter, which driverequests to fetch.
     */
    where: driverequestsWhereUniqueInput
  }

  /**
   * driverequests findUniqueOrThrow
   */
  export type driverequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter, which driverequests to fetch.
     */
    where: driverequestsWhereUniqueInput
  }

  /**
   * driverequests findFirst
   */
  export type driverequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter, which driverequests to fetch.
     */
    where?: driverequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driverequests to fetch.
     */
    orderBy?: driverequestsOrderByWithRelationInput | driverequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for driverequests.
     */
    cursor?: driverequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driverequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driverequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of driverequests.
     */
    distinct?: DriverequestsScalarFieldEnum | DriverequestsScalarFieldEnum[]
  }

  /**
   * driverequests findFirstOrThrow
   */
  export type driverequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter, which driverequests to fetch.
     */
    where?: driverequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driverequests to fetch.
     */
    orderBy?: driverequestsOrderByWithRelationInput | driverequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for driverequests.
     */
    cursor?: driverequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driverequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driverequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of driverequests.
     */
    distinct?: DriverequestsScalarFieldEnum | DriverequestsScalarFieldEnum[]
  }

  /**
   * driverequests findMany
   */
  export type driverequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter, which driverequests to fetch.
     */
    where?: driverequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of driverequests to fetch.
     */
    orderBy?: driverequestsOrderByWithRelationInput | driverequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing driverequests.
     */
    cursor?: driverequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` driverequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` driverequests.
     */
    skip?: number
    distinct?: DriverequestsScalarFieldEnum | DriverequestsScalarFieldEnum[]
  }

  /**
   * driverequests create
   */
  export type driverequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * The data needed to create a driverequests.
     */
    data: XOR<driverequestsCreateInput, driverequestsUncheckedCreateInput>
  }

  /**
   * driverequests createMany
   */
  export type driverequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many driverequests.
     */
    data: driverequestsCreateManyInput | driverequestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * driverequests update
   */
  export type driverequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * The data needed to update a driverequests.
     */
    data: XOR<driverequestsUpdateInput, driverequestsUncheckedUpdateInput>
    /**
     * Choose, which driverequests to update.
     */
    where: driverequestsWhereUniqueInput
  }

  /**
   * driverequests updateMany
   */
  export type driverequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update driverequests.
     */
    data: XOR<driverequestsUpdateManyMutationInput, driverequestsUncheckedUpdateManyInput>
    /**
     * Filter which driverequests to update
     */
    where?: driverequestsWhereInput
    /**
     * Limit how many driverequests to update.
     */
    limit?: number
  }

  /**
   * driverequests upsert
   */
  export type driverequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * The filter to search for the driverequests to update in case it exists.
     */
    where: driverequestsWhereUniqueInput
    /**
     * In case the driverequests found by the `where` argument doesn't exist, create a new driverequests with this data.
     */
    create: XOR<driverequestsCreateInput, driverequestsUncheckedCreateInput>
    /**
     * In case the driverequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driverequestsUpdateInput, driverequestsUncheckedUpdateInput>
  }

  /**
   * driverequests delete
   */
  export type driverequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
    /**
     * Filter which driverequests to delete.
     */
    where: driverequestsWhereUniqueInput
  }

  /**
   * driverequests deleteMany
   */
  export type driverequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which driverequests to delete
     */
    where?: driverequestsWhereInput
    /**
     * Limit how many driverequests to delete.
     */
    limit?: number
  }

  /**
   * driverequests without action
   */
  export type driverequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the driverequests
     */
    select?: driverequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the driverequests
     */
    omit?: driverequestsOmit<ExtArgs> | null
  }


  /**
   * Model order_table
   */

  export type AggregateOrder_table = {
    _count: Order_tableCountAggregateOutputType | null
    _avg: Order_tableAvgAggregateOutputType | null
    _sum: Order_tableSumAggregateOutputType | null
    _min: Order_tableMinAggregateOutputType | null
    _max: Order_tableMaxAggregateOutputType | null
  }

  export type Order_tableAvgAggregateOutputType = {
    order_id: number | null
    order_total: Decimal | null
    shipping_cost: Decimal | null
    grandtotal: Decimal | null
    gatewayid: number | null
    gwtranxid: number | null
    gwtranxamt: Decimal | null
    gwstatuscode: number | null
    order_stage: number | null
  }

  export type Order_tableSumAggregateOutputType = {
    order_id: number | null
    order_total: Decimal | null
    shipping_cost: Decimal | null
    grandtotal: Decimal | null
    gatewayid: number | null
    gwtranxid: number | null
    gwtranxamt: Decimal | null
    gwstatuscode: number | null
    order_stage: number | null
  }

  export type Order_tableMinAggregateOutputType = {
    order_id: number | null
    order_trans_id: string | null
    username: string | null
    order_date: Date | null
    order_time: Date | null
    status: string | null
    customercomment: string | null
    notes: string | null
    shipping_first_name: string | null
    shipping_last_name: string | null
    shipping_address1: string | null
    shipping_address2: string | null
    shipping_phone: string | null
    shipping_email: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_country: string | null
    order_total: Decimal | null
    delivery_type: string | null
    shipping_cost: Decimal | null
    grandtotal: Decimal | null
    gatewayid: number | null
    gwtranxid: number | null
    gwcustid: string | null
    gwtranxamt: Decimal | null
    gwstatuscode: number | null
    gwstatusmsg: string | null
    o_sesid: string | null
    last_update_by: $Enums.order_table_last_update_by | null
    order_stage: number | null
    shipping_option: string | null
    payment_option: string | null
    payment_status: string | null
  }

  export type Order_tableMaxAggregateOutputType = {
    order_id: number | null
    order_trans_id: string | null
    username: string | null
    order_date: Date | null
    order_time: Date | null
    status: string | null
    customercomment: string | null
    notes: string | null
    shipping_first_name: string | null
    shipping_last_name: string | null
    shipping_address1: string | null
    shipping_address2: string | null
    shipping_phone: string | null
    shipping_email: string | null
    shipping_city: string | null
    shipping_state: string | null
    shipping_country: string | null
    order_total: Decimal | null
    delivery_type: string | null
    shipping_cost: Decimal | null
    grandtotal: Decimal | null
    gatewayid: number | null
    gwtranxid: number | null
    gwcustid: string | null
    gwtranxamt: Decimal | null
    gwstatuscode: number | null
    gwstatusmsg: string | null
    o_sesid: string | null
    last_update_by: $Enums.order_table_last_update_by | null
    order_stage: number | null
    shipping_option: string | null
    payment_option: string | null
    payment_status: string | null
  }

  export type Order_tableCountAggregateOutputType = {
    order_id: number
    order_trans_id: number
    username: number
    order_date: number
    order_time: number
    status: number
    customercomment: number
    notes: number
    shipping_first_name: number
    shipping_last_name: number
    shipping_address1: number
    shipping_address2: number
    shipping_phone: number
    shipping_email: number
    shipping_city: number
    shipping_state: number
    shipping_country: number
    order_total: number
    delivery_type: number
    shipping_cost: number
    grandtotal: number
    gatewayid: number
    gwtranxid: number
    gwcustid: number
    gwtranxamt: number
    gwstatuscode: number
    gwstatusmsg: number
    o_sesid: number
    last_update_by: number
    order_stage: number
    shipping_option: number
    payment_option: number
    payment_status: number
    _all: number
  }


  export type Order_tableAvgAggregateInputType = {
    order_id?: true
    order_total?: true
    shipping_cost?: true
    grandtotal?: true
    gatewayid?: true
    gwtranxid?: true
    gwtranxamt?: true
    gwstatuscode?: true
    order_stage?: true
  }

  export type Order_tableSumAggregateInputType = {
    order_id?: true
    order_total?: true
    shipping_cost?: true
    grandtotal?: true
    gatewayid?: true
    gwtranxid?: true
    gwtranxamt?: true
    gwstatuscode?: true
    order_stage?: true
  }

  export type Order_tableMinAggregateInputType = {
    order_id?: true
    order_trans_id?: true
    username?: true
    order_date?: true
    order_time?: true
    status?: true
    customercomment?: true
    notes?: true
    shipping_first_name?: true
    shipping_last_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    order_total?: true
    delivery_type?: true
    shipping_cost?: true
    grandtotal?: true
    gatewayid?: true
    gwtranxid?: true
    gwcustid?: true
    gwtranxamt?: true
    gwstatuscode?: true
    gwstatusmsg?: true
    o_sesid?: true
    last_update_by?: true
    order_stage?: true
    shipping_option?: true
    payment_option?: true
    payment_status?: true
  }

  export type Order_tableMaxAggregateInputType = {
    order_id?: true
    order_trans_id?: true
    username?: true
    order_date?: true
    order_time?: true
    status?: true
    customercomment?: true
    notes?: true
    shipping_first_name?: true
    shipping_last_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    order_total?: true
    delivery_type?: true
    shipping_cost?: true
    grandtotal?: true
    gatewayid?: true
    gwtranxid?: true
    gwcustid?: true
    gwtranxamt?: true
    gwstatuscode?: true
    gwstatusmsg?: true
    o_sesid?: true
    last_update_by?: true
    order_stage?: true
    shipping_option?: true
    payment_option?: true
    payment_status?: true
  }

  export type Order_tableCountAggregateInputType = {
    order_id?: true
    order_trans_id?: true
    username?: true
    order_date?: true
    order_time?: true
    status?: true
    customercomment?: true
    notes?: true
    shipping_first_name?: true
    shipping_last_name?: true
    shipping_address1?: true
    shipping_address2?: true
    shipping_phone?: true
    shipping_email?: true
    shipping_city?: true
    shipping_state?: true
    shipping_country?: true
    order_total?: true
    delivery_type?: true
    shipping_cost?: true
    grandtotal?: true
    gatewayid?: true
    gwtranxid?: true
    gwcustid?: true
    gwtranxamt?: true
    gwstatuscode?: true
    gwstatusmsg?: true
    o_sesid?: true
    last_update_by?: true
    order_stage?: true
    shipping_option?: true
    payment_option?: true
    payment_status?: true
    _all?: true
  }

  export type Order_tableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_table to aggregate.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_tables
    **/
    _count?: true | Order_tableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_tableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_tableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_tableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_tableMaxAggregateInputType
  }

  export type GetOrder_tableAggregateType<T extends Order_tableAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_table]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_table[P]>
      : GetScalarType<T[P], AggregateOrder_table[P]>
  }




  export type order_tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_tableWhereInput
    orderBy?: order_tableOrderByWithAggregationInput | order_tableOrderByWithAggregationInput[]
    by: Order_tableScalarFieldEnum[] | Order_tableScalarFieldEnum
    having?: order_tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_tableCountAggregateInputType | true
    _avg?: Order_tableAvgAggregateInputType
    _sum?: Order_tableSumAggregateInputType
    _min?: Order_tableMinAggregateInputType
    _max?: Order_tableMaxAggregateInputType
  }

  export type Order_tableGroupByOutputType = {
    order_id: number
    order_trans_id: string
    username: string | null
    order_date: Date | null
    order_time: Date
    status: string
    customercomment: string | null
    notes: string
    shipping_first_name: string
    shipping_last_name: string
    shipping_address1: string
    shipping_address2: string
    shipping_phone: string
    shipping_email: string | null
    shipping_city: string
    shipping_state: string
    shipping_country: string
    order_total: Decimal
    delivery_type: string
    shipping_cost: Decimal
    grandtotal: Decimal
    gatewayid: number
    gwtranxid: number | null
    gwcustid: string | null
    gwtranxamt: Decimal | null
    gwstatuscode: number | null
    gwstatusmsg: string | null
    o_sesid: string
    last_update_by: $Enums.order_table_last_update_by
    order_stage: number
    shipping_option: string
    payment_option: string
    payment_status: string
    _count: Order_tableCountAggregateOutputType | null
    _avg: Order_tableAvgAggregateOutputType | null
    _sum: Order_tableSumAggregateOutputType | null
    _min: Order_tableMinAggregateOutputType | null
    _max: Order_tableMaxAggregateOutputType | null
  }

  type GetOrder_tableGroupByPayload<T extends order_tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_tableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_tableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_tableGroupByOutputType[P]>
            : GetScalarType<T[P], Order_tableGroupByOutputType[P]>
        }
      >
    >


  export type order_tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    order_trans_id?: boolean
    username?: boolean
    order_date?: boolean
    order_time?: boolean
    status?: boolean
    customercomment?: boolean
    notes?: boolean
    shipping_first_name?: boolean
    shipping_last_name?: boolean
    shipping_address1?: boolean
    shipping_address2?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    order_total?: boolean
    delivery_type?: boolean
    shipping_cost?: boolean
    grandtotal?: boolean
    gatewayid?: boolean
    gwtranxid?: boolean
    gwcustid?: boolean
    gwtranxamt?: boolean
    gwstatuscode?: boolean
    gwstatusmsg?: boolean
    o_sesid?: boolean
    last_update_by?: boolean
    order_stage?: boolean
    shipping_option?: boolean
    payment_option?: boolean
    payment_status?: boolean
  }, ExtArgs["result"]["order_table"]>



  export type order_tableSelectScalar = {
    order_id?: boolean
    order_trans_id?: boolean
    username?: boolean
    order_date?: boolean
    order_time?: boolean
    status?: boolean
    customercomment?: boolean
    notes?: boolean
    shipping_first_name?: boolean
    shipping_last_name?: boolean
    shipping_address1?: boolean
    shipping_address2?: boolean
    shipping_phone?: boolean
    shipping_email?: boolean
    shipping_city?: boolean
    shipping_state?: boolean
    shipping_country?: boolean
    order_total?: boolean
    delivery_type?: boolean
    shipping_cost?: boolean
    grandtotal?: boolean
    gatewayid?: boolean
    gwtranxid?: boolean
    gwcustid?: boolean
    gwtranxamt?: boolean
    gwstatuscode?: boolean
    gwstatusmsg?: boolean
    o_sesid?: boolean
    last_update_by?: boolean
    order_stage?: boolean
    shipping_option?: boolean
    payment_option?: boolean
    payment_status?: boolean
  }

  export type order_tableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_id" | "order_trans_id" | "username" | "order_date" | "order_time" | "status" | "customercomment" | "notes" | "shipping_first_name" | "shipping_last_name" | "shipping_address1" | "shipping_address2" | "shipping_phone" | "shipping_email" | "shipping_city" | "shipping_state" | "shipping_country" | "order_total" | "delivery_type" | "shipping_cost" | "grandtotal" | "gatewayid" | "gwtranxid" | "gwcustid" | "gwtranxamt" | "gwstatuscode" | "gwstatusmsg" | "o_sesid" | "last_update_by" | "order_stage" | "shipping_option" | "payment_option" | "payment_status", ExtArgs["result"]["order_table"]>

  export type $order_tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_table"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      order_trans_id: string
      username: string | null
      order_date: Date | null
      order_time: Date
      status: string
      customercomment: string | null
      notes: string
      shipping_first_name: string
      shipping_last_name: string
      shipping_address1: string
      shipping_address2: string
      shipping_phone: string
      shipping_email: string | null
      shipping_city: string
      shipping_state: string
      shipping_country: string
      order_total: Prisma.Decimal
      delivery_type: string
      shipping_cost: Prisma.Decimal
      grandtotal: Prisma.Decimal
      gatewayid: number
      gwtranxid: number | null
      gwcustid: string | null
      gwtranxamt: Prisma.Decimal | null
      gwstatuscode: number | null
      gwstatusmsg: string | null
      o_sesid: string
      last_update_by: $Enums.order_table_last_update_by
      order_stage: number
      shipping_option: string
      payment_option: string
      payment_status: string
    }, ExtArgs["result"]["order_table"]>
    composites: {}
  }

  type order_tableGetPayload<S extends boolean | null | undefined | order_tableDefaultArgs> = $Result.GetResult<Prisma.$order_tablePayload, S>

  type order_tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_tableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_tableCountAggregateInputType | true
    }

  export interface order_tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_table'], meta: { name: 'order_table' } }
    /**
     * Find zero or one Order_table that matches the filter.
     * @param {order_tableFindUniqueArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_tableFindUniqueArgs>(args: SelectSubset<T, order_tableFindUniqueArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_tableFindUniqueOrThrowArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_tableFindUniqueOrThrowArgs>(args: SelectSubset<T, order_tableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindFirstArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_tableFindFirstArgs>(args?: SelectSubset<T, order_tableFindFirstArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindFirstOrThrowArgs} args - Arguments to find a Order_table
     * @example
     * // Get one Order_table
     * const order_table = await prisma.order_table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_tableFindFirstOrThrowArgs>(args?: SelectSubset<T, order_tableFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_tables
     * const order_tables = await prisma.order_table.findMany()
     * 
     * // Get first 10 Order_tables
     * const order_tables = await prisma.order_table.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const order_tableWithOrder_idOnly = await prisma.order_table.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends order_tableFindManyArgs>(args?: SelectSubset<T, order_tableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_table.
     * @param {order_tableCreateArgs} args - Arguments to create a Order_table.
     * @example
     * // Create one Order_table
     * const Order_table = await prisma.order_table.create({
     *   data: {
     *     // ... data to create a Order_table
     *   }
     * })
     * 
     */
    create<T extends order_tableCreateArgs>(args: SelectSubset<T, order_tableCreateArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_tables.
     * @param {order_tableCreateManyArgs} args - Arguments to create many Order_tables.
     * @example
     * // Create many Order_tables
     * const order_table = await prisma.order_table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_tableCreateManyArgs>(args?: SelectSubset<T, order_tableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_table.
     * @param {order_tableDeleteArgs} args - Arguments to delete one Order_table.
     * @example
     * // Delete one Order_table
     * const Order_table = await prisma.order_table.delete({
     *   where: {
     *     // ... filter to delete one Order_table
     *   }
     * })
     * 
     */
    delete<T extends order_tableDeleteArgs>(args: SelectSubset<T, order_tableDeleteArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_table.
     * @param {order_tableUpdateArgs} args - Arguments to update one Order_table.
     * @example
     * // Update one Order_table
     * const order_table = await prisma.order_table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_tableUpdateArgs>(args: SelectSubset<T, order_tableUpdateArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_tables.
     * @param {order_tableDeleteManyArgs} args - Arguments to filter Order_tables to delete.
     * @example
     * // Delete a few Order_tables
     * const { count } = await prisma.order_table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_tableDeleteManyArgs>(args?: SelectSubset<T, order_tableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_tables
     * const order_table = await prisma.order_table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_tableUpdateManyArgs>(args: SelectSubset<T, order_tableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_table.
     * @param {order_tableUpsertArgs} args - Arguments to update or create a Order_table.
     * @example
     * // Update or create a Order_table
     * const order_table = await prisma.order_table.upsert({
     *   create: {
     *     // ... data to create a Order_table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_table we want to update
     *   }
     * })
     */
    upsert<T extends order_tableUpsertArgs>(args: SelectSubset<T, order_tableUpsertArgs<ExtArgs>>): Prisma__order_tableClient<$Result.GetResult<Prisma.$order_tablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableCountArgs} args - Arguments to filter Order_tables to count.
     * @example
     * // Count the number of Order_tables
     * const count = await prisma.order_table.count({
     *   where: {
     *     // ... the filter for the Order_tables we want to count
     *   }
     * })
    **/
    count<T extends order_tableCountArgs>(
      args?: Subset<T, order_tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_tableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_tableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_tableAggregateArgs>(args: Subset<T, Order_tableAggregateArgs>): Prisma.PrismaPromise<GetOrder_tableAggregateType<T>>

    /**
     * Group by Order_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_tableGroupByArgs['orderBy'] }
        : { orderBy?: order_tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_tableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_table model
   */
  readonly fields: order_tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_table model
   */
  interface order_tableFieldRefs {
    readonly order_id: FieldRef<"order_table", 'Int'>
    readonly order_trans_id: FieldRef<"order_table", 'String'>
    readonly username: FieldRef<"order_table", 'String'>
    readonly order_date: FieldRef<"order_table", 'DateTime'>
    readonly order_time: FieldRef<"order_table", 'DateTime'>
    readonly status: FieldRef<"order_table", 'String'>
    readonly customercomment: FieldRef<"order_table", 'String'>
    readonly notes: FieldRef<"order_table", 'String'>
    readonly shipping_first_name: FieldRef<"order_table", 'String'>
    readonly shipping_last_name: FieldRef<"order_table", 'String'>
    readonly shipping_address1: FieldRef<"order_table", 'String'>
    readonly shipping_address2: FieldRef<"order_table", 'String'>
    readonly shipping_phone: FieldRef<"order_table", 'String'>
    readonly shipping_email: FieldRef<"order_table", 'String'>
    readonly shipping_city: FieldRef<"order_table", 'String'>
    readonly shipping_state: FieldRef<"order_table", 'String'>
    readonly shipping_country: FieldRef<"order_table", 'String'>
    readonly order_total: FieldRef<"order_table", 'Decimal'>
    readonly delivery_type: FieldRef<"order_table", 'String'>
    readonly shipping_cost: FieldRef<"order_table", 'Decimal'>
    readonly grandtotal: FieldRef<"order_table", 'Decimal'>
    readonly gatewayid: FieldRef<"order_table", 'Int'>
    readonly gwtranxid: FieldRef<"order_table", 'Int'>
    readonly gwcustid: FieldRef<"order_table", 'String'>
    readonly gwtranxamt: FieldRef<"order_table", 'Decimal'>
    readonly gwstatuscode: FieldRef<"order_table", 'Int'>
    readonly gwstatusmsg: FieldRef<"order_table", 'String'>
    readonly o_sesid: FieldRef<"order_table", 'String'>
    readonly last_update_by: FieldRef<"order_table", 'order_table_last_update_by'>
    readonly order_stage: FieldRef<"order_table", 'Int'>
    readonly shipping_option: FieldRef<"order_table", 'String'>
    readonly payment_option: FieldRef<"order_table", 'String'>
    readonly payment_status: FieldRef<"order_table", 'String'>
  }
    

  // Custom InputTypes
  /**
   * order_table findUnique
   */
  export type order_tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where: order_tableWhereUniqueInput
  }

  /**
   * order_table findUniqueOrThrow
   */
  export type order_tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where: order_tableWhereUniqueInput
  }

  /**
   * order_table findFirst
   */
  export type order_tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_tables.
     */
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }

  /**
   * order_table findFirstOrThrow
   */
  export type order_tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter, which order_table to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_tables.
     */
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }

  /**
   * order_table findMany
   */
  export type order_tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter, which order_tables to fetch.
     */
    where?: order_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_tables to fetch.
     */
    orderBy?: order_tableOrderByWithRelationInput | order_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_tables.
     */
    cursor?: order_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_tables.
     */
    skip?: number
    distinct?: Order_tableScalarFieldEnum | Order_tableScalarFieldEnum[]
  }

  /**
   * order_table create
   */
  export type order_tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * The data needed to create a order_table.
     */
    data: XOR<order_tableCreateInput, order_tableUncheckedCreateInput>
  }

  /**
   * order_table createMany
   */
  export type order_tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_tables.
     */
    data: order_tableCreateManyInput | order_tableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_table update
   */
  export type order_tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * The data needed to update a order_table.
     */
    data: XOR<order_tableUpdateInput, order_tableUncheckedUpdateInput>
    /**
     * Choose, which order_table to update.
     */
    where: order_tableWhereUniqueInput
  }

  /**
   * order_table updateMany
   */
  export type order_tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_tables.
     */
    data: XOR<order_tableUpdateManyMutationInput, order_tableUncheckedUpdateManyInput>
    /**
     * Filter which order_tables to update
     */
    where?: order_tableWhereInput
    /**
     * Limit how many order_tables to update.
     */
    limit?: number
  }

  /**
   * order_table upsert
   */
  export type order_tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * The filter to search for the order_table to update in case it exists.
     */
    where: order_tableWhereUniqueInput
    /**
     * In case the order_table found by the `where` argument doesn't exist, create a new order_table with this data.
     */
    create: XOR<order_tableCreateInput, order_tableUncheckedCreateInput>
    /**
     * In case the order_table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_tableUpdateInput, order_tableUncheckedUpdateInput>
  }

  /**
   * order_table delete
   */
  export type order_tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
    /**
     * Filter which order_table to delete.
     */
    where: order_tableWhereUniqueInput
  }

  /**
   * order_table deleteMany
   */
  export type order_tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_tables to delete
     */
    where?: order_tableWhereInput
    /**
     * Limit how many order_tables to delete.
     */
    limit?: number
  }

  /**
   * order_table without action
   */
  export type order_tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_table
     */
    select?: order_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_table
     */
    omit?: order_tableOmit<ExtArgs> | null
  }


  /**
   * Model packages
   */

  export type AggregatePackages = {
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  export type PackagesAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PackagesSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PackagesMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    sku: string | null
    description: string | null
    picture: string | null
    price: number | null
    size: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackagesMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    sku: string | null
    description: string | null
    picture: string | null
    price: number | null
    size: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackagesCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    sku: number
    description: number
    picture: number
    price: number
    size: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackagesAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type PackagesSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type PackagesMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackagesMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackagesCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    sku?: true
    description?: true
    picture?: true
    price?: true
    size?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to aggregate.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned packages
    **/
    _count?: true | PackagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagesMaxAggregateInputType
  }

  export type GetPackagesAggregateType<T extends PackagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePackages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackages[P]>
      : GetScalarType<T[P], AggregatePackages[P]>
  }




  export type packagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithAggregationInput | packagesOrderByWithAggregationInput[]
    by: PackagesScalarFieldEnum[] | PackagesScalarFieldEnum
    having?: packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagesCountAggregateInputType | true
    _avg?: PackagesAvgAggregateInputType
    _sum?: PackagesSumAggregateInputType
    _min?: PackagesMinAggregateInputType
    _max?: PackagesMaxAggregateInputType
  }

  export type PackagesGroupByOutputType = {
    id: number
    uuid: string | null
    name: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  type GetPackagesGroupByPayload<T extends packagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagesGroupByOutputType[P]>
            : GetScalarType<T[P], PackagesGroupByOutputType[P]>
        }
      >
    >


  export type packagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    sku?: boolean
    description?: boolean
    picture?: boolean
    price?: boolean
    size?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packages"]>



  export type packagesSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    sku?: boolean
    description?: boolean
    picture?: boolean
    price?: boolean
    size?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type packagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "name" | "sku" | "description" | "picture" | "price" | "size" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["packages"]>

  export type $packagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "packages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      name: string
      sku: string
      description: string
      picture: string
      price: number
      size: string
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packages"]>
    composites: {}
  }

  type packagesGetPayload<S extends boolean | null | undefined | packagesDefaultArgs> = $Result.GetResult<Prisma.$packagesPayload, S>

  type packagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<packagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackagesCountAggregateInputType | true
    }

  export interface packagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['packages'], meta: { name: 'packages' } }
    /**
     * Find zero or one Packages that matches the filter.
     * @param {packagesFindUniqueArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends packagesFindUniqueArgs>(args: SelectSubset<T, packagesFindUniqueArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Packages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {packagesFindUniqueOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends packagesFindUniqueOrThrowArgs>(args: SelectSubset<T, packagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends packagesFindFirstArgs>(args?: SelectSubset<T, packagesFindFirstArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends packagesFindFirstOrThrowArgs>(args?: SelectSubset<T, packagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.packages.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.packages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagesWithIdOnly = await prisma.packages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends packagesFindManyArgs>(args?: SelectSubset<T, packagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Packages.
     * @param {packagesCreateArgs} args - Arguments to create a Packages.
     * @example
     * // Create one Packages
     * const Packages = await prisma.packages.create({
     *   data: {
     *     // ... data to create a Packages
     *   }
     * })
     * 
     */
    create<T extends packagesCreateArgs>(args: SelectSubset<T, packagesCreateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {packagesCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const packages = await prisma.packages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends packagesCreateManyArgs>(args?: SelectSubset<T, packagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Packages.
     * @param {packagesDeleteArgs} args - Arguments to delete one Packages.
     * @example
     * // Delete one Packages
     * const Packages = await prisma.packages.delete({
     *   where: {
     *     // ... filter to delete one Packages
     *   }
     * })
     * 
     */
    delete<T extends packagesDeleteArgs>(args: SelectSubset<T, packagesDeleteArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Packages.
     * @param {packagesUpdateArgs} args - Arguments to update one Packages.
     * @example
     * // Update one Packages
     * const packages = await prisma.packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends packagesUpdateArgs>(args: SelectSubset<T, packagesUpdateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {packagesDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends packagesDeleteManyArgs>(args?: SelectSubset<T, packagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends packagesUpdateManyArgs>(args: SelectSubset<T, packagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Packages.
     * @param {packagesUpsertArgs} args - Arguments to update or create a Packages.
     * @example
     * // Update or create a Packages
     * const packages = await prisma.packages.upsert({
     *   create: {
     *     // ... data to create a Packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Packages we want to update
     *   }
     * })
     */
    upsert<T extends packagesUpsertArgs>(args: SelectSubset<T, packagesUpsertArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.packages.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends packagesCountArgs>(
      args?: Subset<T, packagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagesAggregateArgs>(args: Subset<T, PackagesAggregateArgs>): Prisma.PrismaPromise<GetPackagesAggregateType<T>>

    /**
     * Group by Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends packagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: packagesGroupByArgs['orderBy'] }
        : { orderBy?: packagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, packagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the packages model
   */
  readonly fields: packagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__packagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the packages model
   */
  interface packagesFieldRefs {
    readonly id: FieldRef<"packages", 'Int'>
    readonly uuid: FieldRef<"packages", 'String'>
    readonly name: FieldRef<"packages", 'String'>
    readonly sku: FieldRef<"packages", 'String'>
    readonly description: FieldRef<"packages", 'String'>
    readonly picture: FieldRef<"packages", 'String'>
    readonly price: FieldRef<"packages", 'Float'>
    readonly size: FieldRef<"packages", 'String'>
    readonly status: FieldRef<"packages", 'Boolean'>
    readonly createdAt: FieldRef<"packages", 'DateTime'>
    readonly updatedAt: FieldRef<"packages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * packages findUnique
   */
  export type packagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findUniqueOrThrow
   */
  export type packagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findFirst
   */
  export type packagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findFirstOrThrow
   */
  export type packagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findMany
   */
  export type packagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages create
   */
  export type packagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data needed to create a packages.
     */
    data: XOR<packagesCreateInput, packagesUncheckedCreateInput>
  }

  /**
   * packages createMany
   */
  export type packagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many packages.
     */
    data: packagesCreateManyInput | packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * packages update
   */
  export type packagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data needed to update a packages.
     */
    data: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
    /**
     * Choose, which packages to update.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages updateMany
   */
  export type packagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update packages.
     */
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to update.
     */
    limit?: number
  }

  /**
   * packages upsert
   */
  export type packagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The filter to search for the packages to update in case it exists.
     */
    where: packagesWhereUniqueInput
    /**
     * In case the packages found by the `where` argument doesn't exist, create a new packages with this data.
     */
    create: XOR<packagesCreateInput, packagesUncheckedCreateInput>
    /**
     * In case the packages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
  }

  /**
   * packages delete
   */
  export type packagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Filter which packages to delete.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages deleteMany
   */
  export type packagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to delete
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to delete.
     */
    limit?: number
  }

  /**
   * packages without action
   */
  export type packagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
  }


  /**
   * Model ratings
   */

  export type AggregateRatings = {
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  export type RatingsAvgAggregateOutputType = {
    id: number | null
    driverid: number | null
    stars: number | null
    customerid: number | null
  }

  export type RatingsSumAggregateOutputType = {
    id: number | null
    driverid: number | null
    stars: number | null
    customerid: number | null
  }

  export type RatingsMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: string | null
    driverid: number | null
    stars: number | null
    comment: string | null
    customerid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    orderid: string | null
    driverid: number | null
    stars: number | null
    comment: string | null
    customerid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsCountAggregateOutputType = {
    id: number
    uuid: number
    orderid: number
    driverid: number
    stars: number
    comment: number
    customerid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingsAvgAggregateInputType = {
    id?: true
    driverid?: true
    stars?: true
    customerid?: true
  }

  export type RatingsSumAggregateInputType = {
    id?: true
    driverid?: true
    stars?: true
    customerid?: true
  }

  export type RatingsMinAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    driverid?: true
    stars?: true
    comment?: true
    customerid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsMaxAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    driverid?: true
    stars?: true
    comment?: true
    customerid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsCountAggregateInputType = {
    id?: true
    uuid?: true
    orderid?: true
    driverid?: true
    stars?: true
    comment?: true
    customerid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to aggregate.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ratings
    **/
    _count?: true | RatingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingsMaxAggregateInputType
  }

  export type GetRatingsAggregateType<T extends RatingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRatings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRatings[P]>
      : GetScalarType<T[P], AggregateRatings[P]>
  }




  export type ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithAggregationInput | ratingsOrderByWithAggregationInput[]
    by: RatingsScalarFieldEnum[] | RatingsScalarFieldEnum
    having?: ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingsCountAggregateInputType | true
    _avg?: RatingsAvgAggregateInputType
    _sum?: RatingsSumAggregateInputType
    _min?: RatingsMinAggregateInputType
    _max?: RatingsMaxAggregateInputType
  }

  export type RatingsGroupByOutputType = {
    id: number
    uuid: string | null
    orderid: string
    driverid: number
    stars: number
    comment: string
    customerid: number
    createdAt: Date
    updatedAt: Date
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  type GetRatingsGroupByPayload<T extends ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingsGroupByOutputType[P]>
            : GetScalarType<T[P], RatingsGroupByOutputType[P]>
        }
      >
    >


  export type ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    driverid?: boolean
    stars?: boolean
    comment?: boolean
    customerid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ratings"]>



  export type ratingsSelectScalar = {
    id?: boolean
    uuid?: boolean
    orderid?: boolean
    driverid?: boolean
    stars?: boolean
    comment?: boolean
    customerid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ratingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "orderid" | "driverid" | "stars" | "comment" | "customerid" | "createdAt" | "updatedAt", ExtArgs["result"]["ratings"]>

  export type $ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ratings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      orderid: string
      driverid: number
      stars: number
      comment: string
      customerid: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ratings"]>
    composites: {}
  }

  type ratingsGetPayload<S extends boolean | null | undefined | ratingsDefaultArgs> = $Result.GetResult<Prisma.$ratingsPayload, S>

  type ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ratingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingsCountAggregateInputType | true
    }

  export interface ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ratings'], meta: { name: 'ratings' } }
    /**
     * Find zero or one Ratings that matches the filter.
     * @param {ratingsFindUniqueArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ratingsFindUniqueArgs>(args: SelectSubset<T, ratingsFindUniqueArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ratings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ratingsFindUniqueOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ratingsFindFirstArgs>(args?: SelectSubset<T, ratingsFindFirstArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.ratings.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingsWithIdOnly = await prisma.ratings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ratingsFindManyArgs>(args?: SelectSubset<T, ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ratings.
     * @param {ratingsCreateArgs} args - Arguments to create a Ratings.
     * @example
     * // Create one Ratings
     * const Ratings = await prisma.ratings.create({
     *   data: {
     *     // ... data to create a Ratings
     *   }
     * })
     * 
     */
    create<T extends ratingsCreateArgs>(args: SelectSubset<T, ratingsCreateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {ratingsCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const ratings = await prisma.ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ratingsCreateManyArgs>(args?: SelectSubset<T, ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ratings.
     * @param {ratingsDeleteArgs} args - Arguments to delete one Ratings.
     * @example
     * // Delete one Ratings
     * const Ratings = await prisma.ratings.delete({
     *   where: {
     *     // ... filter to delete one Ratings
     *   }
     * })
     * 
     */
    delete<T extends ratingsDeleteArgs>(args: SelectSubset<T, ratingsDeleteArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ratings.
     * @param {ratingsUpdateArgs} args - Arguments to update one Ratings.
     * @example
     * // Update one Ratings
     * const ratings = await prisma.ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ratingsUpdateArgs>(args: SelectSubset<T, ratingsUpdateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {ratingsDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ratingsDeleteManyArgs>(args?: SelectSubset<T, ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const ratings = await prisma.ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ratingsUpdateManyArgs>(args: SelectSubset<T, ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ratings.
     * @param {ratingsUpsertArgs} args - Arguments to update or create a Ratings.
     * @example
     * // Update or create a Ratings
     * const ratings = await prisma.ratings.upsert({
     *   create: {
     *     // ... data to create a Ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ratings we want to update
     *   }
     * })
     */
    upsert<T extends ratingsUpsertArgs>(args: SelectSubset<T, ratingsUpsertArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.ratings.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends ratingsCountArgs>(
      args?: Subset<T, ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingsAggregateArgs>(args: Subset<T, RatingsAggregateArgs>): Prisma.PrismaPromise<GetRatingsAggregateType<T>>

    /**
     * Group by Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ratingsGroupByArgs['orderBy'] }
        : { orderBy?: ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ratings model
   */
  readonly fields: ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ratings model
   */
  interface ratingsFieldRefs {
    readonly id: FieldRef<"ratings", 'Int'>
    readonly uuid: FieldRef<"ratings", 'String'>
    readonly orderid: FieldRef<"ratings", 'String'>
    readonly driverid: FieldRef<"ratings", 'Int'>
    readonly stars: FieldRef<"ratings", 'Int'>
    readonly comment: FieldRef<"ratings", 'String'>
    readonly customerid: FieldRef<"ratings", 'Int'>
    readonly createdAt: FieldRef<"ratings", 'DateTime'>
    readonly updatedAt: FieldRef<"ratings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ratings findUnique
   */
  export type ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findUniqueOrThrow
   */
  export type ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findFirst
   */
  export type ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findFirstOrThrow
   */
  export type ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findMany
   */
  export type ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings create
   */
  export type ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * The data needed to create a ratings.
     */
    data: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
  }

  /**
   * ratings createMany
   */
  export type ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ratings.
     */
    data: ratingsCreateManyInput | ratingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ratings update
   */
  export type ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * The data needed to update a ratings.
     */
    data: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
    /**
     * Choose, which ratings to update.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings updateMany
   */
  export type ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ratings.
     */
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyInput>
    /**
     * Filter which ratings to update
     */
    where?: ratingsWhereInput
    /**
     * Limit how many ratings to update.
     */
    limit?: number
  }

  /**
   * ratings upsert
   */
  export type ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * The filter to search for the ratings to update in case it exists.
     */
    where: ratingsWhereUniqueInput
    /**
     * In case the ratings found by the `where` argument doesn't exist, create a new ratings with this data.
     */
    create: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
    /**
     * In case the ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
  }

  /**
   * ratings delete
   */
  export type ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
    /**
     * Filter which ratings to delete.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings deleteMany
   */
  export type ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to delete
     */
    where?: ratingsWhereInput
    /**
     * Limit how many ratings to delete.
     */
    limit?: number
  }

  /**
   * ratings without action
   */
  export type ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ratings
     */
    omit?: ratingsOmit<ExtArgs> | null
  }


  /**
   * Model usercat
   */

  export type AggregateUsercat = {
    _count: UsercatCountAggregateOutputType | null
    _avg: UsercatAvgAggregateOutputType | null
    _sum: UsercatSumAggregateOutputType | null
    _min: UsercatMinAggregateOutputType | null
    _max: UsercatMaxAggregateOutputType | null
  }

  export type UsercatAvgAggregateOutputType = {
    usercatid: number | null
  }

  export type UsercatSumAggregateOutputType = {
    usercatid: number | null
  }

  export type UsercatMinAggregateOutputType = {
    usercatid: number | null
    usercategory: string | null
    usercatdesc: string | null
  }

  export type UsercatMaxAggregateOutputType = {
    usercatid: number | null
    usercategory: string | null
    usercatdesc: string | null
  }

  export type UsercatCountAggregateOutputType = {
    usercatid: number
    usercategory: number
    usercatdesc: number
    _all: number
  }


  export type UsercatAvgAggregateInputType = {
    usercatid?: true
  }

  export type UsercatSumAggregateInputType = {
    usercatid?: true
  }

  export type UsercatMinAggregateInputType = {
    usercatid?: true
    usercategory?: true
    usercatdesc?: true
  }

  export type UsercatMaxAggregateInputType = {
    usercatid?: true
    usercategory?: true
    usercatdesc?: true
  }

  export type UsercatCountAggregateInputType = {
    usercatid?: true
    usercategory?: true
    usercatdesc?: true
    _all?: true
  }

  export type UsercatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usercat to aggregate.
     */
    where?: usercatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercats to fetch.
     */
    orderBy?: usercatOrderByWithRelationInput | usercatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usercatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usercats
    **/
    _count?: true | UsercatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsercatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsercatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsercatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsercatMaxAggregateInputType
  }

  export type GetUsercatAggregateType<T extends UsercatAggregateArgs> = {
        [P in keyof T & keyof AggregateUsercat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsercat[P]>
      : GetScalarType<T[P], AggregateUsercat[P]>
  }




  export type usercatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usercatWhereInput
    orderBy?: usercatOrderByWithAggregationInput | usercatOrderByWithAggregationInput[]
    by: UsercatScalarFieldEnum[] | UsercatScalarFieldEnum
    having?: usercatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsercatCountAggregateInputType | true
    _avg?: UsercatAvgAggregateInputType
    _sum?: UsercatSumAggregateInputType
    _min?: UsercatMinAggregateInputType
    _max?: UsercatMaxAggregateInputType
  }

  export type UsercatGroupByOutputType = {
    usercatid: number
    usercategory: string
    usercatdesc: string
    _count: UsercatCountAggregateOutputType | null
    _avg: UsercatAvgAggregateOutputType | null
    _sum: UsercatSumAggregateOutputType | null
    _min: UsercatMinAggregateOutputType | null
    _max: UsercatMaxAggregateOutputType | null
  }

  type GetUsercatGroupByPayload<T extends usercatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsercatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsercatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsercatGroupByOutputType[P]>
            : GetScalarType<T[P], UsercatGroupByOutputType[P]>
        }
      >
    >


  export type usercatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usercatid?: boolean
    usercategory?: boolean
    usercatdesc?: boolean
  }, ExtArgs["result"]["usercat"]>



  export type usercatSelectScalar = {
    usercatid?: boolean
    usercategory?: boolean
    usercatdesc?: boolean
  }

  export type usercatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"usercatid" | "usercategory" | "usercatdesc", ExtArgs["result"]["usercat"]>

  export type $usercatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usercat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      usercatid: number
      usercategory: string
      usercatdesc: string
    }, ExtArgs["result"]["usercat"]>
    composites: {}
  }

  type usercatGetPayload<S extends boolean | null | undefined | usercatDefaultArgs> = $Result.GetResult<Prisma.$usercatPayload, S>

  type usercatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usercatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsercatCountAggregateInputType | true
    }

  export interface usercatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usercat'], meta: { name: 'usercat' } }
    /**
     * Find zero or one Usercat that matches the filter.
     * @param {usercatFindUniqueArgs} args - Arguments to find a Usercat
     * @example
     * // Get one Usercat
     * const usercat = await prisma.usercat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usercatFindUniqueArgs>(args: SelectSubset<T, usercatFindUniqueArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usercat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usercatFindUniqueOrThrowArgs} args - Arguments to find a Usercat
     * @example
     * // Get one Usercat
     * const usercat = await prisma.usercat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usercatFindUniqueOrThrowArgs>(args: SelectSubset<T, usercatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usercat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatFindFirstArgs} args - Arguments to find a Usercat
     * @example
     * // Get one Usercat
     * const usercat = await prisma.usercat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usercatFindFirstArgs>(args?: SelectSubset<T, usercatFindFirstArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usercat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatFindFirstOrThrowArgs} args - Arguments to find a Usercat
     * @example
     * // Get one Usercat
     * const usercat = await prisma.usercat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usercatFindFirstOrThrowArgs>(args?: SelectSubset<T, usercatFindFirstOrThrowArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usercats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usercats
     * const usercats = await prisma.usercat.findMany()
     * 
     * // Get first 10 Usercats
     * const usercats = await prisma.usercat.findMany({ take: 10 })
     * 
     * // Only select the `usercatid`
     * const usercatWithUsercatidOnly = await prisma.usercat.findMany({ select: { usercatid: true } })
     * 
     */
    findMany<T extends usercatFindManyArgs>(args?: SelectSubset<T, usercatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usercat.
     * @param {usercatCreateArgs} args - Arguments to create a Usercat.
     * @example
     * // Create one Usercat
     * const Usercat = await prisma.usercat.create({
     *   data: {
     *     // ... data to create a Usercat
     *   }
     * })
     * 
     */
    create<T extends usercatCreateArgs>(args: SelectSubset<T, usercatCreateArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usercats.
     * @param {usercatCreateManyArgs} args - Arguments to create many Usercats.
     * @example
     * // Create many Usercats
     * const usercat = await prisma.usercat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usercatCreateManyArgs>(args?: SelectSubset<T, usercatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usercat.
     * @param {usercatDeleteArgs} args - Arguments to delete one Usercat.
     * @example
     * // Delete one Usercat
     * const Usercat = await prisma.usercat.delete({
     *   where: {
     *     // ... filter to delete one Usercat
     *   }
     * })
     * 
     */
    delete<T extends usercatDeleteArgs>(args: SelectSubset<T, usercatDeleteArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usercat.
     * @param {usercatUpdateArgs} args - Arguments to update one Usercat.
     * @example
     * // Update one Usercat
     * const usercat = await prisma.usercat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usercatUpdateArgs>(args: SelectSubset<T, usercatUpdateArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usercats.
     * @param {usercatDeleteManyArgs} args - Arguments to filter Usercats to delete.
     * @example
     * // Delete a few Usercats
     * const { count } = await prisma.usercat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usercatDeleteManyArgs>(args?: SelectSubset<T, usercatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usercats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usercats
     * const usercat = await prisma.usercat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usercatUpdateManyArgs>(args: SelectSubset<T, usercatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usercat.
     * @param {usercatUpsertArgs} args - Arguments to update or create a Usercat.
     * @example
     * // Update or create a Usercat
     * const usercat = await prisma.usercat.upsert({
     *   create: {
     *     // ... data to create a Usercat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usercat we want to update
     *   }
     * })
     */
    upsert<T extends usercatUpsertArgs>(args: SelectSubset<T, usercatUpsertArgs<ExtArgs>>): Prisma__usercatClient<$Result.GetResult<Prisma.$usercatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usercats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatCountArgs} args - Arguments to filter Usercats to count.
     * @example
     * // Count the number of Usercats
     * const count = await prisma.usercat.count({
     *   where: {
     *     // ... the filter for the Usercats we want to count
     *   }
     * })
    **/
    count<T extends usercatCountArgs>(
      args?: Subset<T, usercatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsercatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usercat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsercatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsercatAggregateArgs>(args: Subset<T, UsercatAggregateArgs>): Prisma.PrismaPromise<GetUsercatAggregateType<T>>

    /**
     * Group by Usercat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usercatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usercatGroupByArgs['orderBy'] }
        : { orderBy?: usercatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usercatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsercatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usercat model
   */
  readonly fields: usercatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usercat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usercatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usercat model
   */
  interface usercatFieldRefs {
    readonly usercatid: FieldRef<"usercat", 'Int'>
    readonly usercategory: FieldRef<"usercat", 'String'>
    readonly usercatdesc: FieldRef<"usercat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usercat findUnique
   */
  export type usercatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter, which usercat to fetch.
     */
    where: usercatWhereUniqueInput
  }

  /**
   * usercat findUniqueOrThrow
   */
  export type usercatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter, which usercat to fetch.
     */
    where: usercatWhereUniqueInput
  }

  /**
   * usercat findFirst
   */
  export type usercatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter, which usercat to fetch.
     */
    where?: usercatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercats to fetch.
     */
    orderBy?: usercatOrderByWithRelationInput | usercatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usercats.
     */
    cursor?: usercatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usercats.
     */
    distinct?: UsercatScalarFieldEnum | UsercatScalarFieldEnum[]
  }

  /**
   * usercat findFirstOrThrow
   */
  export type usercatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter, which usercat to fetch.
     */
    where?: usercatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercats to fetch.
     */
    orderBy?: usercatOrderByWithRelationInput | usercatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usercats.
     */
    cursor?: usercatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usercats.
     */
    distinct?: UsercatScalarFieldEnum | UsercatScalarFieldEnum[]
  }

  /**
   * usercat findMany
   */
  export type usercatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter, which usercats to fetch.
     */
    where?: usercatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercats to fetch.
     */
    orderBy?: usercatOrderByWithRelationInput | usercatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usercats.
     */
    cursor?: usercatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercats.
     */
    skip?: number
    distinct?: UsercatScalarFieldEnum | UsercatScalarFieldEnum[]
  }

  /**
   * usercat create
   */
  export type usercatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * The data needed to create a usercat.
     */
    data: XOR<usercatCreateInput, usercatUncheckedCreateInput>
  }

  /**
   * usercat createMany
   */
  export type usercatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usercats.
     */
    data: usercatCreateManyInput | usercatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usercat update
   */
  export type usercatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * The data needed to update a usercat.
     */
    data: XOR<usercatUpdateInput, usercatUncheckedUpdateInput>
    /**
     * Choose, which usercat to update.
     */
    where: usercatWhereUniqueInput
  }

  /**
   * usercat updateMany
   */
  export type usercatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usercats.
     */
    data: XOR<usercatUpdateManyMutationInput, usercatUncheckedUpdateManyInput>
    /**
     * Filter which usercats to update
     */
    where?: usercatWhereInput
    /**
     * Limit how many usercats to update.
     */
    limit?: number
  }

  /**
   * usercat upsert
   */
  export type usercatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * The filter to search for the usercat to update in case it exists.
     */
    where: usercatWhereUniqueInput
    /**
     * In case the usercat found by the `where` argument doesn't exist, create a new usercat with this data.
     */
    create: XOR<usercatCreateInput, usercatUncheckedCreateInput>
    /**
     * In case the usercat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usercatUpdateInput, usercatUncheckedUpdateInput>
  }

  /**
   * usercat delete
   */
  export type usercatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
    /**
     * Filter which usercat to delete.
     */
    where: usercatWhereUniqueInput
  }

  /**
   * usercat deleteMany
   */
  export type usercatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usercats to delete
     */
    where?: usercatWhereInput
    /**
     * Limit how many usercats to delete.
     */
    limit?: number
  }

  /**
   * usercat without action
   */
  export type usercatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercat
     */
    select?: usercatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercat
     */
    omit?: usercatOmit<ExtArgs> | null
  }


  /**
   * Model complaints_replies
   */

  export type AggregateComplaints_replies = {
    _count: Complaints_repliesCountAggregateOutputType | null
    _avg: Complaints_repliesAvgAggregateOutputType | null
    _sum: Complaints_repliesSumAggregateOutputType | null
    _min: Complaints_repliesMinAggregateOutputType | null
    _max: Complaints_repliesMaxAggregateOutputType | null
  }

  export type Complaints_repliesAvgAggregateOutputType = {
    creplyid: number | null
    complaintid: number | null
  }

  export type Complaints_repliesSumAggregateOutputType = {
    creplyid: number | null
    complaintid: number | null
  }

  export type Complaints_repliesMinAggregateOutputType = {
    creplyid: number | null
    complaintid: number | null
    creplysubject: string | null
    creplyname: string | null
    creplyphone: string | null
    creplymessage: string | null
    createdAt: Date | null
  }

  export type Complaints_repliesMaxAggregateOutputType = {
    creplyid: number | null
    complaintid: number | null
    creplysubject: string | null
    creplyname: string | null
    creplyphone: string | null
    creplymessage: string | null
    createdAt: Date | null
  }

  export type Complaints_repliesCountAggregateOutputType = {
    creplyid: number
    complaintid: number
    creplysubject: number
    creplyname: number
    creplyphone: number
    creplymessage: number
    createdAt: number
    _all: number
  }


  export type Complaints_repliesAvgAggregateInputType = {
    creplyid?: true
    complaintid?: true
  }

  export type Complaints_repliesSumAggregateInputType = {
    creplyid?: true
    complaintid?: true
  }

  export type Complaints_repliesMinAggregateInputType = {
    creplyid?: true
    complaintid?: true
    creplysubject?: true
    creplyname?: true
    creplyphone?: true
    creplymessage?: true
    createdAt?: true
  }

  export type Complaints_repliesMaxAggregateInputType = {
    creplyid?: true
    complaintid?: true
    creplysubject?: true
    creplyname?: true
    creplyphone?: true
    creplymessage?: true
    createdAt?: true
  }

  export type Complaints_repliesCountAggregateInputType = {
    creplyid?: true
    complaintid?: true
    creplysubject?: true
    creplyname?: true
    creplyphone?: true
    creplymessage?: true
    createdAt?: true
    _all?: true
  }

  export type Complaints_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints_replies to aggregate.
     */
    where?: complaints_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints_replies to fetch.
     */
    orderBy?: complaints_repliesOrderByWithRelationInput | complaints_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: complaints_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints_replies
    **/
    _count?: true | Complaints_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Complaints_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Complaints_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Complaints_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Complaints_repliesMaxAggregateInputType
  }

  export type GetComplaints_repliesAggregateType<T extends Complaints_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaints_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaints_replies[P]>
      : GetScalarType<T[P], AggregateComplaints_replies[P]>
  }




  export type complaints_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaints_repliesWhereInput
    orderBy?: complaints_repliesOrderByWithAggregationInput | complaints_repliesOrderByWithAggregationInput[]
    by: Complaints_repliesScalarFieldEnum[] | Complaints_repliesScalarFieldEnum
    having?: complaints_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Complaints_repliesCountAggregateInputType | true
    _avg?: Complaints_repliesAvgAggregateInputType
    _sum?: Complaints_repliesSumAggregateInputType
    _min?: Complaints_repliesMinAggregateInputType
    _max?: Complaints_repliesMaxAggregateInputType
  }

  export type Complaints_repliesGroupByOutputType = {
    creplyid: number
    complaintid: number
    creplysubject: string
    creplyname: string
    creplyphone: string
    creplymessage: string
    createdAt: Date
    _count: Complaints_repliesCountAggregateOutputType | null
    _avg: Complaints_repliesAvgAggregateOutputType | null
    _sum: Complaints_repliesSumAggregateOutputType | null
    _min: Complaints_repliesMinAggregateOutputType | null
    _max: Complaints_repliesMaxAggregateOutputType | null
  }

  type GetComplaints_repliesGroupByPayload<T extends complaints_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Complaints_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Complaints_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Complaints_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Complaints_repliesGroupByOutputType[P]>
        }
      >
    >


  export type complaints_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creplyid?: boolean
    complaintid?: boolean
    creplysubject?: boolean
    creplyname?: boolean
    creplyphone?: boolean
    creplymessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["complaints_replies"]>



  export type complaints_repliesSelectScalar = {
    creplyid?: boolean
    complaintid?: boolean
    creplysubject?: boolean
    creplyname?: boolean
    creplyphone?: boolean
    creplymessage?: boolean
    createdAt?: boolean
  }

  export type complaints_repliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"creplyid" | "complaintid" | "creplysubject" | "creplyname" | "creplyphone" | "creplymessage" | "createdAt", ExtArgs["result"]["complaints_replies"]>

  export type $complaints_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "complaints_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      creplyid: number
      complaintid: number
      creplysubject: string
      creplyname: string
      creplyphone: string
      creplymessage: string
      createdAt: Date
    }, ExtArgs["result"]["complaints_replies"]>
    composites: {}
  }

  type complaints_repliesGetPayload<S extends boolean | null | undefined | complaints_repliesDefaultArgs> = $Result.GetResult<Prisma.$complaints_repliesPayload, S>

  type complaints_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<complaints_repliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Complaints_repliesCountAggregateInputType | true
    }

  export interface complaints_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['complaints_replies'], meta: { name: 'complaints_replies' } }
    /**
     * Find zero or one Complaints_replies that matches the filter.
     * @param {complaints_repliesFindUniqueArgs} args - Arguments to find a Complaints_replies
     * @example
     * // Get one Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends complaints_repliesFindUniqueArgs>(args: SelectSubset<T, complaints_repliesFindUniqueArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaints_replies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {complaints_repliesFindUniqueOrThrowArgs} args - Arguments to find a Complaints_replies
     * @example
     * // Get one Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends complaints_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, complaints_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesFindFirstArgs} args - Arguments to find a Complaints_replies
     * @example
     * // Get one Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends complaints_repliesFindFirstArgs>(args?: SelectSubset<T, complaints_repliesFindFirstArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaints_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesFindFirstOrThrowArgs} args - Arguments to find a Complaints_replies
     * @example
     * // Get one Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends complaints_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, complaints_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findMany()
     * 
     * // Get first 10 Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.findMany({ take: 10 })
     * 
     * // Only select the `creplyid`
     * const complaints_repliesWithCreplyidOnly = await prisma.complaints_replies.findMany({ select: { creplyid: true } })
     * 
     */
    findMany<T extends complaints_repliesFindManyArgs>(args?: SelectSubset<T, complaints_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaints_replies.
     * @param {complaints_repliesCreateArgs} args - Arguments to create a Complaints_replies.
     * @example
     * // Create one Complaints_replies
     * const Complaints_replies = await prisma.complaints_replies.create({
     *   data: {
     *     // ... data to create a Complaints_replies
     *   }
     * })
     * 
     */
    create<T extends complaints_repliesCreateArgs>(args: SelectSubset<T, complaints_repliesCreateArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints_replies.
     * @param {complaints_repliesCreateManyArgs} args - Arguments to create many Complaints_replies.
     * @example
     * // Create many Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends complaints_repliesCreateManyArgs>(args?: SelectSubset<T, complaints_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaints_replies.
     * @param {complaints_repliesDeleteArgs} args - Arguments to delete one Complaints_replies.
     * @example
     * // Delete one Complaints_replies
     * const Complaints_replies = await prisma.complaints_replies.delete({
     *   where: {
     *     // ... filter to delete one Complaints_replies
     *   }
     * })
     * 
     */
    delete<T extends complaints_repliesDeleteArgs>(args: SelectSubset<T, complaints_repliesDeleteArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaints_replies.
     * @param {complaints_repliesUpdateArgs} args - Arguments to update one Complaints_replies.
     * @example
     * // Update one Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends complaints_repliesUpdateArgs>(args: SelectSubset<T, complaints_repliesUpdateArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints_replies.
     * @param {complaints_repliesDeleteManyArgs} args - Arguments to filter Complaints_replies to delete.
     * @example
     * // Delete a few Complaints_replies
     * const { count } = await prisma.complaints_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends complaints_repliesDeleteManyArgs>(args?: SelectSubset<T, complaints_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends complaints_repliesUpdateManyArgs>(args: SelectSubset<T, complaints_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaints_replies.
     * @param {complaints_repliesUpsertArgs} args - Arguments to update or create a Complaints_replies.
     * @example
     * // Update or create a Complaints_replies
     * const complaints_replies = await prisma.complaints_replies.upsert({
     *   create: {
     *     // ... data to create a Complaints_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaints_replies we want to update
     *   }
     * })
     */
    upsert<T extends complaints_repliesUpsertArgs>(args: SelectSubset<T, complaints_repliesUpsertArgs<ExtArgs>>): Prisma__complaints_repliesClient<$Result.GetResult<Prisma.$complaints_repliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesCountArgs} args - Arguments to filter Complaints_replies to count.
     * @example
     * // Count the number of Complaints_replies
     * const count = await prisma.complaints_replies.count({
     *   where: {
     *     // ... the filter for the Complaints_replies we want to count
     *   }
     * })
    **/
    count<T extends complaints_repliesCountArgs>(
      args?: Subset<T, complaints_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Complaints_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaints_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Complaints_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Complaints_repliesAggregateArgs>(args: Subset<T, Complaints_repliesAggregateArgs>): Prisma.PrismaPromise<GetComplaints_repliesAggregateType<T>>

    /**
     * Group by Complaints_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaints_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends complaints_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: complaints_repliesGroupByArgs['orderBy'] }
        : { orderBy?: complaints_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, complaints_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaints_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the complaints_replies model
   */
  readonly fields: complaints_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaints_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__complaints_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the complaints_replies model
   */
  interface complaints_repliesFieldRefs {
    readonly creplyid: FieldRef<"complaints_replies", 'Int'>
    readonly complaintid: FieldRef<"complaints_replies", 'Int'>
    readonly creplysubject: FieldRef<"complaints_replies", 'String'>
    readonly creplyname: FieldRef<"complaints_replies", 'String'>
    readonly creplyphone: FieldRef<"complaints_replies", 'String'>
    readonly creplymessage: FieldRef<"complaints_replies", 'String'>
    readonly createdAt: FieldRef<"complaints_replies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * complaints_replies findUnique
   */
  export type complaints_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter, which complaints_replies to fetch.
     */
    where: complaints_repliesWhereUniqueInput
  }

  /**
   * complaints_replies findUniqueOrThrow
   */
  export type complaints_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter, which complaints_replies to fetch.
     */
    where: complaints_repliesWhereUniqueInput
  }

  /**
   * complaints_replies findFirst
   */
  export type complaints_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter, which complaints_replies to fetch.
     */
    where?: complaints_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints_replies to fetch.
     */
    orderBy?: complaints_repliesOrderByWithRelationInput | complaints_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints_replies.
     */
    cursor?: complaints_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints_replies.
     */
    distinct?: Complaints_repliesScalarFieldEnum | Complaints_repliesScalarFieldEnum[]
  }

  /**
   * complaints_replies findFirstOrThrow
   */
  export type complaints_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter, which complaints_replies to fetch.
     */
    where?: complaints_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints_replies to fetch.
     */
    orderBy?: complaints_repliesOrderByWithRelationInput | complaints_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints_replies.
     */
    cursor?: complaints_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints_replies.
     */
    distinct?: Complaints_repliesScalarFieldEnum | Complaints_repliesScalarFieldEnum[]
  }

  /**
   * complaints_replies findMany
   */
  export type complaints_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter, which complaints_replies to fetch.
     */
    where?: complaints_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints_replies to fetch.
     */
    orderBy?: complaints_repliesOrderByWithRelationInput | complaints_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints_replies.
     */
    cursor?: complaints_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints_replies.
     */
    skip?: number
    distinct?: Complaints_repliesScalarFieldEnum | Complaints_repliesScalarFieldEnum[]
  }

  /**
   * complaints_replies create
   */
  export type complaints_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * The data needed to create a complaints_replies.
     */
    data: XOR<complaints_repliesCreateInput, complaints_repliesUncheckedCreateInput>
  }

  /**
   * complaints_replies createMany
   */
  export type complaints_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many complaints_replies.
     */
    data: complaints_repliesCreateManyInput | complaints_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * complaints_replies update
   */
  export type complaints_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * The data needed to update a complaints_replies.
     */
    data: XOR<complaints_repliesUpdateInput, complaints_repliesUncheckedUpdateInput>
    /**
     * Choose, which complaints_replies to update.
     */
    where: complaints_repliesWhereUniqueInput
  }

  /**
   * complaints_replies updateMany
   */
  export type complaints_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update complaints_replies.
     */
    data: XOR<complaints_repliesUpdateManyMutationInput, complaints_repliesUncheckedUpdateManyInput>
    /**
     * Filter which complaints_replies to update
     */
    where?: complaints_repliesWhereInput
    /**
     * Limit how many complaints_replies to update.
     */
    limit?: number
  }

  /**
   * complaints_replies upsert
   */
  export type complaints_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * The filter to search for the complaints_replies to update in case it exists.
     */
    where: complaints_repliesWhereUniqueInput
    /**
     * In case the complaints_replies found by the `where` argument doesn't exist, create a new complaints_replies with this data.
     */
    create: XOR<complaints_repliesCreateInput, complaints_repliesUncheckedCreateInput>
    /**
     * In case the complaints_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<complaints_repliesUpdateInput, complaints_repliesUncheckedUpdateInput>
  }

  /**
   * complaints_replies delete
   */
  export type complaints_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
    /**
     * Filter which complaints_replies to delete.
     */
    where: complaints_repliesWhereUniqueInput
  }

  /**
   * complaints_replies deleteMany
   */
  export type complaints_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints_replies to delete
     */
    where?: complaints_repliesWhereInput
    /**
     * Limit how many complaints_replies to delete.
     */
    limit?: number
  }

  /**
   * complaints_replies without action
   */
  export type complaints_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaints_replies
     */
    select?: complaints_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaints_replies
     */
    omit?: complaints_repliesOmit<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    subplanid: number | null
    subplanamt: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    subplanid: number | null
    subplanamt: number | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    subplanid: number | null
    subplantype: string | null
    subplanusername: string | null
    subplanamt: number | null
    subplan_from: Date | null
    subplan_to: Date | null
    subplan_status: string | null
    subplan_pay_status: string | null
    subplan_area: string | null
    subplan_admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    subplanid: number | null
    subplantype: string | null
    subplanusername: string | null
    subplanamt: number | null
    subplan_from: Date | null
    subplan_to: Date | null
    subplan_status: string | null
    subplan_pay_status: string | null
    subplan_area: string | null
    subplan_admin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    subplanid: number
    subplantype: number
    subplanusername: number
    subplanamt: number
    subplan_from: number
    subplan_to: number
    subplan_status: number
    subplan_pay_status: number
    subplan_area: number
    subplan_admin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    subplanid?: true
    subplanamt?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    subplanid?: true
    subplanamt?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    subplanid?: true
    subplantype?: true
    subplanusername?: true
    subplanamt?: true
    subplan_from?: true
    subplan_to?: true
    subplan_status?: true
    subplan_pay_status?: true
    subplan_area?: true
    subplan_admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    subplanid?: true
    subplantype?: true
    subplanusername?: true
    subplanamt?: true
    subplan_from?: true
    subplan_to?: true
    subplan_status?: true
    subplan_pay_status?: true
    subplan_area?: true
    subplan_admin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    subplanid?: true
    subplantype?: true
    subplanusername?: true
    subplanamt?: true
    subplan_from?: true
    subplan_to?: true
    subplan_status?: true
    subplan_pay_status?: true
    subplan_area?: true
    subplan_admin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    subplanid: number
    subplantype: string
    subplanusername: string
    subplanamt: number
    subplan_from: Date
    subplan_to: Date
    subplan_status: string
    subplan_pay_status: string
    subplan_area: string
    subplan_admin: string
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subplanid?: boolean
    subplantype?: boolean
    subplanusername?: boolean
    subplanamt?: boolean
    subplan_from?: boolean
    subplan_to?: boolean
    subplan_status?: boolean
    subplan_pay_status?: boolean
    subplan_area?: boolean
    subplan_admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptions"]>



  export type subscriptionsSelectScalar = {
    subplanid?: boolean
    subplantype?: boolean
    subplanusername?: boolean
    subplanamt?: boolean
    subplan_from?: boolean
    subplan_to?: boolean
    subplan_status?: boolean
    subplan_pay_status?: boolean
    subplan_area?: boolean
    subplan_admin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subplanid" | "subplantype" | "subplanusername" | "subplanamt" | "subplan_from" | "subplan_to" | "subplan_status" | "subplan_pay_status" | "subplan_area" | "subplan_admin" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptions"]>

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      subplanid: number
      subplantype: string
      subplanusername: string
      subplanamt: number
      subplan_from: Date
      subplan_to: Date
      subplan_status: string
      subplan_pay_status: string
      subplan_area: string
      subplan_admin: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `subplanid`
     * const subscriptionsWithSubplanidOnly = await prisma.subscriptions.findMany({ select: { subplanid: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly subplanid: FieldRef<"subscriptions", 'Int'>
    readonly subplantype: FieldRef<"subscriptions", 'String'>
    readonly subplanusername: FieldRef<"subscriptions", 'String'>
    readonly subplanamt: FieldRef<"subscriptions", 'Int'>
    readonly subplan_from: FieldRef<"subscriptions", 'DateTime'>
    readonly subplan_to: FieldRef<"subscriptions", 'DateTime'>
    readonly subplan_status: FieldRef<"subscriptions", 'String'>
    readonly subplan_pay_status: FieldRef<"subscriptions", 'String'>
    readonly subplan_area: FieldRef<"subscriptions", 'String'>
    readonly subplan_admin: FieldRef<"subscriptions", 'String'>
    readonly createdAt: FieldRef<"subscriptions", 'DateTime'>
    readonly updatedAt: FieldRef<"subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
  }


  /**
   * Model trucks
   */

  export type AggregateTrucks = {
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  export type TrucksAvgAggregateOutputType = {
    truckid: number | null
    truck_fleetowner: number | null
  }

  export type TrucksSumAggregateOutputType = {
    truckid: number | null
    truck_fleetowner: number | null
  }

  export type TrucksMinAggregateOutputType = {
    truckid: number | null
    truck_make: string | null
    truck_plateno: string | null
    truck_fleetowner: number | null
    truck_meterid: string | null
    truck_driver: string | null
    truck_status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrucksMaxAggregateOutputType = {
    truckid: number | null
    truck_make: string | null
    truck_plateno: string | null
    truck_fleetowner: number | null
    truck_meterid: string | null
    truck_driver: string | null
    truck_status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrucksCountAggregateOutputType = {
    truckid: number
    truck_make: number
    truck_plateno: number
    truck_fleetowner: number
    truck_meterid: number
    truck_driver: number
    truck_status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrucksAvgAggregateInputType = {
    truckid?: true
    truck_fleetowner?: true
  }

  export type TrucksSumAggregateInputType = {
    truckid?: true
    truck_fleetowner?: true
  }

  export type TrucksMinAggregateInputType = {
    truckid?: true
    truck_make?: true
    truck_plateno?: true
    truck_fleetowner?: true
    truck_meterid?: true
    truck_driver?: true
    truck_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrucksMaxAggregateInputType = {
    truckid?: true
    truck_make?: true
    truck_plateno?: true
    truck_fleetowner?: true
    truck_meterid?: true
    truck_driver?: true
    truck_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrucksCountAggregateInputType = {
    truckid?: true
    truck_make?: true
    truck_plateno?: true
    truck_fleetowner?: true
    truck_meterid?: true
    truck_driver?: true
    truck_status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrucksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trucks to aggregate.
     */
    where?: trucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: trucksOrderByWithRelationInput | trucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trucks
    **/
    _count?: true | TrucksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrucksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrucksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrucksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrucksMaxAggregateInputType
  }

  export type GetTrucksAggregateType<T extends TrucksAggregateArgs> = {
        [P in keyof T & keyof AggregateTrucks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrucks[P]>
      : GetScalarType<T[P], AggregateTrucks[P]>
  }




  export type trucksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trucksWhereInput
    orderBy?: trucksOrderByWithAggregationInput | trucksOrderByWithAggregationInput[]
    by: TrucksScalarFieldEnum[] | TrucksScalarFieldEnum
    having?: trucksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrucksCountAggregateInputType | true
    _avg?: TrucksAvgAggregateInputType
    _sum?: TrucksSumAggregateInputType
    _min?: TrucksMinAggregateInputType
    _max?: TrucksMaxAggregateInputType
  }

  export type TrucksGroupByOutputType = {
    truckid: number
    truck_make: string
    truck_plateno: string
    truck_fleetowner: number | null
    truck_meterid: string | null
    truck_driver: string | null
    truck_status: string
    createdAt: Date
    updatedAt: Date
    _count: TrucksCountAggregateOutputType | null
    _avg: TrucksAvgAggregateOutputType | null
    _sum: TrucksSumAggregateOutputType | null
    _min: TrucksMinAggregateOutputType | null
    _max: TrucksMaxAggregateOutputType | null
  }

  type GetTrucksGroupByPayload<T extends trucksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrucksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrucksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrucksGroupByOutputType[P]>
            : GetScalarType<T[P], TrucksGroupByOutputType[P]>
        }
      >
    >


  export type trucksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    truck_make?: boolean
    truck_plateno?: boolean
    truck_fleetowner?: boolean
    truck_meterid?: boolean
    truck_driver?: boolean
    truck_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trucks"]>



  export type trucksSelectScalar = {
    truckid?: boolean
    truck_make?: boolean
    truck_plateno?: boolean
    truck_fleetowner?: boolean
    truck_meterid?: boolean
    truck_driver?: boolean
    truck_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type trucksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"truckid" | "truck_make" | "truck_plateno" | "truck_fleetowner" | "truck_meterid" | "truck_driver" | "truck_status" | "createdAt" | "updatedAt", ExtArgs["result"]["trucks"]>

  export type $trucksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trucks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      truckid: number
      truck_make: string
      truck_plateno: string
      truck_fleetowner: number | null
      truck_meterid: string | null
      truck_driver: string | null
      truck_status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trucks"]>
    composites: {}
  }

  type trucksGetPayload<S extends boolean | null | undefined | trucksDefaultArgs> = $Result.GetResult<Prisma.$trucksPayload, S>

  type trucksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trucksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrucksCountAggregateInputType | true
    }

  export interface trucksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trucks'], meta: { name: 'trucks' } }
    /**
     * Find zero or one Trucks that matches the filter.
     * @param {trucksFindUniqueArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trucksFindUniqueArgs>(args: SelectSubset<T, trucksFindUniqueArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trucks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trucksFindUniqueOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trucksFindUniqueOrThrowArgs>(args: SelectSubset<T, trucksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksFindFirstArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trucksFindFirstArgs>(args?: SelectSubset<T, trucksFindFirstArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trucks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksFindFirstOrThrowArgs} args - Arguments to find a Trucks
     * @example
     * // Get one Trucks
     * const trucks = await prisma.trucks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trucksFindFirstOrThrowArgs>(args?: SelectSubset<T, trucksFindFirstOrThrowArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.trucks.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.trucks.findMany({ take: 10 })
     * 
     * // Only select the `truckid`
     * const trucksWithTruckidOnly = await prisma.trucks.findMany({ select: { truckid: true } })
     * 
     */
    findMany<T extends trucksFindManyArgs>(args?: SelectSubset<T, trucksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trucks.
     * @param {trucksCreateArgs} args - Arguments to create a Trucks.
     * @example
     * // Create one Trucks
     * const Trucks = await prisma.trucks.create({
     *   data: {
     *     // ... data to create a Trucks
     *   }
     * })
     * 
     */
    create<T extends trucksCreateArgs>(args: SelectSubset<T, trucksCreateArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trucks.
     * @param {trucksCreateManyArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const trucks = await prisma.trucks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trucksCreateManyArgs>(args?: SelectSubset<T, trucksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trucks.
     * @param {trucksDeleteArgs} args - Arguments to delete one Trucks.
     * @example
     * // Delete one Trucks
     * const Trucks = await prisma.trucks.delete({
     *   where: {
     *     // ... filter to delete one Trucks
     *   }
     * })
     * 
     */
    delete<T extends trucksDeleteArgs>(args: SelectSubset<T, trucksDeleteArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trucks.
     * @param {trucksUpdateArgs} args - Arguments to update one Trucks.
     * @example
     * // Update one Trucks
     * const trucks = await prisma.trucks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trucksUpdateArgs>(args: SelectSubset<T, trucksUpdateArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trucks.
     * @param {trucksDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.trucks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trucksDeleteManyArgs>(args?: SelectSubset<T, trucksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const trucks = await prisma.trucks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trucksUpdateManyArgs>(args: SelectSubset<T, trucksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trucks.
     * @param {trucksUpsertArgs} args - Arguments to update or create a Trucks.
     * @example
     * // Update or create a Trucks
     * const trucks = await prisma.trucks.upsert({
     *   create: {
     *     // ... data to create a Trucks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trucks we want to update
     *   }
     * })
     */
    upsert<T extends trucksUpsertArgs>(args: SelectSubset<T, trucksUpsertArgs<ExtArgs>>): Prisma__trucksClient<$Result.GetResult<Prisma.$trucksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.trucks.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends trucksCountArgs>(
      args?: Subset<T, trucksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrucksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrucksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrucksAggregateArgs>(args: Subset<T, TrucksAggregateArgs>): Prisma.PrismaPromise<GetTrucksAggregateType<T>>

    /**
     * Group by Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trucksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trucksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trucksGroupByArgs['orderBy'] }
        : { orderBy?: trucksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trucksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrucksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trucks model
   */
  readonly fields: trucksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trucks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trucksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trucks model
   */
  interface trucksFieldRefs {
    readonly truckid: FieldRef<"trucks", 'Int'>
    readonly truck_make: FieldRef<"trucks", 'String'>
    readonly truck_plateno: FieldRef<"trucks", 'String'>
    readonly truck_fleetowner: FieldRef<"trucks", 'Int'>
    readonly truck_meterid: FieldRef<"trucks", 'String'>
    readonly truck_driver: FieldRef<"trucks", 'String'>
    readonly truck_status: FieldRef<"trucks", 'String'>
    readonly createdAt: FieldRef<"trucks", 'DateTime'>
    readonly updatedAt: FieldRef<"trucks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trucks findUnique
   */
  export type trucksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where: trucksWhereUniqueInput
  }

  /**
   * trucks findUniqueOrThrow
   */
  export type trucksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where: trucksWhereUniqueInput
  }

  /**
   * trucks findFirst
   */
  export type trucksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where?: trucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: trucksOrderByWithRelationInput | trucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: trucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * trucks findFirstOrThrow
   */
  export type trucksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where?: trucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: trucksOrderByWithRelationInput | trucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: trucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * trucks findMany
   */
  export type trucksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where?: trucksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: trucksOrderByWithRelationInput | trucksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trucks.
     */
    cursor?: trucksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    distinct?: TrucksScalarFieldEnum | TrucksScalarFieldEnum[]
  }

  /**
   * trucks create
   */
  export type trucksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * The data needed to create a trucks.
     */
    data: XOR<trucksCreateInput, trucksUncheckedCreateInput>
  }

  /**
   * trucks createMany
   */
  export type trucksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trucks.
     */
    data: trucksCreateManyInput | trucksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trucks update
   */
  export type trucksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * The data needed to update a trucks.
     */
    data: XOR<trucksUpdateInput, trucksUncheckedUpdateInput>
    /**
     * Choose, which trucks to update.
     */
    where: trucksWhereUniqueInput
  }

  /**
   * trucks updateMany
   */
  export type trucksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trucks.
     */
    data: XOR<trucksUpdateManyMutationInput, trucksUncheckedUpdateManyInput>
    /**
     * Filter which trucks to update
     */
    where?: trucksWhereInput
    /**
     * Limit how many trucks to update.
     */
    limit?: number
  }

  /**
   * trucks upsert
   */
  export type trucksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * The filter to search for the trucks to update in case it exists.
     */
    where: trucksWhereUniqueInput
    /**
     * In case the trucks found by the `where` argument doesn't exist, create a new trucks with this data.
     */
    create: XOR<trucksCreateInput, trucksUncheckedCreateInput>
    /**
     * In case the trucks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trucksUpdateInput, trucksUncheckedUpdateInput>
  }

  /**
   * trucks delete
   */
  export type trucksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
    /**
     * Filter which trucks to delete.
     */
    where: trucksWhereUniqueInput
  }

  /**
   * trucks deleteMany
   */
  export type trucksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trucks to delete
     */
    where?: trucksWhereInput
    /**
     * Limit how many trucks to delete.
     */
    limit?: number
  }

  /**
   * trucks without action
   */
  export type trucksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trucks
     */
    select?: trucksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trucks
     */
    omit?: trucksOmit<ExtArgs> | null
  }


  /**
   * Model area_groups
   */

  export type AggregateArea_groups = {
    _count: Area_groupsCountAggregateOutputType | null
    _avg: Area_groupsAvgAggregateOutputType | null
    _sum: Area_groupsSumAggregateOutputType | null
    _min: Area_groupsMinAggregateOutputType | null
    _max: Area_groupsMaxAggregateOutputType | null
  }

  export type Area_groupsAvgAggregateOutputType = {
    agid: number | null
  }

  export type Area_groupsSumAggregateOutputType = {
    agid: number | null
  }

  export type Area_groupsMinAggregateOutputType = {
    agid: number | null
    agname: string | null
    agareas: string | null
  }

  export type Area_groupsMaxAggregateOutputType = {
    agid: number | null
    agname: string | null
    agareas: string | null
  }

  export type Area_groupsCountAggregateOutputType = {
    agid: number
    agname: number
    agareas: number
    _all: number
  }


  export type Area_groupsAvgAggregateInputType = {
    agid?: true
  }

  export type Area_groupsSumAggregateInputType = {
    agid?: true
  }

  export type Area_groupsMinAggregateInputType = {
    agid?: true
    agname?: true
    agareas?: true
  }

  export type Area_groupsMaxAggregateInputType = {
    agid?: true
    agname?: true
    agareas?: true
  }

  export type Area_groupsCountAggregateInputType = {
    agid?: true
    agname?: true
    agareas?: true
    _all?: true
  }

  export type Area_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which area_groups to aggregate.
     */
    where?: area_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_groups to fetch.
     */
    orderBy?: area_groupsOrderByWithRelationInput | area_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: area_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned area_groups
    **/
    _count?: true | Area_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Area_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Area_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Area_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Area_groupsMaxAggregateInputType
  }

  export type GetArea_groupsAggregateType<T extends Area_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateArea_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea_groups[P]>
      : GetScalarType<T[P], AggregateArea_groups[P]>
  }




  export type area_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: area_groupsWhereInput
    orderBy?: area_groupsOrderByWithAggregationInput | area_groupsOrderByWithAggregationInput[]
    by: Area_groupsScalarFieldEnum[] | Area_groupsScalarFieldEnum
    having?: area_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Area_groupsCountAggregateInputType | true
    _avg?: Area_groupsAvgAggregateInputType
    _sum?: Area_groupsSumAggregateInputType
    _min?: Area_groupsMinAggregateInputType
    _max?: Area_groupsMaxAggregateInputType
  }

  export type Area_groupsGroupByOutputType = {
    agid: number
    agname: string
    agareas: string
    _count: Area_groupsCountAggregateOutputType | null
    _avg: Area_groupsAvgAggregateOutputType | null
    _sum: Area_groupsSumAggregateOutputType | null
    _min: Area_groupsMinAggregateOutputType | null
    _max: Area_groupsMaxAggregateOutputType | null
  }

  type GetArea_groupsGroupByPayload<T extends area_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Area_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Area_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Area_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Area_groupsGroupByOutputType[P]>
        }
      >
    >


  export type area_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agid?: boolean
    agname?: boolean
    agareas?: boolean
  }, ExtArgs["result"]["area_groups"]>



  export type area_groupsSelectScalar = {
    agid?: boolean
    agname?: boolean
    agareas?: boolean
  }

  export type area_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"agid" | "agname" | "agareas", ExtArgs["result"]["area_groups"]>

  export type $area_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "area_groups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      agid: number
      agname: string
      agareas: string
    }, ExtArgs["result"]["area_groups"]>
    composites: {}
  }

  type area_groupsGetPayload<S extends boolean | null | undefined | area_groupsDefaultArgs> = $Result.GetResult<Prisma.$area_groupsPayload, S>

  type area_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<area_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Area_groupsCountAggregateInputType | true
    }

  export interface area_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['area_groups'], meta: { name: 'area_groups' } }
    /**
     * Find zero or one Area_groups that matches the filter.
     * @param {area_groupsFindUniqueArgs} args - Arguments to find a Area_groups
     * @example
     * // Get one Area_groups
     * const area_groups = await prisma.area_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends area_groupsFindUniqueArgs>(args: SelectSubset<T, area_groupsFindUniqueArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {area_groupsFindUniqueOrThrowArgs} args - Arguments to find a Area_groups
     * @example
     * // Get one Area_groups
     * const area_groups = await prisma.area_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends area_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, area_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsFindFirstArgs} args - Arguments to find a Area_groups
     * @example
     * // Get one Area_groups
     * const area_groups = await prisma.area_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends area_groupsFindFirstArgs>(args?: SelectSubset<T, area_groupsFindFirstArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsFindFirstOrThrowArgs} args - Arguments to find a Area_groups
     * @example
     * // Get one Area_groups
     * const area_groups = await prisma.area_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends area_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, area_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Area_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Area_groups
     * const area_groups = await prisma.area_groups.findMany()
     * 
     * // Get first 10 Area_groups
     * const area_groups = await prisma.area_groups.findMany({ take: 10 })
     * 
     * // Only select the `agid`
     * const area_groupsWithAgidOnly = await prisma.area_groups.findMany({ select: { agid: true } })
     * 
     */
    findMany<T extends area_groupsFindManyArgs>(args?: SelectSubset<T, area_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area_groups.
     * @param {area_groupsCreateArgs} args - Arguments to create a Area_groups.
     * @example
     * // Create one Area_groups
     * const Area_groups = await prisma.area_groups.create({
     *   data: {
     *     // ... data to create a Area_groups
     *   }
     * })
     * 
     */
    create<T extends area_groupsCreateArgs>(args: SelectSubset<T, area_groupsCreateArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Area_groups.
     * @param {area_groupsCreateManyArgs} args - Arguments to create many Area_groups.
     * @example
     * // Create many Area_groups
     * const area_groups = await prisma.area_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends area_groupsCreateManyArgs>(args?: SelectSubset<T, area_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Area_groups.
     * @param {area_groupsDeleteArgs} args - Arguments to delete one Area_groups.
     * @example
     * // Delete one Area_groups
     * const Area_groups = await prisma.area_groups.delete({
     *   where: {
     *     // ... filter to delete one Area_groups
     *   }
     * })
     * 
     */
    delete<T extends area_groupsDeleteArgs>(args: SelectSubset<T, area_groupsDeleteArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area_groups.
     * @param {area_groupsUpdateArgs} args - Arguments to update one Area_groups.
     * @example
     * // Update one Area_groups
     * const area_groups = await prisma.area_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends area_groupsUpdateArgs>(args: SelectSubset<T, area_groupsUpdateArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Area_groups.
     * @param {area_groupsDeleteManyArgs} args - Arguments to filter Area_groups to delete.
     * @example
     * // Delete a few Area_groups
     * const { count } = await prisma.area_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends area_groupsDeleteManyArgs>(args?: SelectSubset<T, area_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Area_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Area_groups
     * const area_groups = await prisma.area_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends area_groupsUpdateManyArgs>(args: SelectSubset<T, area_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area_groups.
     * @param {area_groupsUpsertArgs} args - Arguments to update or create a Area_groups.
     * @example
     * // Update or create a Area_groups
     * const area_groups = await prisma.area_groups.upsert({
     *   create: {
     *     // ... data to create a Area_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area_groups we want to update
     *   }
     * })
     */
    upsert<T extends area_groupsUpsertArgs>(args: SelectSubset<T, area_groupsUpsertArgs<ExtArgs>>): Prisma__area_groupsClient<$Result.GetResult<Prisma.$area_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Area_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsCountArgs} args - Arguments to filter Area_groups to count.
     * @example
     * // Count the number of Area_groups
     * const count = await prisma.area_groups.count({
     *   where: {
     *     // ... the filter for the Area_groups we want to count
     *   }
     * })
    **/
    count<T extends area_groupsCountArgs>(
      args?: Subset<T, area_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Area_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Area_groupsAggregateArgs>(args: Subset<T, Area_groupsAggregateArgs>): Prisma.PrismaPromise<GetArea_groupsAggregateType<T>>

    /**
     * Group by Area_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {area_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends area_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: area_groupsGroupByArgs['orderBy'] }
        : { orderBy?: area_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, area_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArea_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the area_groups model
   */
  readonly fields: area_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for area_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__area_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the area_groups model
   */
  interface area_groupsFieldRefs {
    readonly agid: FieldRef<"area_groups", 'Int'>
    readonly agname: FieldRef<"area_groups", 'String'>
    readonly agareas: FieldRef<"area_groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * area_groups findUnique
   */
  export type area_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter, which area_groups to fetch.
     */
    where: area_groupsWhereUniqueInput
  }

  /**
   * area_groups findUniqueOrThrow
   */
  export type area_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter, which area_groups to fetch.
     */
    where: area_groupsWhereUniqueInput
  }

  /**
   * area_groups findFirst
   */
  export type area_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter, which area_groups to fetch.
     */
    where?: area_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_groups to fetch.
     */
    orderBy?: area_groupsOrderByWithRelationInput | area_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for area_groups.
     */
    cursor?: area_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of area_groups.
     */
    distinct?: Area_groupsScalarFieldEnum | Area_groupsScalarFieldEnum[]
  }

  /**
   * area_groups findFirstOrThrow
   */
  export type area_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter, which area_groups to fetch.
     */
    where?: area_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_groups to fetch.
     */
    orderBy?: area_groupsOrderByWithRelationInput | area_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for area_groups.
     */
    cursor?: area_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of area_groups.
     */
    distinct?: Area_groupsScalarFieldEnum | Area_groupsScalarFieldEnum[]
  }

  /**
   * area_groups findMany
   */
  export type area_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter, which area_groups to fetch.
     */
    where?: area_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of area_groups to fetch.
     */
    orderBy?: area_groupsOrderByWithRelationInput | area_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing area_groups.
     */
    cursor?: area_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` area_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` area_groups.
     */
    skip?: number
    distinct?: Area_groupsScalarFieldEnum | Area_groupsScalarFieldEnum[]
  }

  /**
   * area_groups create
   */
  export type area_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a area_groups.
     */
    data: XOR<area_groupsCreateInput, area_groupsUncheckedCreateInput>
  }

  /**
   * area_groups createMany
   */
  export type area_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many area_groups.
     */
    data: area_groupsCreateManyInput | area_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * area_groups update
   */
  export type area_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a area_groups.
     */
    data: XOR<area_groupsUpdateInput, area_groupsUncheckedUpdateInput>
    /**
     * Choose, which area_groups to update.
     */
    where: area_groupsWhereUniqueInput
  }

  /**
   * area_groups updateMany
   */
  export type area_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update area_groups.
     */
    data: XOR<area_groupsUpdateManyMutationInput, area_groupsUncheckedUpdateManyInput>
    /**
     * Filter which area_groups to update
     */
    where?: area_groupsWhereInput
    /**
     * Limit how many area_groups to update.
     */
    limit?: number
  }

  /**
   * area_groups upsert
   */
  export type area_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the area_groups to update in case it exists.
     */
    where: area_groupsWhereUniqueInput
    /**
     * In case the area_groups found by the `where` argument doesn't exist, create a new area_groups with this data.
     */
    create: XOR<area_groupsCreateInput, area_groupsUncheckedCreateInput>
    /**
     * In case the area_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<area_groupsUpdateInput, area_groupsUncheckedUpdateInput>
  }

  /**
   * area_groups delete
   */
  export type area_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
    /**
     * Filter which area_groups to delete.
     */
    where: area_groupsWhereUniqueInput
  }

  /**
   * area_groups deleteMany
   */
  export type area_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which area_groups to delete
     */
    where?: area_groupsWhereInput
    /**
     * Limit how many area_groups to delete.
     */
    limit?: number
  }

  /**
   * area_groups without action
   */
  export type area_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the area_groups
     */
    select?: area_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the area_groups
     */
    omit?: area_groupsOmit<ExtArgs> | null
  }


  /**
   * Model product_prices_areas
   */

  export type AggregateProduct_prices_areas = {
    _count: Product_prices_areasCountAggregateOutputType | null
    _avg: Product_prices_areasAvgAggregateOutputType | null
    _sum: Product_prices_areasSumAggregateOutputType | null
    _min: Product_prices_areasMinAggregateOutputType | null
    _max: Product_prices_areasMaxAggregateOutputType | null
  }

  export type Product_prices_areasAvgAggregateOutputType = {
    ppid: number | null
    ppa_pid: number | null
    pp_rate: number | null
  }

  export type Product_prices_areasSumAggregateOutputType = {
    ppid: number | null
    ppa_pid: number | null
    pp_rate: number | null
  }

  export type Product_prices_areasMinAggregateOutputType = {
    ppid: number | null
    ppa_pid: number | null
    pparea: string | null
    pp_subscription: string | null
    pp_rate: number | null
  }

  export type Product_prices_areasMaxAggregateOutputType = {
    ppid: number | null
    ppa_pid: number | null
    pparea: string | null
    pp_subscription: string | null
    pp_rate: number | null
  }

  export type Product_prices_areasCountAggregateOutputType = {
    ppid: number
    ppa_pid: number
    pparea: number
    pp_subscription: number
    pp_rate: number
    _all: number
  }


  export type Product_prices_areasAvgAggregateInputType = {
    ppid?: true
    ppa_pid?: true
    pp_rate?: true
  }

  export type Product_prices_areasSumAggregateInputType = {
    ppid?: true
    ppa_pid?: true
    pp_rate?: true
  }

  export type Product_prices_areasMinAggregateInputType = {
    ppid?: true
    ppa_pid?: true
    pparea?: true
    pp_subscription?: true
    pp_rate?: true
  }

  export type Product_prices_areasMaxAggregateInputType = {
    ppid?: true
    ppa_pid?: true
    pparea?: true
    pp_subscription?: true
    pp_rate?: true
  }

  export type Product_prices_areasCountAggregateInputType = {
    ppid?: true
    ppa_pid?: true
    pparea?: true
    pp_subscription?: true
    pp_rate?: true
    _all?: true
  }

  export type Product_prices_areasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_prices_areas to aggregate.
     */
    where?: product_prices_areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices_areas to fetch.
     */
    orderBy?: product_prices_areasOrderByWithRelationInput | product_prices_areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_prices_areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_prices_areas
    **/
    _count?: true | Product_prices_areasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_prices_areasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_prices_areasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_prices_areasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_prices_areasMaxAggregateInputType
  }

  export type GetProduct_prices_areasAggregateType<T extends Product_prices_areasAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_prices_areas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_prices_areas[P]>
      : GetScalarType<T[P], AggregateProduct_prices_areas[P]>
  }




  export type product_prices_areasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_prices_areasWhereInput
    orderBy?: product_prices_areasOrderByWithAggregationInput | product_prices_areasOrderByWithAggregationInput[]
    by: Product_prices_areasScalarFieldEnum[] | Product_prices_areasScalarFieldEnum
    having?: product_prices_areasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_prices_areasCountAggregateInputType | true
    _avg?: Product_prices_areasAvgAggregateInputType
    _sum?: Product_prices_areasSumAggregateInputType
    _min?: Product_prices_areasMinAggregateInputType
    _max?: Product_prices_areasMaxAggregateInputType
  }

  export type Product_prices_areasGroupByOutputType = {
    ppid: number
    ppa_pid: number
    pparea: string
    pp_subscription: string
    pp_rate: number
    _count: Product_prices_areasCountAggregateOutputType | null
    _avg: Product_prices_areasAvgAggregateOutputType | null
    _sum: Product_prices_areasSumAggregateOutputType | null
    _min: Product_prices_areasMinAggregateOutputType | null
    _max: Product_prices_areasMaxAggregateOutputType | null
  }

  type GetProduct_prices_areasGroupByPayload<T extends product_prices_areasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_prices_areasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_prices_areasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_prices_areasGroupByOutputType[P]>
            : GetScalarType<T[P], Product_prices_areasGroupByOutputType[P]>
        }
      >
    >


  export type product_prices_areasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ppid?: boolean
    ppa_pid?: boolean
    pparea?: boolean
    pp_subscription?: boolean
    pp_rate?: boolean
  }, ExtArgs["result"]["product_prices_areas"]>



  export type product_prices_areasSelectScalar = {
    ppid?: boolean
    ppa_pid?: boolean
    pparea?: boolean
    pp_subscription?: boolean
    pp_rate?: boolean
  }

  export type product_prices_areasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ppid" | "ppa_pid" | "pparea" | "pp_subscription" | "pp_rate", ExtArgs["result"]["product_prices_areas"]>

  export type $product_prices_areasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_prices_areas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ppid: number
      ppa_pid: number
      pparea: string
      pp_subscription: string
      pp_rate: number
    }, ExtArgs["result"]["product_prices_areas"]>
    composites: {}
  }

  type product_prices_areasGetPayload<S extends boolean | null | undefined | product_prices_areasDefaultArgs> = $Result.GetResult<Prisma.$product_prices_areasPayload, S>

  type product_prices_areasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<product_prices_areasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Product_prices_areasCountAggregateInputType | true
    }

  export interface product_prices_areasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_prices_areas'], meta: { name: 'product_prices_areas' } }
    /**
     * Find zero or one Product_prices_areas that matches the filter.
     * @param {product_prices_areasFindUniqueArgs} args - Arguments to find a Product_prices_areas
     * @example
     * // Get one Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends product_prices_areasFindUniqueArgs>(args: SelectSubset<T, product_prices_areasFindUniqueArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product_prices_areas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {product_prices_areasFindUniqueOrThrowArgs} args - Arguments to find a Product_prices_areas
     * @example
     * // Get one Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends product_prices_areasFindUniqueOrThrowArgs>(args: SelectSubset<T, product_prices_areasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_prices_areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasFindFirstArgs} args - Arguments to find a Product_prices_areas
     * @example
     * // Get one Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends product_prices_areasFindFirstArgs>(args?: SelectSubset<T, product_prices_areasFindFirstArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_prices_areas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasFindFirstOrThrowArgs} args - Arguments to find a Product_prices_areas
     * @example
     * // Get one Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends product_prices_areasFindFirstOrThrowArgs>(args?: SelectSubset<T, product_prices_areasFindFirstOrThrowArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Product_prices_areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findMany()
     * 
     * // Get first 10 Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.findMany({ take: 10 })
     * 
     * // Only select the `ppid`
     * const product_prices_areasWithPpidOnly = await prisma.product_prices_areas.findMany({ select: { ppid: true } })
     * 
     */
    findMany<T extends product_prices_areasFindManyArgs>(args?: SelectSubset<T, product_prices_areasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product_prices_areas.
     * @param {product_prices_areasCreateArgs} args - Arguments to create a Product_prices_areas.
     * @example
     * // Create one Product_prices_areas
     * const Product_prices_areas = await prisma.product_prices_areas.create({
     *   data: {
     *     // ... data to create a Product_prices_areas
     *   }
     * })
     * 
     */
    create<T extends product_prices_areasCreateArgs>(args: SelectSubset<T, product_prices_areasCreateArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Product_prices_areas.
     * @param {product_prices_areasCreateManyArgs} args - Arguments to create many Product_prices_areas.
     * @example
     * // Create many Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends product_prices_areasCreateManyArgs>(args?: SelectSubset<T, product_prices_areasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_prices_areas.
     * @param {product_prices_areasDeleteArgs} args - Arguments to delete one Product_prices_areas.
     * @example
     * // Delete one Product_prices_areas
     * const Product_prices_areas = await prisma.product_prices_areas.delete({
     *   where: {
     *     // ... filter to delete one Product_prices_areas
     *   }
     * })
     * 
     */
    delete<T extends product_prices_areasDeleteArgs>(args: SelectSubset<T, product_prices_areasDeleteArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product_prices_areas.
     * @param {product_prices_areasUpdateArgs} args - Arguments to update one Product_prices_areas.
     * @example
     * // Update one Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends product_prices_areasUpdateArgs>(args: SelectSubset<T, product_prices_areasUpdateArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Product_prices_areas.
     * @param {product_prices_areasDeleteManyArgs} args - Arguments to filter Product_prices_areas to delete.
     * @example
     * // Delete a few Product_prices_areas
     * const { count } = await prisma.product_prices_areas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends product_prices_areasDeleteManyArgs>(args?: SelectSubset<T, product_prices_areasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_prices_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends product_prices_areasUpdateManyArgs>(args: SelectSubset<T, product_prices_areasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_prices_areas.
     * @param {product_prices_areasUpsertArgs} args - Arguments to update or create a Product_prices_areas.
     * @example
     * // Update or create a Product_prices_areas
     * const product_prices_areas = await prisma.product_prices_areas.upsert({
     *   create: {
     *     // ... data to create a Product_prices_areas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_prices_areas we want to update
     *   }
     * })
     */
    upsert<T extends product_prices_areasUpsertArgs>(args: SelectSubset<T, product_prices_areasUpsertArgs<ExtArgs>>): Prisma__product_prices_areasClient<$Result.GetResult<Prisma.$product_prices_areasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Product_prices_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasCountArgs} args - Arguments to filter Product_prices_areas to count.
     * @example
     * // Count the number of Product_prices_areas
     * const count = await prisma.product_prices_areas.count({
     *   where: {
     *     // ... the filter for the Product_prices_areas we want to count
     *   }
     * })
    **/
    count<T extends product_prices_areasCountArgs>(
      args?: Subset<T, product_prices_areasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_prices_areasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_prices_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_prices_areasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_prices_areasAggregateArgs>(args: Subset<T, Product_prices_areasAggregateArgs>): Prisma.PrismaPromise<GetProduct_prices_areasAggregateType<T>>

    /**
     * Group by Product_prices_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_prices_areasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_prices_areasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_prices_areasGroupByArgs['orderBy'] }
        : { orderBy?: product_prices_areasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_prices_areasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_prices_areasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_prices_areas model
   */
  readonly fields: product_prices_areasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_prices_areas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_prices_areasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product_prices_areas model
   */
  interface product_prices_areasFieldRefs {
    readonly ppid: FieldRef<"product_prices_areas", 'Int'>
    readonly ppa_pid: FieldRef<"product_prices_areas", 'Int'>
    readonly pparea: FieldRef<"product_prices_areas", 'String'>
    readonly pp_subscription: FieldRef<"product_prices_areas", 'String'>
    readonly pp_rate: FieldRef<"product_prices_areas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * product_prices_areas findUnique
   */
  export type product_prices_areasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter, which product_prices_areas to fetch.
     */
    where: product_prices_areasWhereUniqueInput
  }

  /**
   * product_prices_areas findUniqueOrThrow
   */
  export type product_prices_areasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter, which product_prices_areas to fetch.
     */
    where: product_prices_areasWhereUniqueInput
  }

  /**
   * product_prices_areas findFirst
   */
  export type product_prices_areasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter, which product_prices_areas to fetch.
     */
    where?: product_prices_areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices_areas to fetch.
     */
    orderBy?: product_prices_areasOrderByWithRelationInput | product_prices_areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_prices_areas.
     */
    cursor?: product_prices_areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_prices_areas.
     */
    distinct?: Product_prices_areasScalarFieldEnum | Product_prices_areasScalarFieldEnum[]
  }

  /**
   * product_prices_areas findFirstOrThrow
   */
  export type product_prices_areasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter, which product_prices_areas to fetch.
     */
    where?: product_prices_areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices_areas to fetch.
     */
    orderBy?: product_prices_areasOrderByWithRelationInput | product_prices_areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_prices_areas.
     */
    cursor?: product_prices_areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_prices_areas.
     */
    distinct?: Product_prices_areasScalarFieldEnum | Product_prices_areasScalarFieldEnum[]
  }

  /**
   * product_prices_areas findMany
   */
  export type product_prices_areasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter, which product_prices_areas to fetch.
     */
    where?: product_prices_areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_prices_areas to fetch.
     */
    orderBy?: product_prices_areasOrderByWithRelationInput | product_prices_areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_prices_areas.
     */
    cursor?: product_prices_areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_prices_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_prices_areas.
     */
    skip?: number
    distinct?: Product_prices_areasScalarFieldEnum | Product_prices_areasScalarFieldEnum[]
  }

  /**
   * product_prices_areas create
   */
  export type product_prices_areasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * The data needed to create a product_prices_areas.
     */
    data: XOR<product_prices_areasCreateInput, product_prices_areasUncheckedCreateInput>
  }

  /**
   * product_prices_areas createMany
   */
  export type product_prices_areasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_prices_areas.
     */
    data: product_prices_areasCreateManyInput | product_prices_areasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product_prices_areas update
   */
  export type product_prices_areasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * The data needed to update a product_prices_areas.
     */
    data: XOR<product_prices_areasUpdateInput, product_prices_areasUncheckedUpdateInput>
    /**
     * Choose, which product_prices_areas to update.
     */
    where: product_prices_areasWhereUniqueInput
  }

  /**
   * product_prices_areas updateMany
   */
  export type product_prices_areasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_prices_areas.
     */
    data: XOR<product_prices_areasUpdateManyMutationInput, product_prices_areasUncheckedUpdateManyInput>
    /**
     * Filter which product_prices_areas to update
     */
    where?: product_prices_areasWhereInput
    /**
     * Limit how many product_prices_areas to update.
     */
    limit?: number
  }

  /**
   * product_prices_areas upsert
   */
  export type product_prices_areasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * The filter to search for the product_prices_areas to update in case it exists.
     */
    where: product_prices_areasWhereUniqueInput
    /**
     * In case the product_prices_areas found by the `where` argument doesn't exist, create a new product_prices_areas with this data.
     */
    create: XOR<product_prices_areasCreateInput, product_prices_areasUncheckedCreateInput>
    /**
     * In case the product_prices_areas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_prices_areasUpdateInput, product_prices_areasUncheckedUpdateInput>
  }

  /**
   * product_prices_areas delete
   */
  export type product_prices_areasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
    /**
     * Filter which product_prices_areas to delete.
     */
    where: product_prices_areasWhereUniqueInput
  }

  /**
   * product_prices_areas deleteMany
   */
  export type product_prices_areasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_prices_areas to delete
     */
    where?: product_prices_areasWhereInput
    /**
     * Limit how many product_prices_areas to delete.
     */
    limit?: number
  }

  /**
   * product_prices_areas without action
   */
  export type product_prices_areasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_prices_areas
     */
    select?: product_prices_areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_prices_areas
     */
    omit?: product_prices_areasOmit<ExtArgs> | null
  }


  /**
   * Model articles
   */

  export type AggregateArticles = {
    _count: ArticlesCountAggregateOutputType | null
    _avg: ArticlesAvgAggregateOutputType | null
    _sum: ArticlesSumAggregateOutputType | null
    _min: ArticlesMinAggregateOutputType | null
    _max: ArticlesMaxAggregateOutputType | null
  }

  export type ArticlesAvgAggregateOutputType = {
    artid: number | null
    views: number | null
  }

  export type ArticlesSumAggregateOutputType = {
    artid: number | null
    views: number | null
  }

  export type ArticlesMinAggregateOutputType = {
    artid: number | null
    artcategory: string | null
    title: string | null
    titleslug: string | null
    fullcontent: string | null
    mkeys: string | null
    mdesc: string | null
    artsource: string | null
    artsource_url: string | null
    artphoto: string | null
    artphotocaption: string | null
    artphotourl: string | null
    author: string | null
    artstatus: string | null
    views: number | null
    published_date: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticlesMaxAggregateOutputType = {
    artid: number | null
    artcategory: string | null
    title: string | null
    titleslug: string | null
    fullcontent: string | null
    mkeys: string | null
    mdesc: string | null
    artsource: string | null
    artsource_url: string | null
    artphoto: string | null
    artphotocaption: string | null
    artphotourl: string | null
    author: string | null
    artstatus: string | null
    views: number | null
    published_date: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticlesCountAggregateOutputType = {
    artid: number
    artcategory: number
    title: number
    titleslug: number
    fullcontent: number
    mkeys: number
    mdesc: number
    artsource: number
    artsource_url: number
    artphoto: number
    artphotocaption: number
    artphotourl: number
    author: number
    artstatus: number
    views: number
    published_date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticlesAvgAggregateInputType = {
    artid?: true
    views?: true
  }

  export type ArticlesSumAggregateInputType = {
    artid?: true
    views?: true
  }

  export type ArticlesMinAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    fullcontent?: true
    mkeys?: true
    mdesc?: true
    artsource?: true
    artsource_url?: true
    artphoto?: true
    artphotocaption?: true
    artphotourl?: true
    author?: true
    artstatus?: true
    views?: true
    published_date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticlesMaxAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    fullcontent?: true
    mkeys?: true
    mdesc?: true
    artsource?: true
    artsource_url?: true
    artphoto?: true
    artphotocaption?: true
    artphotourl?: true
    author?: true
    artstatus?: true
    views?: true
    published_date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticlesCountAggregateInputType = {
    artid?: true
    artcategory?: true
    title?: true
    titleslug?: true
    fullcontent?: true
    mkeys?: true
    mdesc?: true
    artsource?: true
    artsource_url?: true
    artphoto?: true
    artphotocaption?: true
    artphotourl?: true
    author?: true
    artstatus?: true
    views?: true
    published_date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articles to aggregate.
     */
    where?: articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articlesOrderByWithRelationInput | articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned articles
    **/
    _count?: true | ArticlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticlesMaxAggregateInputType
  }

  export type GetArticlesAggregateType<T extends ArticlesAggregateArgs> = {
        [P in keyof T & keyof AggregateArticles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticles[P]>
      : GetScalarType<T[P], AggregateArticles[P]>
  }




  export type articlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articlesWhereInput
    orderBy?: articlesOrderByWithAggregationInput | articlesOrderByWithAggregationInput[]
    by: ArticlesScalarFieldEnum[] | ArticlesScalarFieldEnum
    having?: articlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticlesCountAggregateInputType | true
    _avg?: ArticlesAvgAggregateInputType
    _sum?: ArticlesSumAggregateInputType
    _min?: ArticlesMinAggregateInputType
    _max?: ArticlesMaxAggregateInputType
  }

  export type ArticlesGroupByOutputType = {
    artid: number
    artcategory: string
    title: string
    titleslug: string
    fullcontent: string
    mkeys: string
    mdesc: string
    artsource: string | null
    artsource_url: string | null
    artphoto: string | null
    artphotocaption: string
    artphotourl: string | null
    author: string | null
    artstatus: string
    views: number
    published_date: string
    createdAt: Date
    updatedAt: Date
    _count: ArticlesCountAggregateOutputType | null
    _avg: ArticlesAvgAggregateOutputType | null
    _sum: ArticlesSumAggregateOutputType | null
    _min: ArticlesMinAggregateOutputType | null
    _max: ArticlesMaxAggregateOutputType | null
  }

  type GetArticlesGroupByPayload<T extends articlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticlesGroupByOutputType[P]>
            : GetScalarType<T[P], ArticlesGroupByOutputType[P]>
        }
      >
    >


  export type articlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artid?: boolean
    artcategory?: boolean
    title?: boolean
    titleslug?: boolean
    fullcontent?: boolean
    mkeys?: boolean
    mdesc?: boolean
    artsource?: boolean
    artsource_url?: boolean
    artphoto?: boolean
    artphotocaption?: boolean
    artphotourl?: boolean
    author?: boolean
    artstatus?: boolean
    views?: boolean
    published_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["articles"]>



  export type articlesSelectScalar = {
    artid?: boolean
    artcategory?: boolean
    title?: boolean
    titleslug?: boolean
    fullcontent?: boolean
    mkeys?: boolean
    mdesc?: boolean
    artsource?: boolean
    artsource_url?: boolean
    artphoto?: boolean
    artphotocaption?: boolean
    artphotourl?: boolean
    author?: boolean
    artstatus?: boolean
    views?: boolean
    published_date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type articlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"artid" | "artcategory" | "title" | "titleslug" | "fullcontent" | "mkeys" | "mdesc" | "artsource" | "artsource_url" | "artphoto" | "artphotocaption" | "artphotourl" | "author" | "artstatus" | "views" | "published_date" | "createdAt" | "updatedAt", ExtArgs["result"]["articles"]>

  export type $articlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "articles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      artid: number
      artcategory: string
      title: string
      titleslug: string
      fullcontent: string
      mkeys: string
      mdesc: string
      artsource: string | null
      artsource_url: string | null
      artphoto: string | null
      artphotocaption: string
      artphotourl: string | null
      author: string | null
      artstatus: string
      views: number
      published_date: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["articles"]>
    composites: {}
  }

  type articlesGetPayload<S extends boolean | null | undefined | articlesDefaultArgs> = $Result.GetResult<Prisma.$articlesPayload, S>

  type articlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<articlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticlesCountAggregateInputType | true
    }

  export interface articlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['articles'], meta: { name: 'articles' } }
    /**
     * Find zero or one Articles that matches the filter.
     * @param {articlesFindUniqueArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends articlesFindUniqueArgs>(args: SelectSubset<T, articlesFindUniqueArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Articles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {articlesFindUniqueOrThrowArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends articlesFindUniqueOrThrowArgs>(args: SelectSubset<T, articlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesFindFirstArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends articlesFindFirstArgs>(args?: SelectSubset<T, articlesFindFirstArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Articles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesFindFirstOrThrowArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends articlesFindFirstOrThrowArgs>(args?: SelectSubset<T, articlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.articles.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.articles.findMany({ take: 10 })
     * 
     * // Only select the `artid`
     * const articlesWithArtidOnly = await prisma.articles.findMany({ select: { artid: true } })
     * 
     */
    findMany<T extends articlesFindManyArgs>(args?: SelectSubset<T, articlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Articles.
     * @param {articlesCreateArgs} args - Arguments to create a Articles.
     * @example
     * // Create one Articles
     * const Articles = await prisma.articles.create({
     *   data: {
     *     // ... data to create a Articles
     *   }
     * })
     * 
     */
    create<T extends articlesCreateArgs>(args: SelectSubset<T, articlesCreateArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Articles.
     * @param {articlesCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const articles = await prisma.articles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends articlesCreateManyArgs>(args?: SelectSubset<T, articlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Articles.
     * @param {articlesDeleteArgs} args - Arguments to delete one Articles.
     * @example
     * // Delete one Articles
     * const Articles = await prisma.articles.delete({
     *   where: {
     *     // ... filter to delete one Articles
     *   }
     * })
     * 
     */
    delete<T extends articlesDeleteArgs>(args: SelectSubset<T, articlesDeleteArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Articles.
     * @param {articlesUpdateArgs} args - Arguments to update one Articles.
     * @example
     * // Update one Articles
     * const articles = await prisma.articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends articlesUpdateArgs>(args: SelectSubset<T, articlesUpdateArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Articles.
     * @param {articlesDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends articlesDeleteManyArgs>(args?: SelectSubset<T, articlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const articles = await prisma.articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends articlesUpdateManyArgs>(args: SelectSubset<T, articlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Articles.
     * @param {articlesUpsertArgs} args - Arguments to update or create a Articles.
     * @example
     * // Update or create a Articles
     * const articles = await prisma.articles.upsert({
     *   create: {
     *     // ... data to create a Articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Articles we want to update
     *   }
     * })
     */
    upsert<T extends articlesUpsertArgs>(args: SelectSubset<T, articlesUpsertArgs<ExtArgs>>): Prisma__articlesClient<$Result.GetResult<Prisma.$articlesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.articles.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends articlesCountArgs>(
      args?: Subset<T, articlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticlesAggregateArgs>(args: Subset<T, ArticlesAggregateArgs>): Prisma.PrismaPromise<GetArticlesAggregateType<T>>

    /**
     * Group by Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends articlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: articlesGroupByArgs['orderBy'] }
        : { orderBy?: articlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, articlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the articles model
   */
  readonly fields: articlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__articlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the articles model
   */
  interface articlesFieldRefs {
    readonly artid: FieldRef<"articles", 'Int'>
    readonly artcategory: FieldRef<"articles", 'String'>
    readonly title: FieldRef<"articles", 'String'>
    readonly titleslug: FieldRef<"articles", 'String'>
    readonly fullcontent: FieldRef<"articles", 'String'>
    readonly mkeys: FieldRef<"articles", 'String'>
    readonly mdesc: FieldRef<"articles", 'String'>
    readonly artsource: FieldRef<"articles", 'String'>
    readonly artsource_url: FieldRef<"articles", 'String'>
    readonly artphoto: FieldRef<"articles", 'String'>
    readonly artphotocaption: FieldRef<"articles", 'String'>
    readonly artphotourl: FieldRef<"articles", 'String'>
    readonly author: FieldRef<"articles", 'String'>
    readonly artstatus: FieldRef<"articles", 'String'>
    readonly views: FieldRef<"articles", 'Int'>
    readonly published_date: FieldRef<"articles", 'String'>
    readonly createdAt: FieldRef<"articles", 'DateTime'>
    readonly updatedAt: FieldRef<"articles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * articles findUnique
   */
  export type articlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where: articlesWhereUniqueInput
  }

  /**
   * articles findUniqueOrThrow
   */
  export type articlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where: articlesWhereUniqueInput
  }

  /**
   * articles findFirst
   */
  export type articlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where?: articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articlesOrderByWithRelationInput | articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articles.
     */
    cursor?: articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articles.
     */
    distinct?: ArticlesScalarFieldEnum | ArticlesScalarFieldEnum[]
  }

  /**
   * articles findFirstOrThrow
   */
  export type articlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where?: articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articlesOrderByWithRelationInput | articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articles.
     */
    cursor?: articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articles.
     */
    distinct?: ArticlesScalarFieldEnum | ArticlesScalarFieldEnum[]
  }

  /**
   * articles findMany
   */
  export type articlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where?: articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articlesOrderByWithRelationInput | articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing articles.
     */
    cursor?: articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    distinct?: ArticlesScalarFieldEnum | ArticlesScalarFieldEnum[]
  }

  /**
   * articles create
   */
  export type articlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * The data needed to create a articles.
     */
    data: XOR<articlesCreateInput, articlesUncheckedCreateInput>
  }

  /**
   * articles createMany
   */
  export type articlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many articles.
     */
    data: articlesCreateManyInput | articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * articles update
   */
  export type articlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * The data needed to update a articles.
     */
    data: XOR<articlesUpdateInput, articlesUncheckedUpdateInput>
    /**
     * Choose, which articles to update.
     */
    where: articlesWhereUniqueInput
  }

  /**
   * articles updateMany
   */
  export type articlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update articles.
     */
    data: XOR<articlesUpdateManyMutationInput, articlesUncheckedUpdateManyInput>
    /**
     * Filter which articles to update
     */
    where?: articlesWhereInput
    /**
     * Limit how many articles to update.
     */
    limit?: number
  }

  /**
   * articles upsert
   */
  export type articlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * The filter to search for the articles to update in case it exists.
     */
    where: articlesWhereUniqueInput
    /**
     * In case the articles found by the `where` argument doesn't exist, create a new articles with this data.
     */
    create: XOR<articlesCreateInput, articlesUncheckedCreateInput>
    /**
     * In case the articles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<articlesUpdateInput, articlesUncheckedUpdateInput>
  }

  /**
   * articles delete
   */
  export type articlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
    /**
     * Filter which articles to delete.
     */
    where: articlesWhereUniqueInput
  }

  /**
   * articles deleteMany
   */
  export type articlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articles to delete
     */
    where?: articlesWhereInput
    /**
     * Limit how many articles to delete.
     */
    limit?: number
  }

  /**
   * articles without action
   */
  export type articlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articles
     */
    select?: articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the articles
     */
    omit?: articlesOmit<ExtArgs> | null
  }


  /**
   * Model subscription_plans
   */

  export type AggregateSubscription_plans = {
    _count: Subscription_plansCountAggregateOutputType | null
    _avg: Subscription_plansAvgAggregateOutputType | null
    _sum: Subscription_plansSumAggregateOutputType | null
    _min: Subscription_plansMinAggregateOutputType | null
    _max: Subscription_plansMaxAggregateOutputType | null
  }

  export type Subscription_plansAvgAggregateOutputType = {
    subplanid: number | null
    subplan_amount: number | null
  }

  export type Subscription_plansSumAggregateOutputType = {
    subplanid: number | null
    subplan_amount: number | null
  }

  export type Subscription_plansMinAggregateOutputType = {
    subplanid: number | null
    subplan_cat: string | null
    subplan: string | null
    subplan_amount: number | null
    subplan_months: string | null
    subplan_include: string | null
    subplan_exclude: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Subscription_plansMaxAggregateOutputType = {
    subplanid: number | null
    subplan_cat: string | null
    subplan: string | null
    subplan_amount: number | null
    subplan_months: string | null
    subplan_include: string | null
    subplan_exclude: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Subscription_plansCountAggregateOutputType = {
    subplanid: number
    subplan_cat: number
    subplan: number
    subplan_amount: number
    subplan_months: number
    subplan_include: number
    subplan_exclude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Subscription_plansAvgAggregateInputType = {
    subplanid?: true
    subplan_amount?: true
  }

  export type Subscription_plansSumAggregateInputType = {
    subplanid?: true
    subplan_amount?: true
  }

  export type Subscription_plansMinAggregateInputType = {
    subplanid?: true
    subplan_cat?: true
    subplan?: true
    subplan_amount?: true
    subplan_months?: true
    subplan_include?: true
    subplan_exclude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Subscription_plansMaxAggregateInputType = {
    subplanid?: true
    subplan_cat?: true
    subplan?: true
    subplan_amount?: true
    subplan_months?: true
    subplan_include?: true
    subplan_exclude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Subscription_plansCountAggregateInputType = {
    subplanid?: true
    subplan_cat?: true
    subplan?: true
    subplan_amount?: true
    subplan_months?: true
    subplan_include?: true
    subplan_exclude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Subscription_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription_plans to aggregate.
     */
    where?: subscription_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscription_plans to fetch.
     */
    orderBy?: subscription_plansOrderByWithRelationInput | subscription_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscription_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscription_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscription_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscription_plans
    **/
    _count?: true | Subscription_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subscription_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subscription_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subscription_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subscription_plansMaxAggregateInputType
  }

  export type GetSubscription_plansAggregateType<T extends Subscription_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription_plans[P]>
      : GetScalarType<T[P], AggregateSubscription_plans[P]>
  }




  export type subscription_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscription_plansWhereInput
    orderBy?: subscription_plansOrderByWithAggregationInput | subscription_plansOrderByWithAggregationInput[]
    by: Subscription_plansScalarFieldEnum[] | Subscription_plansScalarFieldEnum
    having?: subscription_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subscription_plansCountAggregateInputType | true
    _avg?: Subscription_plansAvgAggregateInputType
    _sum?: Subscription_plansSumAggregateInputType
    _min?: Subscription_plansMinAggregateInputType
    _max?: Subscription_plansMaxAggregateInputType
  }

  export type Subscription_plansGroupByOutputType = {
    subplanid: number
    subplan_cat: string
    subplan: string
    subplan_amount: number
    subplan_months: string
    subplan_include: string
    subplan_exclude: string
    createdAt: Date
    updatedAt: Date
    _count: Subscription_plansCountAggregateOutputType | null
    _avg: Subscription_plansAvgAggregateOutputType | null
    _sum: Subscription_plansSumAggregateOutputType | null
    _min: Subscription_plansMinAggregateOutputType | null
    _max: Subscription_plansMaxAggregateOutputType | null
  }

  type GetSubscription_plansGroupByPayload<T extends subscription_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Subscription_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subscription_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subscription_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Subscription_plansGroupByOutputType[P]>
        }
      >
    >


  export type subscription_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subplanid?: boolean
    subplan_cat?: boolean
    subplan?: boolean
    subplan_amount?: boolean
    subplan_months?: boolean
    subplan_include?: boolean
    subplan_exclude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription_plans"]>



  export type subscription_plansSelectScalar = {
    subplanid?: boolean
    subplan_cat?: boolean
    subplan?: boolean
    subplan_amount?: boolean
    subplan_months?: boolean
    subplan_include?: boolean
    subplan_exclude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type subscription_plansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subplanid" | "subplan_cat" | "subplan" | "subplan_amount" | "subplan_months" | "subplan_include" | "subplan_exclude" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription_plans"]>

  export type $subscription_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscription_plans"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      subplanid: number
      subplan_cat: string
      subplan: string
      subplan_amount: number
      subplan_months: string
      subplan_include: string
      subplan_exclude: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription_plans"]>
    composites: {}
  }

  type subscription_plansGetPayload<S extends boolean | null | undefined | subscription_plansDefaultArgs> = $Result.GetResult<Prisma.$subscription_plansPayload, S>

  type subscription_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscription_plansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Subscription_plansCountAggregateInputType | true
    }

  export interface subscription_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription_plans'], meta: { name: 'subscription_plans' } }
    /**
     * Find zero or one Subscription_plans that matches the filter.
     * @param {subscription_plansFindUniqueArgs} args - Arguments to find a Subscription_plans
     * @example
     * // Get one Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscription_plansFindUniqueArgs>(args: SelectSubset<T, subscription_plansFindUniqueArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription_plans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscription_plansFindUniqueOrThrowArgs} args - Arguments to find a Subscription_plans
     * @example
     * // Get one Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscription_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, subscription_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansFindFirstArgs} args - Arguments to find a Subscription_plans
     * @example
     * // Get one Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscription_plansFindFirstArgs>(args?: SelectSubset<T, subscription_plansFindFirstArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansFindFirstOrThrowArgs} args - Arguments to find a Subscription_plans
     * @example
     * // Get one Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscription_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, subscription_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscription_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findMany()
     * 
     * // Get first 10 Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.findMany({ take: 10 })
     * 
     * // Only select the `subplanid`
     * const subscription_plansWithSubplanidOnly = await prisma.subscription_plans.findMany({ select: { subplanid: true } })
     * 
     */
    findMany<T extends subscription_plansFindManyArgs>(args?: SelectSubset<T, subscription_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription_plans.
     * @param {subscription_plansCreateArgs} args - Arguments to create a Subscription_plans.
     * @example
     * // Create one Subscription_plans
     * const Subscription_plans = await prisma.subscription_plans.create({
     *   data: {
     *     // ... data to create a Subscription_plans
     *   }
     * })
     * 
     */
    create<T extends subscription_plansCreateArgs>(args: SelectSubset<T, subscription_plansCreateArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscription_plans.
     * @param {subscription_plansCreateManyArgs} args - Arguments to create many Subscription_plans.
     * @example
     * // Create many Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscription_plansCreateManyArgs>(args?: SelectSubset<T, subscription_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription_plans.
     * @param {subscription_plansDeleteArgs} args - Arguments to delete one Subscription_plans.
     * @example
     * // Delete one Subscription_plans
     * const Subscription_plans = await prisma.subscription_plans.delete({
     *   where: {
     *     // ... filter to delete one Subscription_plans
     *   }
     * })
     * 
     */
    delete<T extends subscription_plansDeleteArgs>(args: SelectSubset<T, subscription_plansDeleteArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription_plans.
     * @param {subscription_plansUpdateArgs} args - Arguments to update one Subscription_plans.
     * @example
     * // Update one Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscription_plansUpdateArgs>(args: SelectSubset<T, subscription_plansUpdateArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscription_plans.
     * @param {subscription_plansDeleteManyArgs} args - Arguments to filter Subscription_plans to delete.
     * @example
     * // Delete a few Subscription_plans
     * const { count } = await prisma.subscription_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscription_plansDeleteManyArgs>(args?: SelectSubset<T, subscription_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscription_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscription_plansUpdateManyArgs>(args: SelectSubset<T, subscription_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription_plans.
     * @param {subscription_plansUpsertArgs} args - Arguments to update or create a Subscription_plans.
     * @example
     * // Update or create a Subscription_plans
     * const subscription_plans = await prisma.subscription_plans.upsert({
     *   create: {
     *     // ... data to create a Subscription_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription_plans we want to update
     *   }
     * })
     */
    upsert<T extends subscription_plansUpsertArgs>(args: SelectSubset<T, subscription_plansUpsertArgs<ExtArgs>>): Prisma__subscription_plansClient<$Result.GetResult<Prisma.$subscription_plansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscription_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansCountArgs} args - Arguments to filter Subscription_plans to count.
     * @example
     * // Count the number of Subscription_plans
     * const count = await prisma.subscription_plans.count({
     *   where: {
     *     // ... the filter for the Subscription_plans we want to count
     *   }
     * })
    **/
    count<T extends subscription_plansCountArgs>(
      args?: Subset<T, subscription_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subscription_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subscription_plansAggregateArgs>(args: Subset<T, Subscription_plansAggregateArgs>): Prisma.PrismaPromise<GetSubscription_plansAggregateType<T>>

    /**
     * Group by Subscription_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscription_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscription_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscription_plansGroupByArgs['orderBy'] }
        : { orderBy?: subscription_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscription_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscription_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription_plans model
   */
  readonly fields: subscription_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscription_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscription_plans model
   */
  interface subscription_plansFieldRefs {
    readonly subplanid: FieldRef<"subscription_plans", 'Int'>
    readonly subplan_cat: FieldRef<"subscription_plans", 'String'>
    readonly subplan: FieldRef<"subscription_plans", 'String'>
    readonly subplan_amount: FieldRef<"subscription_plans", 'Float'>
    readonly subplan_months: FieldRef<"subscription_plans", 'String'>
    readonly subplan_include: FieldRef<"subscription_plans", 'String'>
    readonly subplan_exclude: FieldRef<"subscription_plans", 'String'>
    readonly createdAt: FieldRef<"subscription_plans", 'DateTime'>
    readonly updatedAt: FieldRef<"subscription_plans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscription_plans findUnique
   */
  export type subscription_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter, which subscription_plans to fetch.
     */
    where: subscription_plansWhereUniqueInput
  }

  /**
   * subscription_plans findUniqueOrThrow
   */
  export type subscription_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter, which subscription_plans to fetch.
     */
    where: subscription_plansWhereUniqueInput
  }

  /**
   * subscription_plans findFirst
   */
  export type subscription_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter, which subscription_plans to fetch.
     */
    where?: subscription_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscription_plans to fetch.
     */
    orderBy?: subscription_plansOrderByWithRelationInput | subscription_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscription_plans.
     */
    cursor?: subscription_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscription_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscription_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscription_plans.
     */
    distinct?: Subscription_plansScalarFieldEnum | Subscription_plansScalarFieldEnum[]
  }

  /**
   * subscription_plans findFirstOrThrow
   */
  export type subscription_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter, which subscription_plans to fetch.
     */
    where?: subscription_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscription_plans to fetch.
     */
    orderBy?: subscription_plansOrderByWithRelationInput | subscription_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscription_plans.
     */
    cursor?: subscription_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscription_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscription_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscription_plans.
     */
    distinct?: Subscription_plansScalarFieldEnum | Subscription_plansScalarFieldEnum[]
  }

  /**
   * subscription_plans findMany
   */
  export type subscription_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter, which subscription_plans to fetch.
     */
    where?: subscription_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscription_plans to fetch.
     */
    orderBy?: subscription_plansOrderByWithRelationInput | subscription_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscription_plans.
     */
    cursor?: subscription_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscription_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscription_plans.
     */
    skip?: number
    distinct?: Subscription_plansScalarFieldEnum | Subscription_plansScalarFieldEnum[]
  }

  /**
   * subscription_plans create
   */
  export type subscription_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * The data needed to create a subscription_plans.
     */
    data: XOR<subscription_plansCreateInput, subscription_plansUncheckedCreateInput>
  }

  /**
   * subscription_plans createMany
   */
  export type subscription_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscription_plans.
     */
    data: subscription_plansCreateManyInput | subscription_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription_plans update
   */
  export type subscription_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * The data needed to update a subscription_plans.
     */
    data: XOR<subscription_plansUpdateInput, subscription_plansUncheckedUpdateInput>
    /**
     * Choose, which subscription_plans to update.
     */
    where: subscription_plansWhereUniqueInput
  }

  /**
   * subscription_plans updateMany
   */
  export type subscription_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscription_plans.
     */
    data: XOR<subscription_plansUpdateManyMutationInput, subscription_plansUncheckedUpdateManyInput>
    /**
     * Filter which subscription_plans to update
     */
    where?: subscription_plansWhereInput
    /**
     * Limit how many subscription_plans to update.
     */
    limit?: number
  }

  /**
   * subscription_plans upsert
   */
  export type subscription_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * The filter to search for the subscription_plans to update in case it exists.
     */
    where: subscription_plansWhereUniqueInput
    /**
     * In case the subscription_plans found by the `where` argument doesn't exist, create a new subscription_plans with this data.
     */
    create: XOR<subscription_plansCreateInput, subscription_plansUncheckedCreateInput>
    /**
     * In case the subscription_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscription_plansUpdateInput, subscription_plansUncheckedUpdateInput>
  }

  /**
   * subscription_plans delete
   */
  export type subscription_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
    /**
     * Filter which subscription_plans to delete.
     */
    where: subscription_plansWhereUniqueInput
  }

  /**
   * subscription_plans deleteMany
   */
  export type subscription_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription_plans to delete
     */
    where?: subscription_plansWhereInput
    /**
     * Limit how many subscription_plans to delete.
     */
    limit?: number
  }

  /**
   * subscription_plans without action
   */
  export type subscription_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription_plans
     */
    select?: subscription_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription_plans
     */
    omit?: subscription_plansOmit<ExtArgs> | null
  }


  /**
   * Model vendorreports
   */

  export type AggregateVendorreports = {
    _count: VendorreportsCountAggregateOutputType | null
    _avg: VendorreportsAvgAggregateOutputType | null
    _sum: VendorreportsSumAggregateOutputType | null
    _min: VendorreportsMinAggregateOutputType | null
    _max: VendorreportsMaxAggregateOutputType | null
  }

  export type VendorreportsAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorreportsSumAggregateOutputType = {
    id: number | null
  }

  export type VendorreportsMinAggregateOutputType = {
    id: number | null
    customerid: string | null
    customername: string | null
    vendorid: string | null
    plateno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorreportsMaxAggregateOutputType = {
    id: number | null
    customerid: string | null
    customername: string | null
    vendorid: string | null
    plateno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorreportsCountAggregateOutputType = {
    id: number
    customerid: number
    customername: number
    vendorid: number
    plateno: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorreportsAvgAggregateInputType = {
    id?: true
  }

  export type VendorreportsSumAggregateInputType = {
    id?: true
  }

  export type VendorreportsMinAggregateInputType = {
    id?: true
    customerid?: true
    customername?: true
    vendorid?: true
    plateno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorreportsMaxAggregateInputType = {
    id?: true
    customerid?: true
    customername?: true
    vendorid?: true
    plateno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorreportsCountAggregateInputType = {
    id?: true
    customerid?: true
    customername?: true
    vendorid?: true
    plateno?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorreportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vendorreports to aggregate.
     */
    where?: vendorreportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorreports to fetch.
     */
    orderBy?: vendorreportsOrderByWithRelationInput | vendorreportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vendorreportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorreports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorreports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vendorreports
    **/
    _count?: true | VendorreportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorreportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorreportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorreportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorreportsMaxAggregateInputType
  }

  export type GetVendorreportsAggregateType<T extends VendorreportsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorreports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorreports[P]>
      : GetScalarType<T[P], AggregateVendorreports[P]>
  }




  export type vendorreportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vendorreportsWhereInput
    orderBy?: vendorreportsOrderByWithAggregationInput | vendorreportsOrderByWithAggregationInput[]
    by: VendorreportsScalarFieldEnum[] | VendorreportsScalarFieldEnum
    having?: vendorreportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorreportsCountAggregateInputType | true
    _avg?: VendorreportsAvgAggregateInputType
    _sum?: VendorreportsSumAggregateInputType
    _min?: VendorreportsMinAggregateInputType
    _max?: VendorreportsMaxAggregateInputType
  }

  export type VendorreportsGroupByOutputType = {
    id: number
    customerid: string | null
    customername: string
    vendorid: string
    plateno: string
    createdAt: Date
    updatedAt: Date
    _count: VendorreportsCountAggregateOutputType | null
    _avg: VendorreportsAvgAggregateOutputType | null
    _sum: VendorreportsSumAggregateOutputType | null
    _min: VendorreportsMinAggregateOutputType | null
    _max: VendorreportsMaxAggregateOutputType | null
  }

  type GetVendorreportsGroupByPayload<T extends vendorreportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorreportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorreportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorreportsGroupByOutputType[P]>
            : GetScalarType<T[P], VendorreportsGroupByOutputType[P]>
        }
      >
    >


  export type vendorreportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerid?: boolean
    customername?: boolean
    vendorid?: boolean
    plateno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendorreports"]>



  export type vendorreportsSelectScalar = {
    id?: boolean
    customerid?: boolean
    customername?: boolean
    vendorid?: boolean
    plateno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vendorreportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerid" | "customername" | "vendorid" | "plateno" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorreports"]>

  export type $vendorreportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vendorreports"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerid: string | null
      customername: string
      vendorid: string
      plateno: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorreports"]>
    composites: {}
  }

  type vendorreportsGetPayload<S extends boolean | null | undefined | vendorreportsDefaultArgs> = $Result.GetResult<Prisma.$vendorreportsPayload, S>

  type vendorreportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vendorreportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorreportsCountAggregateInputType | true
    }

  export interface vendorreportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vendorreports'], meta: { name: 'vendorreports' } }
    /**
     * Find zero or one Vendorreports that matches the filter.
     * @param {vendorreportsFindUniqueArgs} args - Arguments to find a Vendorreports
     * @example
     * // Get one Vendorreports
     * const vendorreports = await prisma.vendorreports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vendorreportsFindUniqueArgs>(args: SelectSubset<T, vendorreportsFindUniqueArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendorreports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vendorreportsFindUniqueOrThrowArgs} args - Arguments to find a Vendorreports
     * @example
     * // Get one Vendorreports
     * const vendorreports = await prisma.vendorreports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vendorreportsFindUniqueOrThrowArgs>(args: SelectSubset<T, vendorreportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendorreports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsFindFirstArgs} args - Arguments to find a Vendorreports
     * @example
     * // Get one Vendorreports
     * const vendorreports = await prisma.vendorreports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vendorreportsFindFirstArgs>(args?: SelectSubset<T, vendorreportsFindFirstArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendorreports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsFindFirstOrThrowArgs} args - Arguments to find a Vendorreports
     * @example
     * // Get one Vendorreports
     * const vendorreports = await prisma.vendorreports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vendorreportsFindFirstOrThrowArgs>(args?: SelectSubset<T, vendorreportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendorreports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendorreports
     * const vendorreports = await prisma.vendorreports.findMany()
     * 
     * // Get first 10 Vendorreports
     * const vendorreports = await prisma.vendorreports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorreportsWithIdOnly = await prisma.vendorreports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vendorreportsFindManyArgs>(args?: SelectSubset<T, vendorreportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendorreports.
     * @param {vendorreportsCreateArgs} args - Arguments to create a Vendorreports.
     * @example
     * // Create one Vendorreports
     * const Vendorreports = await prisma.vendorreports.create({
     *   data: {
     *     // ... data to create a Vendorreports
     *   }
     * })
     * 
     */
    create<T extends vendorreportsCreateArgs>(args: SelectSubset<T, vendorreportsCreateArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendorreports.
     * @param {vendorreportsCreateManyArgs} args - Arguments to create many Vendorreports.
     * @example
     * // Create many Vendorreports
     * const vendorreports = await prisma.vendorreports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vendorreportsCreateManyArgs>(args?: SelectSubset<T, vendorreportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendorreports.
     * @param {vendorreportsDeleteArgs} args - Arguments to delete one Vendorreports.
     * @example
     * // Delete one Vendorreports
     * const Vendorreports = await prisma.vendorreports.delete({
     *   where: {
     *     // ... filter to delete one Vendorreports
     *   }
     * })
     * 
     */
    delete<T extends vendorreportsDeleteArgs>(args: SelectSubset<T, vendorreportsDeleteArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendorreports.
     * @param {vendorreportsUpdateArgs} args - Arguments to update one Vendorreports.
     * @example
     * // Update one Vendorreports
     * const vendorreports = await prisma.vendorreports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vendorreportsUpdateArgs>(args: SelectSubset<T, vendorreportsUpdateArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendorreports.
     * @param {vendorreportsDeleteManyArgs} args - Arguments to filter Vendorreports to delete.
     * @example
     * // Delete a few Vendorreports
     * const { count } = await prisma.vendorreports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vendorreportsDeleteManyArgs>(args?: SelectSubset<T, vendorreportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendorreports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendorreports
     * const vendorreports = await prisma.vendorreports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vendorreportsUpdateManyArgs>(args: SelectSubset<T, vendorreportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendorreports.
     * @param {vendorreportsUpsertArgs} args - Arguments to update or create a Vendorreports.
     * @example
     * // Update or create a Vendorreports
     * const vendorreports = await prisma.vendorreports.upsert({
     *   create: {
     *     // ... data to create a Vendorreports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendorreports we want to update
     *   }
     * })
     */
    upsert<T extends vendorreportsUpsertArgs>(args: SelectSubset<T, vendorreportsUpsertArgs<ExtArgs>>): Prisma__vendorreportsClient<$Result.GetResult<Prisma.$vendorreportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendorreports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsCountArgs} args - Arguments to filter Vendorreports to count.
     * @example
     * // Count the number of Vendorreports
     * const count = await prisma.vendorreports.count({
     *   where: {
     *     // ... the filter for the Vendorreports we want to count
     *   }
     * })
    **/
    count<T extends vendorreportsCountArgs>(
      args?: Subset<T, vendorreportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorreportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendorreports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorreportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorreportsAggregateArgs>(args: Subset<T, VendorreportsAggregateArgs>): Prisma.PrismaPromise<GetVendorreportsAggregateType<T>>

    /**
     * Group by Vendorreports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorreportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vendorreportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vendorreportsGroupByArgs['orderBy'] }
        : { orderBy?: vendorreportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vendorreportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorreportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vendorreports model
   */
  readonly fields: vendorreportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vendorreports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vendorreportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vendorreports model
   */
  interface vendorreportsFieldRefs {
    readonly id: FieldRef<"vendorreports", 'Int'>
    readonly customerid: FieldRef<"vendorreports", 'String'>
    readonly customername: FieldRef<"vendorreports", 'String'>
    readonly vendorid: FieldRef<"vendorreports", 'String'>
    readonly plateno: FieldRef<"vendorreports", 'String'>
    readonly createdAt: FieldRef<"vendorreports", 'DateTime'>
    readonly updatedAt: FieldRef<"vendorreports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vendorreports findUnique
   */
  export type vendorreportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter, which vendorreports to fetch.
     */
    where: vendorreportsWhereUniqueInput
  }

  /**
   * vendorreports findUniqueOrThrow
   */
  export type vendorreportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter, which vendorreports to fetch.
     */
    where: vendorreportsWhereUniqueInput
  }

  /**
   * vendorreports findFirst
   */
  export type vendorreportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter, which vendorreports to fetch.
     */
    where?: vendorreportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorreports to fetch.
     */
    orderBy?: vendorreportsOrderByWithRelationInput | vendorreportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorreports.
     */
    cursor?: vendorreportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorreports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorreports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorreports.
     */
    distinct?: VendorreportsScalarFieldEnum | VendorreportsScalarFieldEnum[]
  }

  /**
   * vendorreports findFirstOrThrow
   */
  export type vendorreportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter, which vendorreports to fetch.
     */
    where?: vendorreportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorreports to fetch.
     */
    orderBy?: vendorreportsOrderByWithRelationInput | vendorreportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorreports.
     */
    cursor?: vendorreportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorreports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorreports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorreports.
     */
    distinct?: VendorreportsScalarFieldEnum | VendorreportsScalarFieldEnum[]
  }

  /**
   * vendorreports findMany
   */
  export type vendorreportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter, which vendorreports to fetch.
     */
    where?: vendorreportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorreports to fetch.
     */
    orderBy?: vendorreportsOrderByWithRelationInput | vendorreportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vendorreports.
     */
    cursor?: vendorreportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorreports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorreports.
     */
    skip?: number
    distinct?: VendorreportsScalarFieldEnum | VendorreportsScalarFieldEnum[]
  }

  /**
   * vendorreports create
   */
  export type vendorreportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * The data needed to create a vendorreports.
     */
    data: XOR<vendorreportsCreateInput, vendorreportsUncheckedCreateInput>
  }

  /**
   * vendorreports createMany
   */
  export type vendorreportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vendorreports.
     */
    data: vendorreportsCreateManyInput | vendorreportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vendorreports update
   */
  export type vendorreportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * The data needed to update a vendorreports.
     */
    data: XOR<vendorreportsUpdateInput, vendorreportsUncheckedUpdateInput>
    /**
     * Choose, which vendorreports to update.
     */
    where: vendorreportsWhereUniqueInput
  }

  /**
   * vendorreports updateMany
   */
  export type vendorreportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vendorreports.
     */
    data: XOR<vendorreportsUpdateManyMutationInput, vendorreportsUncheckedUpdateManyInput>
    /**
     * Filter which vendorreports to update
     */
    where?: vendorreportsWhereInput
    /**
     * Limit how many vendorreports to update.
     */
    limit?: number
  }

  /**
   * vendorreports upsert
   */
  export type vendorreportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * The filter to search for the vendorreports to update in case it exists.
     */
    where: vendorreportsWhereUniqueInput
    /**
     * In case the vendorreports found by the `where` argument doesn't exist, create a new vendorreports with this data.
     */
    create: XOR<vendorreportsCreateInput, vendorreportsUncheckedCreateInput>
    /**
     * In case the vendorreports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vendorreportsUpdateInput, vendorreportsUncheckedUpdateInput>
  }

  /**
   * vendorreports delete
   */
  export type vendorreportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
    /**
     * Filter which vendorreports to delete.
     */
    where: vendorreportsWhereUniqueInput
  }

  /**
   * vendorreports deleteMany
   */
  export type vendorreportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vendorreports to delete
     */
    where?: vendorreportsWhereInput
    /**
     * Limit how many vendorreports to delete.
     */
    limit?: number
  }

  /**
   * vendorreports without action
   */
  export type vendorreportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vendorreports
     */
    select?: vendorreportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vendorreports
     */
    omit?: vendorreportsOmit<ExtArgs> | null
  }


  /**
   * Model water_purchases
   */

  export type AggregateWater_purchases = {
    _count: Water_purchasesCountAggregateOutputType | null
    _avg: Water_purchasesAvgAggregateOutputType | null
    _sum: Water_purchasesSumAggregateOutputType | null
    _min: Water_purchasesMinAggregateOutputType | null
    _max: Water_purchasesMaxAggregateOutputType | null
  }

  export type Water_purchasesAvgAggregateOutputType = {
    wpid: number | null
    wp_merchant_latitude: Decimal | null
    wp_merchant_longitude: Decimal | null
    wp_amount: number | null
    wp_commission: number | null
    wp_owner_amount: number | null
    wp_driver_latitude: Decimal | null
    wp_driver_longitude: Decimal | null
  }

  export type Water_purchasesSumAggregateOutputType = {
    wpid: number | null
    wp_merchant_latitude: Decimal | null
    wp_merchant_longitude: Decimal | null
    wp_amount: number | null
    wp_commission: number | null
    wp_owner_amount: number | null
    wp_driver_latitude: Decimal | null
    wp_driver_longitude: Decimal | null
  }

  export type Water_purchasesMinAggregateOutputType = {
    wpid: number | null
    wp_orderref: string | null
    wp_type: string | null
    wp_merchant_id: string | null
    wp_merchant_name: string | null
    wp_merchant_address: string | null
    wp_merchant_latitude: Decimal | null
    wp_merchant_longitude: Decimal | null
    wp_volume: string | null
    wp_amount: number | null
    wp_commission: number | null
    wp_owner_amount: number | null
    wp_driver_id: string | null
    wp_driver_name: string | null
    wp_driver_latitude: Decimal | null
    wp_driver_longitude: Decimal | null
    wp_fleetid: string | null
    wp_remark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Water_purchasesMaxAggregateOutputType = {
    wpid: number | null
    wp_orderref: string | null
    wp_type: string | null
    wp_merchant_id: string | null
    wp_merchant_name: string | null
    wp_merchant_address: string | null
    wp_merchant_latitude: Decimal | null
    wp_merchant_longitude: Decimal | null
    wp_volume: string | null
    wp_amount: number | null
    wp_commission: number | null
    wp_owner_amount: number | null
    wp_driver_id: string | null
    wp_driver_name: string | null
    wp_driver_latitude: Decimal | null
    wp_driver_longitude: Decimal | null
    wp_fleetid: string | null
    wp_remark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Water_purchasesCountAggregateOutputType = {
    wpid: number
    wp_orderref: number
    wp_type: number
    wp_merchant_id: number
    wp_merchant_name: number
    wp_merchant_address: number
    wp_merchant_latitude: number
    wp_merchant_longitude: number
    wp_volume: number
    wp_amount: number
    wp_commission: number
    wp_owner_amount: number
    wp_driver_id: number
    wp_driver_name: number
    wp_driver_latitude: number
    wp_driver_longitude: number
    wp_fleetid: number
    wp_remark: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Water_purchasesAvgAggregateInputType = {
    wpid?: true
    wp_merchant_latitude?: true
    wp_merchant_longitude?: true
    wp_amount?: true
    wp_commission?: true
    wp_owner_amount?: true
    wp_driver_latitude?: true
    wp_driver_longitude?: true
  }

  export type Water_purchasesSumAggregateInputType = {
    wpid?: true
    wp_merchant_latitude?: true
    wp_merchant_longitude?: true
    wp_amount?: true
    wp_commission?: true
    wp_owner_amount?: true
    wp_driver_latitude?: true
    wp_driver_longitude?: true
  }

  export type Water_purchasesMinAggregateInputType = {
    wpid?: true
    wp_orderref?: true
    wp_type?: true
    wp_merchant_id?: true
    wp_merchant_name?: true
    wp_merchant_address?: true
    wp_merchant_latitude?: true
    wp_merchant_longitude?: true
    wp_volume?: true
    wp_amount?: true
    wp_commission?: true
    wp_owner_amount?: true
    wp_driver_id?: true
    wp_driver_name?: true
    wp_driver_latitude?: true
    wp_driver_longitude?: true
    wp_fleetid?: true
    wp_remark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Water_purchasesMaxAggregateInputType = {
    wpid?: true
    wp_orderref?: true
    wp_type?: true
    wp_merchant_id?: true
    wp_merchant_name?: true
    wp_merchant_address?: true
    wp_merchant_latitude?: true
    wp_merchant_longitude?: true
    wp_volume?: true
    wp_amount?: true
    wp_commission?: true
    wp_owner_amount?: true
    wp_driver_id?: true
    wp_driver_name?: true
    wp_driver_latitude?: true
    wp_driver_longitude?: true
    wp_fleetid?: true
    wp_remark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Water_purchasesCountAggregateInputType = {
    wpid?: true
    wp_orderref?: true
    wp_type?: true
    wp_merchant_id?: true
    wp_merchant_name?: true
    wp_merchant_address?: true
    wp_merchant_latitude?: true
    wp_merchant_longitude?: true
    wp_volume?: true
    wp_amount?: true
    wp_commission?: true
    wp_owner_amount?: true
    wp_driver_id?: true
    wp_driver_name?: true
    wp_driver_latitude?: true
    wp_driver_longitude?: true
    wp_fleetid?: true
    wp_remark?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Water_purchasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which water_purchases to aggregate.
     */
    where?: water_purchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of water_purchases to fetch.
     */
    orderBy?: water_purchasesOrderByWithRelationInput | water_purchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: water_purchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` water_purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` water_purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned water_purchases
    **/
    _count?: true | Water_purchasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Water_purchasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Water_purchasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Water_purchasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Water_purchasesMaxAggregateInputType
  }

  export type GetWater_purchasesAggregateType<T extends Water_purchasesAggregateArgs> = {
        [P in keyof T & keyof AggregateWater_purchases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWater_purchases[P]>
      : GetScalarType<T[P], AggregateWater_purchases[P]>
  }




  export type water_purchasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: water_purchasesWhereInput
    orderBy?: water_purchasesOrderByWithAggregationInput | water_purchasesOrderByWithAggregationInput[]
    by: Water_purchasesScalarFieldEnum[] | Water_purchasesScalarFieldEnum
    having?: water_purchasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Water_purchasesCountAggregateInputType | true
    _avg?: Water_purchasesAvgAggregateInputType
    _sum?: Water_purchasesSumAggregateInputType
    _min?: Water_purchasesMinAggregateInputType
    _max?: Water_purchasesMaxAggregateInputType
  }

  export type Water_purchasesGroupByOutputType = {
    wpid: number
    wp_orderref: string | null
    wp_type: string
    wp_merchant_id: string
    wp_merchant_name: string
    wp_merchant_address: string
    wp_merchant_latitude: Decimal
    wp_merchant_longitude: Decimal
    wp_volume: string
    wp_amount: number
    wp_commission: number
    wp_owner_amount: number
    wp_driver_id: string
    wp_driver_name: string
    wp_driver_latitude: Decimal
    wp_driver_longitude: Decimal
    wp_fleetid: string
    wp_remark: string
    createdAt: Date
    updatedAt: Date
    _count: Water_purchasesCountAggregateOutputType | null
    _avg: Water_purchasesAvgAggregateOutputType | null
    _sum: Water_purchasesSumAggregateOutputType | null
    _min: Water_purchasesMinAggregateOutputType | null
    _max: Water_purchasesMaxAggregateOutputType | null
  }

  type GetWater_purchasesGroupByPayload<T extends water_purchasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Water_purchasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Water_purchasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Water_purchasesGroupByOutputType[P]>
            : GetScalarType<T[P], Water_purchasesGroupByOutputType[P]>
        }
      >
    >


  export type water_purchasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wpid?: boolean
    wp_orderref?: boolean
    wp_type?: boolean
    wp_merchant_id?: boolean
    wp_merchant_name?: boolean
    wp_merchant_address?: boolean
    wp_merchant_latitude?: boolean
    wp_merchant_longitude?: boolean
    wp_volume?: boolean
    wp_amount?: boolean
    wp_commission?: boolean
    wp_owner_amount?: boolean
    wp_driver_id?: boolean
    wp_driver_name?: boolean
    wp_driver_latitude?: boolean
    wp_driver_longitude?: boolean
    wp_fleetid?: boolean
    wp_remark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["water_purchases"]>



  export type water_purchasesSelectScalar = {
    wpid?: boolean
    wp_orderref?: boolean
    wp_type?: boolean
    wp_merchant_id?: boolean
    wp_merchant_name?: boolean
    wp_merchant_address?: boolean
    wp_merchant_latitude?: boolean
    wp_merchant_longitude?: boolean
    wp_volume?: boolean
    wp_amount?: boolean
    wp_commission?: boolean
    wp_owner_amount?: boolean
    wp_driver_id?: boolean
    wp_driver_name?: boolean
    wp_driver_latitude?: boolean
    wp_driver_longitude?: boolean
    wp_fleetid?: boolean
    wp_remark?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type water_purchasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"wpid" | "wp_orderref" | "wp_type" | "wp_merchant_id" | "wp_merchant_name" | "wp_merchant_address" | "wp_merchant_latitude" | "wp_merchant_longitude" | "wp_volume" | "wp_amount" | "wp_commission" | "wp_owner_amount" | "wp_driver_id" | "wp_driver_name" | "wp_driver_latitude" | "wp_driver_longitude" | "wp_fleetid" | "wp_remark" | "createdAt" | "updatedAt", ExtArgs["result"]["water_purchases"]>

  export type $water_purchasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "water_purchases"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      wpid: number
      wp_orderref: string | null
      wp_type: string
      wp_merchant_id: string
      wp_merchant_name: string
      wp_merchant_address: string
      wp_merchant_latitude: Prisma.Decimal
      wp_merchant_longitude: Prisma.Decimal
      wp_volume: string
      wp_amount: number
      wp_commission: number
      wp_owner_amount: number
      wp_driver_id: string
      wp_driver_name: string
      wp_driver_latitude: Prisma.Decimal
      wp_driver_longitude: Prisma.Decimal
      wp_fleetid: string
      wp_remark: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["water_purchases"]>
    composites: {}
  }

  type water_purchasesGetPayload<S extends boolean | null | undefined | water_purchasesDefaultArgs> = $Result.GetResult<Prisma.$water_purchasesPayload, S>

  type water_purchasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<water_purchasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Water_purchasesCountAggregateInputType | true
    }

  export interface water_purchasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['water_purchases'], meta: { name: 'water_purchases' } }
    /**
     * Find zero or one Water_purchases that matches the filter.
     * @param {water_purchasesFindUniqueArgs} args - Arguments to find a Water_purchases
     * @example
     * // Get one Water_purchases
     * const water_purchases = await prisma.water_purchases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends water_purchasesFindUniqueArgs>(args: SelectSubset<T, water_purchasesFindUniqueArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Water_purchases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {water_purchasesFindUniqueOrThrowArgs} args - Arguments to find a Water_purchases
     * @example
     * // Get one Water_purchases
     * const water_purchases = await prisma.water_purchases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends water_purchasesFindUniqueOrThrowArgs>(args: SelectSubset<T, water_purchasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Water_purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesFindFirstArgs} args - Arguments to find a Water_purchases
     * @example
     * // Get one Water_purchases
     * const water_purchases = await prisma.water_purchases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends water_purchasesFindFirstArgs>(args?: SelectSubset<T, water_purchasesFindFirstArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Water_purchases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesFindFirstOrThrowArgs} args - Arguments to find a Water_purchases
     * @example
     * // Get one Water_purchases
     * const water_purchases = await prisma.water_purchases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends water_purchasesFindFirstOrThrowArgs>(args?: SelectSubset<T, water_purchasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Water_purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Water_purchases
     * const water_purchases = await prisma.water_purchases.findMany()
     * 
     * // Get first 10 Water_purchases
     * const water_purchases = await prisma.water_purchases.findMany({ take: 10 })
     * 
     * // Only select the `wpid`
     * const water_purchasesWithWpidOnly = await prisma.water_purchases.findMany({ select: { wpid: true } })
     * 
     */
    findMany<T extends water_purchasesFindManyArgs>(args?: SelectSubset<T, water_purchasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Water_purchases.
     * @param {water_purchasesCreateArgs} args - Arguments to create a Water_purchases.
     * @example
     * // Create one Water_purchases
     * const Water_purchases = await prisma.water_purchases.create({
     *   data: {
     *     // ... data to create a Water_purchases
     *   }
     * })
     * 
     */
    create<T extends water_purchasesCreateArgs>(args: SelectSubset<T, water_purchasesCreateArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Water_purchases.
     * @param {water_purchasesCreateManyArgs} args - Arguments to create many Water_purchases.
     * @example
     * // Create many Water_purchases
     * const water_purchases = await prisma.water_purchases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends water_purchasesCreateManyArgs>(args?: SelectSubset<T, water_purchasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Water_purchases.
     * @param {water_purchasesDeleteArgs} args - Arguments to delete one Water_purchases.
     * @example
     * // Delete one Water_purchases
     * const Water_purchases = await prisma.water_purchases.delete({
     *   where: {
     *     // ... filter to delete one Water_purchases
     *   }
     * })
     * 
     */
    delete<T extends water_purchasesDeleteArgs>(args: SelectSubset<T, water_purchasesDeleteArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Water_purchases.
     * @param {water_purchasesUpdateArgs} args - Arguments to update one Water_purchases.
     * @example
     * // Update one Water_purchases
     * const water_purchases = await prisma.water_purchases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends water_purchasesUpdateArgs>(args: SelectSubset<T, water_purchasesUpdateArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Water_purchases.
     * @param {water_purchasesDeleteManyArgs} args - Arguments to filter Water_purchases to delete.
     * @example
     * // Delete a few Water_purchases
     * const { count } = await prisma.water_purchases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends water_purchasesDeleteManyArgs>(args?: SelectSubset<T, water_purchasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Water_purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Water_purchases
     * const water_purchases = await prisma.water_purchases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends water_purchasesUpdateManyArgs>(args: SelectSubset<T, water_purchasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Water_purchases.
     * @param {water_purchasesUpsertArgs} args - Arguments to update or create a Water_purchases.
     * @example
     * // Update or create a Water_purchases
     * const water_purchases = await prisma.water_purchases.upsert({
     *   create: {
     *     // ... data to create a Water_purchases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Water_purchases we want to update
     *   }
     * })
     */
    upsert<T extends water_purchasesUpsertArgs>(args: SelectSubset<T, water_purchasesUpsertArgs<ExtArgs>>): Prisma__water_purchasesClient<$Result.GetResult<Prisma.$water_purchasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Water_purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesCountArgs} args - Arguments to filter Water_purchases to count.
     * @example
     * // Count the number of Water_purchases
     * const count = await prisma.water_purchases.count({
     *   where: {
     *     // ... the filter for the Water_purchases we want to count
     *   }
     * })
    **/
    count<T extends water_purchasesCountArgs>(
      args?: Subset<T, water_purchasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Water_purchasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Water_purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Water_purchasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Water_purchasesAggregateArgs>(args: Subset<T, Water_purchasesAggregateArgs>): Prisma.PrismaPromise<GetWater_purchasesAggregateType<T>>

    /**
     * Group by Water_purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {water_purchasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends water_purchasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: water_purchasesGroupByArgs['orderBy'] }
        : { orderBy?: water_purchasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, water_purchasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWater_purchasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the water_purchases model
   */
  readonly fields: water_purchasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for water_purchases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__water_purchasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the water_purchases model
   */
  interface water_purchasesFieldRefs {
    readonly wpid: FieldRef<"water_purchases", 'Int'>
    readonly wp_orderref: FieldRef<"water_purchases", 'String'>
    readonly wp_type: FieldRef<"water_purchases", 'String'>
    readonly wp_merchant_id: FieldRef<"water_purchases", 'String'>
    readonly wp_merchant_name: FieldRef<"water_purchases", 'String'>
    readonly wp_merchant_address: FieldRef<"water_purchases", 'String'>
    readonly wp_merchant_latitude: FieldRef<"water_purchases", 'Decimal'>
    readonly wp_merchant_longitude: FieldRef<"water_purchases", 'Decimal'>
    readonly wp_volume: FieldRef<"water_purchases", 'String'>
    readonly wp_amount: FieldRef<"water_purchases", 'Float'>
    readonly wp_commission: FieldRef<"water_purchases", 'Float'>
    readonly wp_owner_amount: FieldRef<"water_purchases", 'Float'>
    readonly wp_driver_id: FieldRef<"water_purchases", 'String'>
    readonly wp_driver_name: FieldRef<"water_purchases", 'String'>
    readonly wp_driver_latitude: FieldRef<"water_purchases", 'Decimal'>
    readonly wp_driver_longitude: FieldRef<"water_purchases", 'Decimal'>
    readonly wp_fleetid: FieldRef<"water_purchases", 'String'>
    readonly wp_remark: FieldRef<"water_purchases", 'String'>
    readonly createdAt: FieldRef<"water_purchases", 'DateTime'>
    readonly updatedAt: FieldRef<"water_purchases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * water_purchases findUnique
   */
  export type water_purchasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter, which water_purchases to fetch.
     */
    where: water_purchasesWhereUniqueInput
  }

  /**
   * water_purchases findUniqueOrThrow
   */
  export type water_purchasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter, which water_purchases to fetch.
     */
    where: water_purchasesWhereUniqueInput
  }

  /**
   * water_purchases findFirst
   */
  export type water_purchasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter, which water_purchases to fetch.
     */
    where?: water_purchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of water_purchases to fetch.
     */
    orderBy?: water_purchasesOrderByWithRelationInput | water_purchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for water_purchases.
     */
    cursor?: water_purchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` water_purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` water_purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of water_purchases.
     */
    distinct?: Water_purchasesScalarFieldEnum | Water_purchasesScalarFieldEnum[]
  }

  /**
   * water_purchases findFirstOrThrow
   */
  export type water_purchasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter, which water_purchases to fetch.
     */
    where?: water_purchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of water_purchases to fetch.
     */
    orderBy?: water_purchasesOrderByWithRelationInput | water_purchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for water_purchases.
     */
    cursor?: water_purchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` water_purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` water_purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of water_purchases.
     */
    distinct?: Water_purchasesScalarFieldEnum | Water_purchasesScalarFieldEnum[]
  }

  /**
   * water_purchases findMany
   */
  export type water_purchasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter, which water_purchases to fetch.
     */
    where?: water_purchasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of water_purchases to fetch.
     */
    orderBy?: water_purchasesOrderByWithRelationInput | water_purchasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing water_purchases.
     */
    cursor?: water_purchasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` water_purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` water_purchases.
     */
    skip?: number
    distinct?: Water_purchasesScalarFieldEnum | Water_purchasesScalarFieldEnum[]
  }

  /**
   * water_purchases create
   */
  export type water_purchasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * The data needed to create a water_purchases.
     */
    data: XOR<water_purchasesCreateInput, water_purchasesUncheckedCreateInput>
  }

  /**
   * water_purchases createMany
   */
  export type water_purchasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many water_purchases.
     */
    data: water_purchasesCreateManyInput | water_purchasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * water_purchases update
   */
  export type water_purchasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * The data needed to update a water_purchases.
     */
    data: XOR<water_purchasesUpdateInput, water_purchasesUncheckedUpdateInput>
    /**
     * Choose, which water_purchases to update.
     */
    where: water_purchasesWhereUniqueInput
  }

  /**
   * water_purchases updateMany
   */
  export type water_purchasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update water_purchases.
     */
    data: XOR<water_purchasesUpdateManyMutationInput, water_purchasesUncheckedUpdateManyInput>
    /**
     * Filter which water_purchases to update
     */
    where?: water_purchasesWhereInput
    /**
     * Limit how many water_purchases to update.
     */
    limit?: number
  }

  /**
   * water_purchases upsert
   */
  export type water_purchasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * The filter to search for the water_purchases to update in case it exists.
     */
    where: water_purchasesWhereUniqueInput
    /**
     * In case the water_purchases found by the `where` argument doesn't exist, create a new water_purchases with this data.
     */
    create: XOR<water_purchasesCreateInput, water_purchasesUncheckedCreateInput>
    /**
     * In case the water_purchases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<water_purchasesUpdateInput, water_purchasesUncheckedUpdateInput>
  }

  /**
   * water_purchases delete
   */
  export type water_purchasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
    /**
     * Filter which water_purchases to delete.
     */
    where: water_purchasesWhereUniqueInput
  }

  /**
   * water_purchases deleteMany
   */
  export type water_purchasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which water_purchases to delete
     */
    where?: water_purchasesWhereInput
    /**
     * Limit how many water_purchases to delete.
     */
    limit?: number
  }

  /**
   * water_purchases without action
   */
  export type water_purchasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the water_purchases
     */
    select?: water_purchasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the water_purchases
     */
    omit?: water_purchasesOmit<ExtArgs> | null
  }


  /**
   * Model MeterReadings
   */

  export type AggregateMeterReadings = {
    _count: MeterReadingsCountAggregateOutputType | null
    _avg: MeterReadingsAvgAggregateOutputType | null
    _sum: MeterReadingsSumAggregateOutputType | null
    _min: MeterReadingsMinAggregateOutputType | null
    _max: MeterReadingsMaxAggregateOutputType | null
  }

  export type MeterReadingsAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    first_reading_user_id: number | null
    afternoon_reading_user_id: number | null
    last_reading_user_id: number | null
  }

  export type MeterReadingsSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    first_reading_user_id: number | null
    afternoon_reading_user_id: number | null
    last_reading_user_id: number | null
  }

  export type MeterReadingsMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    reading_date: Date | null
    first_reading: string | null
    first_reading_user_id: number | null
    first_reading_at: Date | null
    afternoon_reading: string | null
    afternoon_reading_user_id: number | null
    afternoon_reading_at: Date | null
    last_reading: string | null
    last_reading_user_id: number | null
    last_reading_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeterReadingsMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    reading_date: Date | null
    first_reading: string | null
    first_reading_user_id: number | null
    first_reading_at: Date | null
    afternoon_reading: string | null
    afternoon_reading_user_id: number | null
    afternoon_reading_at: Date | null
    last_reading: string | null
    last_reading_user_id: number | null
    last_reading_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeterReadingsCountAggregateOutputType = {
    id: number
    meterId: number
    reading_date: number
    first_reading: number
    first_reading_user_id: number
    first_reading_at: number
    afternoon_reading: number
    afternoon_reading_user_id: number
    afternoon_reading_at: number
    last_reading: number
    last_reading_user_id: number
    last_reading_at: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeterReadingsAvgAggregateInputType = {
    id?: true
    meterId?: true
    first_reading_user_id?: true
    afternoon_reading_user_id?: true
    last_reading_user_id?: true
  }

  export type MeterReadingsSumAggregateInputType = {
    id?: true
    meterId?: true
    first_reading_user_id?: true
    afternoon_reading_user_id?: true
    last_reading_user_id?: true
  }

  export type MeterReadingsMinAggregateInputType = {
    id?: true
    meterId?: true
    reading_date?: true
    first_reading?: true
    first_reading_user_id?: true
    first_reading_at?: true
    afternoon_reading?: true
    afternoon_reading_user_id?: true
    afternoon_reading_at?: true
    last_reading?: true
    last_reading_user_id?: true
    last_reading_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeterReadingsMaxAggregateInputType = {
    id?: true
    meterId?: true
    reading_date?: true
    first_reading?: true
    first_reading_user_id?: true
    first_reading_at?: true
    afternoon_reading?: true
    afternoon_reading_user_id?: true
    afternoon_reading_at?: true
    last_reading?: true
    last_reading_user_id?: true
    last_reading_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeterReadingsCountAggregateInputType = {
    id?: true
    meterId?: true
    reading_date?: true
    first_reading?: true
    first_reading_user_id?: true
    first_reading_at?: true
    afternoon_reading?: true
    afternoon_reading_user_id?: true
    afternoon_reading_at?: true
    last_reading?: true
    last_reading_user_id?: true
    last_reading_at?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeterReadingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeterReadings to aggregate.
     */
    where?: MeterReadingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterReadings to fetch.
     */
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeterReadingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeterReadings
    **/
    _count?: true | MeterReadingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeterReadingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeterReadingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeterReadingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeterReadingsMaxAggregateInputType
  }

  export type GetMeterReadingsAggregateType<T extends MeterReadingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMeterReadings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeterReadings[P]>
      : GetScalarType<T[P], AggregateMeterReadings[P]>
  }




  export type MeterReadingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeterReadingsWhereInput
    orderBy?: MeterReadingsOrderByWithAggregationInput | MeterReadingsOrderByWithAggregationInput[]
    by: MeterReadingsScalarFieldEnum[] | MeterReadingsScalarFieldEnum
    having?: MeterReadingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeterReadingsCountAggregateInputType | true
    _avg?: MeterReadingsAvgAggregateInputType
    _sum?: MeterReadingsSumAggregateInputType
    _min?: MeterReadingsMinAggregateInputType
    _max?: MeterReadingsMaxAggregateInputType
  }

  export type MeterReadingsGroupByOutputType = {
    id: number
    meterId: number
    reading_date: Date
    first_reading: string | null
    first_reading_user_id: number | null
    first_reading_at: Date | null
    afternoon_reading: string | null
    afternoon_reading_user_id: number | null
    afternoon_reading_at: Date | null
    last_reading: string | null
    last_reading_user_id: number | null
    last_reading_at: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MeterReadingsCountAggregateOutputType | null
    _avg: MeterReadingsAvgAggregateOutputType | null
    _sum: MeterReadingsSumAggregateOutputType | null
    _min: MeterReadingsMinAggregateOutputType | null
    _max: MeterReadingsMaxAggregateOutputType | null
  }

  type GetMeterReadingsGroupByPayload<T extends MeterReadingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeterReadingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeterReadingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeterReadingsGroupByOutputType[P]>
            : GetScalarType<T[P], MeterReadingsGroupByOutputType[P]>
        }
      >
    >


  export type MeterReadingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    reading_date?: boolean
    first_reading?: boolean
    first_reading_user_id?: boolean
    first_reading_at?: boolean
    afternoon_reading?: boolean
    afternoon_reading_user_id?: boolean
    afternoon_reading_at?: boolean
    last_reading?: boolean
    last_reading_user_id?: boolean
    last_reading_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meter?: boolean | metersDefaultArgs<ExtArgs>
    first_reading_user?: boolean | MeterReadings$first_reading_userArgs<ExtArgs>
    afternoon_reading_user?: boolean | MeterReadings$afternoon_reading_userArgs<ExtArgs>
    last_reading_user?: boolean | MeterReadings$last_reading_userArgs<ExtArgs>
  }, ExtArgs["result"]["meterReadings"]>



  export type MeterReadingsSelectScalar = {
    id?: boolean
    meterId?: boolean
    reading_date?: boolean
    first_reading?: boolean
    first_reading_user_id?: boolean
    first_reading_at?: boolean
    afternoon_reading?: boolean
    afternoon_reading_user_id?: boolean
    afternoon_reading_at?: boolean
    last_reading?: boolean
    last_reading_user_id?: boolean
    last_reading_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeterReadingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meterId" | "reading_date" | "first_reading" | "first_reading_user_id" | "first_reading_at" | "afternoon_reading" | "afternoon_reading_user_id" | "afternoon_reading_at" | "last_reading" | "last_reading_user_id" | "last_reading_at" | "createdAt" | "updatedAt", ExtArgs["result"]["meterReadings"]>
  export type MeterReadingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meter?: boolean | metersDefaultArgs<ExtArgs>
    first_reading_user?: boolean | MeterReadings$first_reading_userArgs<ExtArgs>
    afternoon_reading_user?: boolean | MeterReadings$afternoon_reading_userArgs<ExtArgs>
    last_reading_user?: boolean | MeterReadings$last_reading_userArgs<ExtArgs>
  }

  export type $MeterReadingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeterReadings"
    objects: {
      meter: Prisma.$metersPayload<ExtArgs>
      first_reading_user: Prisma.$usersPayload<ExtArgs> | null
      afternoon_reading_user: Prisma.$usersPayload<ExtArgs> | null
      last_reading_user: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      reading_date: Date
      first_reading: string | null
      first_reading_user_id: number | null
      first_reading_at: Date | null
      afternoon_reading: string | null
      afternoon_reading_user_id: number | null
      afternoon_reading_at: Date | null
      last_reading: string | null
      last_reading_user_id: number | null
      last_reading_at: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meterReadings"]>
    composites: {}
  }

  type MeterReadingsGetPayload<S extends boolean | null | undefined | MeterReadingsDefaultArgs> = $Result.GetResult<Prisma.$MeterReadingsPayload, S>

  type MeterReadingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeterReadingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeterReadingsCountAggregateInputType | true
    }

  export interface MeterReadingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeterReadings'], meta: { name: 'MeterReadings' } }
    /**
     * Find zero or one MeterReadings that matches the filter.
     * @param {MeterReadingsFindUniqueArgs} args - Arguments to find a MeterReadings
     * @example
     * // Get one MeterReadings
     * const meterReadings = await prisma.meterReadings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeterReadingsFindUniqueArgs>(args: SelectSubset<T, MeterReadingsFindUniqueArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeterReadings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeterReadingsFindUniqueOrThrowArgs} args - Arguments to find a MeterReadings
     * @example
     * // Get one MeterReadings
     * const meterReadings = await prisma.meterReadings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeterReadingsFindUniqueOrThrowArgs>(args: SelectSubset<T, MeterReadingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeterReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsFindFirstArgs} args - Arguments to find a MeterReadings
     * @example
     * // Get one MeterReadings
     * const meterReadings = await prisma.meterReadings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeterReadingsFindFirstArgs>(args?: SelectSubset<T, MeterReadingsFindFirstArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeterReadings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsFindFirstOrThrowArgs} args - Arguments to find a MeterReadings
     * @example
     * // Get one MeterReadings
     * const meterReadings = await prisma.meterReadings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeterReadingsFindFirstOrThrowArgs>(args?: SelectSubset<T, MeterReadingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeterReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeterReadings
     * const meterReadings = await prisma.meterReadings.findMany()
     * 
     * // Get first 10 MeterReadings
     * const meterReadings = await prisma.meterReadings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meterReadingsWithIdOnly = await prisma.meterReadings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeterReadingsFindManyArgs>(args?: SelectSubset<T, MeterReadingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeterReadings.
     * @param {MeterReadingsCreateArgs} args - Arguments to create a MeterReadings.
     * @example
     * // Create one MeterReadings
     * const MeterReadings = await prisma.meterReadings.create({
     *   data: {
     *     // ... data to create a MeterReadings
     *   }
     * })
     * 
     */
    create<T extends MeterReadingsCreateArgs>(args: SelectSubset<T, MeterReadingsCreateArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeterReadings.
     * @param {MeterReadingsCreateManyArgs} args - Arguments to create many MeterReadings.
     * @example
     * // Create many MeterReadings
     * const meterReadings = await prisma.meterReadings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeterReadingsCreateManyArgs>(args?: SelectSubset<T, MeterReadingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MeterReadings.
     * @param {MeterReadingsDeleteArgs} args - Arguments to delete one MeterReadings.
     * @example
     * // Delete one MeterReadings
     * const MeterReadings = await prisma.meterReadings.delete({
     *   where: {
     *     // ... filter to delete one MeterReadings
     *   }
     * })
     * 
     */
    delete<T extends MeterReadingsDeleteArgs>(args: SelectSubset<T, MeterReadingsDeleteArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeterReadings.
     * @param {MeterReadingsUpdateArgs} args - Arguments to update one MeterReadings.
     * @example
     * // Update one MeterReadings
     * const meterReadings = await prisma.meterReadings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeterReadingsUpdateArgs>(args: SelectSubset<T, MeterReadingsUpdateArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeterReadings.
     * @param {MeterReadingsDeleteManyArgs} args - Arguments to filter MeterReadings to delete.
     * @example
     * // Delete a few MeterReadings
     * const { count } = await prisma.meterReadings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeterReadingsDeleteManyArgs>(args?: SelectSubset<T, MeterReadingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeterReadings
     * const meterReadings = await prisma.meterReadings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeterReadingsUpdateManyArgs>(args: SelectSubset<T, MeterReadingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeterReadings.
     * @param {MeterReadingsUpsertArgs} args - Arguments to update or create a MeterReadings.
     * @example
     * // Update or create a MeterReadings
     * const meterReadings = await prisma.meterReadings.upsert({
     *   create: {
     *     // ... data to create a MeterReadings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeterReadings we want to update
     *   }
     * })
     */
    upsert<T extends MeterReadingsUpsertArgs>(args: SelectSubset<T, MeterReadingsUpsertArgs<ExtArgs>>): Prisma__MeterReadingsClient<$Result.GetResult<Prisma.$MeterReadingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsCountArgs} args - Arguments to filter MeterReadings to count.
     * @example
     * // Count the number of MeterReadings
     * const count = await prisma.meterReadings.count({
     *   where: {
     *     // ... the filter for the MeterReadings we want to count
     *   }
     * })
    **/
    count<T extends MeterReadingsCountArgs>(
      args?: Subset<T, MeterReadingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeterReadingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeterReadingsAggregateArgs>(args: Subset<T, MeterReadingsAggregateArgs>): Prisma.PrismaPromise<GetMeterReadingsAggregateType<T>>

    /**
     * Group by MeterReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeterReadingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeterReadingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeterReadingsGroupByArgs['orderBy'] }
        : { orderBy?: MeterReadingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeterReadingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeterReadingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeterReadings model
   */
  readonly fields: MeterReadingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeterReadings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeterReadingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meter<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    first_reading_user<T extends MeterReadings$first_reading_userArgs<ExtArgs> = {}>(args?: Subset<T, MeterReadings$first_reading_userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    afternoon_reading_user<T extends MeterReadings$afternoon_reading_userArgs<ExtArgs> = {}>(args?: Subset<T, MeterReadings$afternoon_reading_userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    last_reading_user<T extends MeterReadings$last_reading_userArgs<ExtArgs> = {}>(args?: Subset<T, MeterReadings$last_reading_userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeterReadings model
   */
  interface MeterReadingsFieldRefs {
    readonly id: FieldRef<"MeterReadings", 'Int'>
    readonly meterId: FieldRef<"MeterReadings", 'Int'>
    readonly reading_date: FieldRef<"MeterReadings", 'DateTime'>
    readonly first_reading: FieldRef<"MeterReadings", 'String'>
    readonly first_reading_user_id: FieldRef<"MeterReadings", 'Int'>
    readonly first_reading_at: FieldRef<"MeterReadings", 'DateTime'>
    readonly afternoon_reading: FieldRef<"MeterReadings", 'String'>
    readonly afternoon_reading_user_id: FieldRef<"MeterReadings", 'Int'>
    readonly afternoon_reading_at: FieldRef<"MeterReadings", 'DateTime'>
    readonly last_reading: FieldRef<"MeterReadings", 'String'>
    readonly last_reading_user_id: FieldRef<"MeterReadings", 'Int'>
    readonly last_reading_at: FieldRef<"MeterReadings", 'DateTime'>
    readonly createdAt: FieldRef<"MeterReadings", 'DateTime'>
    readonly updatedAt: FieldRef<"MeterReadings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeterReadings findUnique
   */
  export type MeterReadingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter, which MeterReadings to fetch.
     */
    where: MeterReadingsWhereUniqueInput
  }

  /**
   * MeterReadings findUniqueOrThrow
   */
  export type MeterReadingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter, which MeterReadings to fetch.
     */
    where: MeterReadingsWhereUniqueInput
  }

  /**
   * MeterReadings findFirst
   */
  export type MeterReadingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter, which MeterReadings to fetch.
     */
    where?: MeterReadingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterReadings to fetch.
     */
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeterReadings.
     */
    cursor?: MeterReadingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeterReadings.
     */
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * MeterReadings findFirstOrThrow
   */
  export type MeterReadingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter, which MeterReadings to fetch.
     */
    where?: MeterReadingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterReadings to fetch.
     */
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeterReadings.
     */
    cursor?: MeterReadingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeterReadings.
     */
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * MeterReadings findMany
   */
  export type MeterReadingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter, which MeterReadings to fetch.
     */
    where?: MeterReadingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeterReadings to fetch.
     */
    orderBy?: MeterReadingsOrderByWithRelationInput | MeterReadingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeterReadings.
     */
    cursor?: MeterReadingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeterReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeterReadings.
     */
    skip?: number
    distinct?: MeterReadingsScalarFieldEnum | MeterReadingsScalarFieldEnum[]
  }

  /**
   * MeterReadings create
   */
  export type MeterReadingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * The data needed to create a MeterReadings.
     */
    data: XOR<MeterReadingsCreateInput, MeterReadingsUncheckedCreateInput>
  }

  /**
   * MeterReadings createMany
   */
  export type MeterReadingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeterReadings.
     */
    data: MeterReadingsCreateManyInput | MeterReadingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeterReadings update
   */
  export type MeterReadingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * The data needed to update a MeterReadings.
     */
    data: XOR<MeterReadingsUpdateInput, MeterReadingsUncheckedUpdateInput>
    /**
     * Choose, which MeterReadings to update.
     */
    where: MeterReadingsWhereUniqueInput
  }

  /**
   * MeterReadings updateMany
   */
  export type MeterReadingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeterReadings.
     */
    data: XOR<MeterReadingsUpdateManyMutationInput, MeterReadingsUncheckedUpdateManyInput>
    /**
     * Filter which MeterReadings to update
     */
    where?: MeterReadingsWhereInput
    /**
     * Limit how many MeterReadings to update.
     */
    limit?: number
  }

  /**
   * MeterReadings upsert
   */
  export type MeterReadingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * The filter to search for the MeterReadings to update in case it exists.
     */
    where: MeterReadingsWhereUniqueInput
    /**
     * In case the MeterReadings found by the `where` argument doesn't exist, create a new MeterReadings with this data.
     */
    create: XOR<MeterReadingsCreateInput, MeterReadingsUncheckedCreateInput>
    /**
     * In case the MeterReadings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeterReadingsUpdateInput, MeterReadingsUncheckedUpdateInput>
  }

  /**
   * MeterReadings delete
   */
  export type MeterReadingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
    /**
     * Filter which MeterReadings to delete.
     */
    where: MeterReadingsWhereUniqueInput
  }

  /**
   * MeterReadings deleteMany
   */
  export type MeterReadingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeterReadings to delete
     */
    where?: MeterReadingsWhereInput
    /**
     * Limit how many MeterReadings to delete.
     */
    limit?: number
  }

  /**
   * MeterReadings.first_reading_user
   */
  export type MeterReadings$first_reading_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * MeterReadings.afternoon_reading_user
   */
  export type MeterReadings$afternoon_reading_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * MeterReadings.last_reading_user
   */
  export type MeterReadings$last_reading_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * MeterReadings without action
   */
  export type MeterReadingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeterReadings
     */
    select?: MeterReadingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeterReadings
     */
    omit?: MeterReadingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeterReadingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BanneradsScalarFieldEnum: {
    id_ad: 'id_ad',
    title_ad: 'title_ad',
    descr_ad: 'descr_ad',
    adcode: 'adcode',
    file_ad: 'file_ad',
    topfile_ad: 'topfile_ad',
    url_ad: 'url_ad',
    banner_rank: 'banner_rank',
    addedon_ad: 'addedon_ad',
    startdate_ad: 'startdate_ad',
    enddate_ad: 'enddate_ad',
    daysno_ad: 'daysno_ad',
    width_ad: 'width_ad',
    height_ad: 'height_ad',
    position_ad: 'position_ad',
    banner_status: 'banner_status',
    visible_ad: 'visible_ad',
    userid_ad: 'userid_ad',
    username_ad: 'username_ad',
    paid: 'paid',
    amount: 'amount',
    datepaid: 'datepaid',
    remark: 'remark',
    views_ad: 'views_ad',
    clicks_ad: 'clicks_ad'
  };

  export type BanneradsScalarFieldEnum = (typeof BanneradsScalarFieldEnum)[keyof typeof BanneradsScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    artid: 'artid',
    artcategory: 'artcategory',
    title: 'title',
    titleslug: 'titleslug',
    brief: 'brief',
    fullcontent: 'fullcontent',
    artphoto: 'artphoto',
    artphotocaption: 'artphotocaption',
    author: 'author',
    artsource: 'artsource',
    artsource_url: 'artsource_url',
    published_date: 'published_date',
    artstatus: 'artstatus',
    nstatus: 'nstatus',
    views: 'views',
    artsubmit: 'artsubmit',
    artusername: 'artusername',
    youtube_embed: 'youtube_embed',
    vidurl: 'vidurl',
    homepage: 'homepage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const ContentpagesScalarFieldEnum: {
    cpageid: 'cpageid',
    cpagename: 'cpagename',
    cpagecontent: 'cpagecontent',
    cpagephoto: 'cpagephoto',
    cpagesbanner: 'cpagesbanner',
    cpagemenu: 'cpagemenu',
    cpagelinkname: 'cpagelinkname',
    cpage_postedby: 'cpage_postedby',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentpagesScalarFieldEnum = (typeof ContentpagesScalarFieldEnum)[keyof typeof ContentpagesScalarFieldEnum]


  export const Driver_paymentsScalarFieldEnum: {
    dpayid: 'dpayid',
    dpayref: 'dpayref',
    dpaydriver: 'dpaydriver',
    dpayoutstanding: 'dpayoutstanding',
    dpaypaystackref: 'dpaypaystackref',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Driver_paymentsScalarFieldEnum = (typeof Driver_paymentsScalarFieldEnum)[keyof typeof Driver_paymentsScalarFieldEnum]


  export const FaqsScalarFieldEnum: {
    faqid: 'faqid',
    faqcat: 'faqcat',
    faqquestion: 'faqquestion',
    faqanswer: 'faqanswer',
    faqslug: 'faqslug',
    faqpostedby: 'faqpostedby',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FaqsScalarFieldEnum = (typeof FaqsScalarFieldEnum)[keyof typeof FaqsScalarFieldEnum]


  export const Loc_statesScalarFieldEnum: {
    stateid: 'stateid',
    state: 'state'
  };

  export type Loc_statesScalarFieldEnum = (typeof Loc_statesScalarFieldEnum)[keyof typeof Loc_statesScalarFieldEnum]


  export const Media_assetsScalarFieldEnum: {
    massetid: 'massetid',
    masset: 'masset',
    massetdate: 'massetdate'
  };

  export type Media_assetsScalarFieldEnum = (typeof Media_assetsScalarFieldEnum)[keyof typeof Media_assetsScalarFieldEnum]


  export const NewsletterScalarFieldEnum: {
    nlid: 'nlid',
    nlname: 'nlname',
    nlemail: 'nlemail',
    nlstatus: 'nlstatus',
    nl_received: 'nl_received',
    nl_id: 'nl_id'
  };

  export type NewsletterScalarFieldEnum = (typeof NewsletterScalarFieldEnum)[keyof typeof NewsletterScalarFieldEnum]


  export const Newsletter_bodyScalarFieldEnum: {
    nlb_id: 'nlb_id',
    nlb_title: 'nlb_title',
    nlb_story: 'nlb_story',
    nlb_finished: 'nlb_finished',
    nlb_postedby: 'nlb_postedby',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Newsletter_bodyScalarFieldEnum = (typeof Newsletter_bodyScalarFieldEnum)[keyof typeof Newsletter_bodyScalarFieldEnum]


  export const PaystackresponseScalarFieldEnum: {
    prid: 'prid',
    prbody: 'prbody',
    pracc_number: 'pracc_number',
    pracc_bank: 'pracc_bank',
    createdAt: 'createdAt'
  };

  export type PaystackresponseScalarFieldEnum = (typeof PaystackresponseScalarFieldEnum)[keyof typeof PaystackresponseScalarFieldEnum]


  export const ProductcategoriesScalarFieldEnum: {
    pcid: 'pcid',
    pcatname: 'pcatname',
    pcatslug: 'pcatslug',
    pcatpicture: 'pcatpicture',
    pcatdesc: 'pcatdesc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductcategoriesScalarFieldEnum = (typeof ProductcategoriesScalarFieldEnum)[keyof typeof ProductcategoriesScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    category: 'category',
    catslug: 'catslug',
    uuid: 'uuid',
    name: 'name',
    nameslug: 'nameslug',
    sku: 'sku',
    description: 'description',
    picture: 'picture',
    price: 'price',
    size: 'size',
    response_time: 'response_time',
    status: 'status',
    payment_account: 'payment_account',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const RequestsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    orderid: 'orderid',
    orderref: 'orderref',
    orderdetails: 'orderdetails',
    req_type: 'req_type',
    task: 'task',
    howmany: 'howmany',
    productid: 'productid',
    productname: 'productname',
    prod_waittime: 'prod_waittime',
    amount: 'amount',
    commission: 'commission',
    customerid: 'customerid',
    customername: 'customername',
    customerphone: 'customerphone',
    customeraddress: 'customeraddress',
    customerarea: 'customerarea',
    customerareagroup: 'customerareagroup',
    third_party_delivery: 'third_party_delivery',
    third_party_name: 'third_party_name',
    third_party_phone: 'third_party_phone',
    third_party_areagroup: 'third_party_areagroup',
    third_party_address: 'third_party_address',
    customerlatitude: 'customerlatitude',
    customerlongitude: 'customerlongitude',
    address: 'address',
    driverid: 'driverid',
    drivername: 'drivername',
    driverphone: 'driverphone',
    driveremail: 'driveremail',
    drivervehicleplateno: 'drivervehicleplateno',
    status: 'status',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestsScalarFieldEnum = (typeof RequestsScalarFieldEnum)[keyof typeof RequestsScalarFieldEnum]


  export const ShopinfoScalarFieldEnum: {
    shopid: 'shopid',
    shopname: 'shopname',
    shopdescription: 'shopdescription',
    driver_commission: 'driver_commission',
    water_merchant_commission: 'water_merchant_commission',
    shoplogo: 'shoplogo',
    shmetakey: 'shmetakey',
    shmetadesc: 'shmetadesc',
    shopphone: 'shopphone',
    shopemailname: 'shopemailname',
    shopemailaddress: 'shopemailaddress',
    shoporderemail: 'shoporderemail',
    shopaddress: 'shopaddress',
    shopcity: 'shopcity',
    shopstate: 'shopstate',
    shopcountry: 'shopcountry',
    latestonhome: 'latestonhome',
    offline: 'offline',
    offlinemsg: 'offlinemsg',
    shopimage: 'shopimage',
    total_news: 'total_news',
    slfacebook: 'slfacebook',
    sltwitter: 'sltwitter',
    slinstagram: 'slinstagram',
    slyoutube: 'slyoutube',
    postedby: 'postedby',
    updatedAt: 'updatedAt'
  };

  export type ShopinfoScalarFieldEnum = (typeof ShopinfoScalarFieldEnum)[keyof typeof ShopinfoScalarFieldEnum]


  export const SociallinksScalarFieldEnum: {
    slid: 'slid',
    slimage: 'slimage',
    sladdress: 'sladdress'
  };

  export type SociallinksScalarFieldEnum = (typeof SociallinksScalarFieldEnum)[keyof typeof SociallinksScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    submagid: 'submagid',
    sm_title: 'sm_title',
    sm_initials: 'sm_initials',
    sm_surname: 'sm_surname',
    sm_business: 'sm_business',
    sm_address: 'sm_address',
    sm_postcode: 'sm_postcode',
    sm_country: 'sm_country',
    sm_telephone: 'sm_telephone',
    sm_email: 'sm_email',
    sm_dateposted: 'sm_dateposted',
    sm_amount: 'sm_amount',
    sm_paid: 'sm_paid',
    sm_datepaid: 'sm_datepaid',
    sm_from: 'sm_from',
    sm_to: 'sm_to'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const Team_categoryScalarFieldEnum: {
    teamcategoryid: 'teamcategoryid',
    teamcategory: 'teamcategory',
    teamcat_slug: 'teamcat_slug'
  };

  export type Team_categoryScalarFieldEnum = (typeof Team_categoryScalarFieldEnum)[keyof typeof Team_categoryScalarFieldEnum]


  export const Team_membersScalarFieldEnum: {
    tmemberid: 'tmemberid',
    tmcategory: 'tmcategory',
    tmember: 'tmember',
    tmember_slug: 'tmember_slug',
    tmemberposition: 'tmemberposition',
    tmemberphoto: 'tmemberphoto',
    tmemberprofile: 'tmemberprofile',
    tmembersummary: 'tmembersummary',
    tmemberdateadded: 'tmemberdateadded',
    tmemberpostedby: 'tmemberpostedby',
    tmemberrank: 'tmemberrank',
    tmember_email: 'tmember_email',
    tmember_phone: 'tmember_phone',
    tmember_facebook: 'tmember_facebook',
    tmember_twitter: 'tmember_twitter',
    tmember_linkedin: 'tmember_linkedin',
    tmember_instagram: 'tmember_instagram'
  };

  export type Team_membersScalarFieldEnum = (typeof Team_membersScalarFieldEnum)[keyof typeof Team_membersScalarFieldEnum]


  export const TestimonialsScalarFieldEnum: {
    tid: 'tid',
    tcustomer: 'tcustomer',
    trole: 'trole',
    tphoto: 'tphoto',
    tmessage: 'tmessage',
    tstars: 'tstars',
    tdate: 'tdate',
    tstatus: 'tstatus'
  };

  export type TestimonialsScalarFieldEnum = (typeof TestimonialsScalarFieldEnum)[keyof typeof TestimonialsScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    orderref: 'orderref',
    productid: 'productid',
    productname: 'productname',
    prod_waittime: 'prod_waittime',
    product_subscription: 'product_subscription',
    qty: 'qty',
    orderdetails: 'orderdetails',
    req_type: 'req_type',
    task: 'task',
    howmany: 'howmany',
    amount: 'amount',
    commission: 'commission',
    driverfee: 'driverfee',
    driverid: 'driverid',
    drivername: 'drivername',
    driverphone: 'driverphone',
    driveremail: 'driveremail',
    drivervehicleplateno: 'drivervehicleplateno',
    driverphoto: 'driverphoto',
    fleetid: 'fleetid',
    driverlatitude: 'driverlatitude',
    driverlongitude: 'driverlongitude',
    driveraccept: 'driveraccept',
    customerid: 'customerid',
    customername: 'customername',
    customeremail: 'customeremail',
    customerphone: 'customerphone',
    customeraddress: 'customeraddress',
    customerarea: 'customerarea',
    customerareagroup: 'customerareagroup',
    third_party_delivery: 'third_party_delivery',
    third_party_name: 'third_party_name',
    third_party_phone: 'third_party_phone',
    third_party_areagroup: 'third_party_areagroup',
    third_party_address: 'third_party_address',
    customerlatitude: 'customerlatitude',
    customerlongitude: 'customerlongitude',
    status: 'status',
    paymentstatus: 'paymentstatus',
    paymentmode: 'paymentmode',
    paymenttime: 'paymenttime',
    driverdeliverystatus: 'driverdeliverystatus',
    driverdeliverystatustime: 'driverdeliverystatustime',
    driverdeliverytime: 'driverdeliverytime',
    customerdeliverystatus: 'customerdeliverystatus',
    customerdeliverystatustime: 'customerdeliverystatustime',
    customerwaittime: 'customerwaittime',
    orderprocessed: 'orderprocessed',
    commission_paid: 'commission_paid',
    driverrating: 'driverrating',
    driverfeedback: 'driverfeedback',
    notes: 'notes',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const UsermessagesScalarFieldEnum: {
    umsgid: 'umsgid',
    umsg_user: 'umsg_user',
    umsg_cat: 'umsg_cat',
    umsg_title: 'umsg_title',
    umsg_body: 'umsg_body',
    umsg_read: 'umsg_read',
    umsg_time: 'umsg_time',
    umsg_sender: 'umsg_sender'
  };

  export type UsermessagesScalarFieldEnum = (typeof UsermessagesScalarFieldEnum)[keyof typeof UsermessagesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    fleetid: 'fleetid',
    name: 'name',
    first_name: 'first_name',
    last_name: 'last_name',
    username: 'username',
    email: 'email',
    password: 'password',
    phone: 'phone',
    dob: 'dob',
    subscription_plan: 'subscription_plan',
    subscription_end: 'subscription_end',
    address: 'address',
    area: 'area',
    areagroup: 'areagroup',
    residencestate: 'residencestate',
    latitude: 'latitude',
    longitude: 'longitude',
    role: 'role',
    user_type: 'user_type',
    expotoken: 'expotoken',
    photo: 'photo',
    identification: 'identification',
    identification_back: 'identification_back',
    drv_license: 'drv_license',
    drv_license_back: 'drv_license_back',
    drv_vehicle_license_plate_no: 'drv_vehicle_license_plate_no',
    drv_vehicle_capacity: 'drv_vehicle_capacity',
    drv_vehicle_make: 'drv_vehicle_make',
    drv_vehicle_meterid: 'drv_vehicle_meterid',
    drv_account_name: 'drv_account_name',
    drv_account_no: 'drv_account_no',
    drv_bank: 'drv_bank',
    psv_customer_name: 'psv_customer_name',
    psv_account_name: 'psv_account_name',
    psv_account_number: 'psv_account_number',
    psv_bank: 'psv_bank',
    isverified: 'isverified',
    verifiedby: 'verifiedby',
    isavailable: 'isavailable',
    isavailable_by: 'isavailable_by',
    isavailable_reason: 'isavailable_reason',
    commissions_outstanding: 'commissions_outstanding',
    commission_payment_ref: 'commission_payment_ref',
    isactive: 'isactive',
    isadmin: 'isadmin',
    terms: 'terms',
    enable2fa: 'enable2fa',
    code2fa: 'code2fa',
    expiry2fa: 'expiry2fa',
    signupotp: 'signupotp',
    wm_wait_list: 'wm_wait_list',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VideocatScalarFieldEnum: {
    vidcatid: 'vidcatid',
    vidcat: 'vidcat'
  };

  export type VideocatScalarFieldEnum = (typeof VideocatScalarFieldEnum)[keyof typeof VideocatScalarFieldEnum]


  export const VideosScalarFieldEnum: {
    videntryid: 'videntryid',
    vcatid: 'vcatid',
    vidcategory: 'vidcategory',
    vidtitle: 'vidtitle',
    viddesc: 'viddesc',
    vidurl: 'vidurl',
    vidembed: 'vidembed',
    vidpostedby: 'vidpostedby',
    vidtimeposted: 'vidtimeposted',
    vidhits: 'vidhits',
    vidextra: 'vidextra'
  };

  export type VideosScalarFieldEnum = (typeof VideosScalarFieldEnum)[keyof typeof VideosScalarFieldEnum]


  export const Meter_domestic_entriesScalarFieldEnum: {
    mdid: 'mdid',
    md_unique_id: 'md_unique_id',
    md_userid: 'md_userid',
    md_area: 'md_area',
    md_consumption_rate: 'md_consumption_rate',
    md_volume_received: 'md_volume_received',
    md_valve_state: 'md_valve_state',
    createdAt: 'createdAt'
  };

  export type Meter_domestic_entriesScalarFieldEnum = (typeof Meter_domestic_entriesScalarFieldEnum)[keyof typeof Meter_domestic_entriesScalarFieldEnum]


  export const Meter_supply_entriesScalarFieldEnum: {
    msid: 'msid',
    ms_unique_id: 'ms_unique_id',
    ms_userid: 'ms_userid',
    ms_supply_rate: 'ms_supply_rate',
    ms_volume_supplied: 'ms_volume_supplied',
    ms_temperature_c: 'ms_temperature_c',
    ms_temperature_f: 'ms_temperature_f',
    ms_turbidity_level: 'ms_turbidity_level',
    ms_ph_level: 'ms_ph_level',
    ms_valve_state: 'ms_valve_state',
    createdAt: 'createdAt'
  };

  export type Meter_supply_entriesScalarFieldEnum = (typeof Meter_supply_entriesScalarFieldEnum)[keyof typeof Meter_supply_entriesScalarFieldEnum]


  export const Meter_tanker_entriesScalarFieldEnum: {
    mtid: 'mtid',
    mt_unique_id: 'mt_unique_id',
    mt_tankerid: 'mt_tankerid',
    mt_delivery_rate: 'mt_delivery_rate',
    mt_volume_delivered: 'mt_volume_delivered',
    mt_valve_state: 'mt_valve_state',
    createdAt: 'createdAt'
  };

  export type Meter_tanker_entriesScalarFieldEnum = (typeof Meter_tanker_entriesScalarFieldEnum)[keyof typeof Meter_tanker_entriesScalarFieldEnum]


  export const MetersScalarFieldEnum: {
    meterid: 'meterid',
    m_account_number: 'm_account_number',
    m_unique_id: 'm_unique_id',
    m_for: 'm_for',
    m_assigned: 'm_assigned',
    m_assigned_to: 'm_assigned_to',
    m_assigned_name: 'm_assigned_name',
    m_assigned_phone: 'm_assigned_phone',
    m_assigned_address: 'm_assigned_address',
    m_area: 'm_area',
    m_status: 'm_status',
    m_valve_state: 'm_valve_state',
    m_water_unit_price: 'm_water_unit_price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetersScalarFieldEnum = (typeof MetersScalarFieldEnum)[keyof typeof MetersScalarFieldEnum]


  export const Contact_messagesScalarFieldEnum: {
    cid: 'cid',
    cname: 'cname',
    cphone: 'cphone',
    cemail: 'cemail',
    csubject: 'csubject',
    cmessage: 'cmessage',
    cstatus: 'cstatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Contact_messagesScalarFieldEnum = (typeof Contact_messagesScalarFieldEnum)[keyof typeof Contact_messagesScalarFieldEnum]


  export const Meter_numbersScalarFieldEnum: {
    meter_uuid_id: 'meter_uuid_id',
    meter_type: 'meter_type',
    meter_uuid: 'meter_uuid',
    meter_uuid_used: 'meter_uuid_used',
    meter_assigned: 'meter_assigned',
    createdAt: 'createdAt'
  };

  export type Meter_numbersScalarFieldEnum = (typeof Meter_numbersScalarFieldEnum)[keyof typeof Meter_numbersScalarFieldEnum]


  export const DriverequestsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    orderid: 'orderid',
    customerid: 'customerid',
    address: 'address',
    driverid: 'driverid',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverequestsScalarFieldEnum = (typeof DriverequestsScalarFieldEnum)[keyof typeof DriverequestsScalarFieldEnum]


  export const Order_tableScalarFieldEnum: {
    order_id: 'order_id',
    order_trans_id: 'order_trans_id',
    username: 'username',
    order_date: 'order_date',
    order_time: 'order_time',
    status: 'status',
    customercomment: 'customercomment',
    notes: 'notes',
    shipping_first_name: 'shipping_first_name',
    shipping_last_name: 'shipping_last_name',
    shipping_address1: 'shipping_address1',
    shipping_address2: 'shipping_address2',
    shipping_phone: 'shipping_phone',
    shipping_email: 'shipping_email',
    shipping_city: 'shipping_city',
    shipping_state: 'shipping_state',
    shipping_country: 'shipping_country',
    order_total: 'order_total',
    delivery_type: 'delivery_type',
    shipping_cost: 'shipping_cost',
    grandtotal: 'grandtotal',
    gatewayid: 'gatewayid',
    gwtranxid: 'gwtranxid',
    gwcustid: 'gwcustid',
    gwtranxamt: 'gwtranxamt',
    gwstatuscode: 'gwstatuscode',
    gwstatusmsg: 'gwstatusmsg',
    o_sesid: 'o_sesid',
    last_update_by: 'last_update_by',
    order_stage: 'order_stage',
    shipping_option: 'shipping_option',
    payment_option: 'payment_option',
    payment_status: 'payment_status'
  };

  export type Order_tableScalarFieldEnum = (typeof Order_tableScalarFieldEnum)[keyof typeof Order_tableScalarFieldEnum]


  export const PackagesScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    sku: 'sku',
    description: 'description',
    picture: 'picture',
    price: 'price',
    size: 'size',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackagesScalarFieldEnum = (typeof PackagesScalarFieldEnum)[keyof typeof PackagesScalarFieldEnum]


  export const RatingsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    orderid: 'orderid',
    driverid: 'driverid',
    stars: 'stars',
    comment: 'comment',
    customerid: 'customerid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingsScalarFieldEnum = (typeof RatingsScalarFieldEnum)[keyof typeof RatingsScalarFieldEnum]


  export const UsercatScalarFieldEnum: {
    usercatid: 'usercatid',
    usercategory: 'usercategory',
    usercatdesc: 'usercatdesc'
  };

  export type UsercatScalarFieldEnum = (typeof UsercatScalarFieldEnum)[keyof typeof UsercatScalarFieldEnum]


  export const Complaints_repliesScalarFieldEnum: {
    creplyid: 'creplyid',
    complaintid: 'complaintid',
    creplysubject: 'creplysubject',
    creplyname: 'creplyname',
    creplyphone: 'creplyphone',
    creplymessage: 'creplymessage',
    createdAt: 'createdAt'
  };

  export type Complaints_repliesScalarFieldEnum = (typeof Complaints_repliesScalarFieldEnum)[keyof typeof Complaints_repliesScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    subplanid: 'subplanid',
    subplantype: 'subplantype',
    subplanusername: 'subplanusername',
    subplanamt: 'subplanamt',
    subplan_from: 'subplan_from',
    subplan_to: 'subplan_to',
    subplan_status: 'subplan_status',
    subplan_pay_status: 'subplan_pay_status',
    subplan_area: 'subplan_area',
    subplan_admin: 'subplan_admin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const TrucksScalarFieldEnum: {
    truckid: 'truckid',
    truck_make: 'truck_make',
    truck_plateno: 'truck_plateno',
    truck_fleetowner: 'truck_fleetowner',
    truck_meterid: 'truck_meterid',
    truck_driver: 'truck_driver',
    truck_status: 'truck_status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrucksScalarFieldEnum = (typeof TrucksScalarFieldEnum)[keyof typeof TrucksScalarFieldEnum]


  export const Area_groupsScalarFieldEnum: {
    agid: 'agid',
    agname: 'agname',
    agareas: 'agareas'
  };

  export type Area_groupsScalarFieldEnum = (typeof Area_groupsScalarFieldEnum)[keyof typeof Area_groupsScalarFieldEnum]


  export const Product_prices_areasScalarFieldEnum: {
    ppid: 'ppid',
    ppa_pid: 'ppa_pid',
    pparea: 'pparea',
    pp_subscription: 'pp_subscription',
    pp_rate: 'pp_rate'
  };

  export type Product_prices_areasScalarFieldEnum = (typeof Product_prices_areasScalarFieldEnum)[keyof typeof Product_prices_areasScalarFieldEnum]


  export const ArticlesScalarFieldEnum: {
    artid: 'artid',
    artcategory: 'artcategory',
    title: 'title',
    titleslug: 'titleslug',
    fullcontent: 'fullcontent',
    mkeys: 'mkeys',
    mdesc: 'mdesc',
    artsource: 'artsource',
    artsource_url: 'artsource_url',
    artphoto: 'artphoto',
    artphotocaption: 'artphotocaption',
    artphotourl: 'artphotourl',
    author: 'author',
    artstatus: 'artstatus',
    views: 'views',
    published_date: 'published_date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticlesScalarFieldEnum = (typeof ArticlesScalarFieldEnum)[keyof typeof ArticlesScalarFieldEnum]


  export const Subscription_plansScalarFieldEnum: {
    subplanid: 'subplanid',
    subplan_cat: 'subplan_cat',
    subplan: 'subplan',
    subplan_amount: 'subplan_amount',
    subplan_months: 'subplan_months',
    subplan_include: 'subplan_include',
    subplan_exclude: 'subplan_exclude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Subscription_plansScalarFieldEnum = (typeof Subscription_plansScalarFieldEnum)[keyof typeof Subscription_plansScalarFieldEnum]


  export const VendorreportsScalarFieldEnum: {
    id: 'id',
    customerid: 'customerid',
    customername: 'customername',
    vendorid: 'vendorid',
    plateno: 'plateno',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorreportsScalarFieldEnum = (typeof VendorreportsScalarFieldEnum)[keyof typeof VendorreportsScalarFieldEnum]


  export const Water_purchasesScalarFieldEnum: {
    wpid: 'wpid',
    wp_orderref: 'wp_orderref',
    wp_type: 'wp_type',
    wp_merchant_id: 'wp_merchant_id',
    wp_merchant_name: 'wp_merchant_name',
    wp_merchant_address: 'wp_merchant_address',
    wp_merchant_latitude: 'wp_merchant_latitude',
    wp_merchant_longitude: 'wp_merchant_longitude',
    wp_volume: 'wp_volume',
    wp_amount: 'wp_amount',
    wp_commission: 'wp_commission',
    wp_owner_amount: 'wp_owner_amount',
    wp_driver_id: 'wp_driver_id',
    wp_driver_name: 'wp_driver_name',
    wp_driver_latitude: 'wp_driver_latitude',
    wp_driver_longitude: 'wp_driver_longitude',
    wp_fleetid: 'wp_fleetid',
    wp_remark: 'wp_remark',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Water_purchasesScalarFieldEnum = (typeof Water_purchasesScalarFieldEnum)[keyof typeof Water_purchasesScalarFieldEnum]


  export const MeterReadingsScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    reading_date: 'reading_date',
    first_reading: 'first_reading',
    first_reading_user_id: 'first_reading_user_id',
    first_reading_at: 'first_reading_at',
    afternoon_reading: 'afternoon_reading',
    afternoon_reading_user_id: 'afternoon_reading_user_id',
    afternoon_reading_at: 'afternoon_reading_at',
    last_reading: 'last_reading',
    last_reading_user_id: 'last_reading_user_id',
    last_reading_at: 'last_reading_at',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeterReadingsScalarFieldEnum = (typeof MeterReadingsScalarFieldEnum)[keyof typeof MeterReadingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const banneradsOrderByRelevanceFieldEnum: {
    title_ad: 'title_ad',
    descr_ad: 'descr_ad',
    adcode: 'adcode',
    file_ad: 'file_ad',
    topfile_ad: 'topfile_ad',
    url_ad: 'url_ad',
    daysno_ad: 'daysno_ad',
    width_ad: 'width_ad',
    height_ad: 'height_ad',
    position_ad: 'position_ad',
    banner_status: 'banner_status',
    userid_ad: 'userid_ad',
    username_ad: 'username_ad',
    remark: 'remark'
  };

  export type banneradsOrderByRelevanceFieldEnum = (typeof banneradsOrderByRelevanceFieldEnum)[keyof typeof banneradsOrderByRelevanceFieldEnum]


  export const blogOrderByRelevanceFieldEnum: {
    artcategory: 'artcategory',
    title: 'title',
    titleslug: 'titleslug',
    brief: 'brief',
    fullcontent: 'fullcontent',
    artphoto: 'artphoto',
    artphotocaption: 'artphotocaption',
    author: 'author',
    artsource: 'artsource',
    artsource_url: 'artsource_url',
    artstatus: 'artstatus',
    nstatus: 'nstatus',
    artusername: 'artusername',
    youtube_embed: 'youtube_embed',
    vidurl: 'vidurl'
  };

  export type blogOrderByRelevanceFieldEnum = (typeof blogOrderByRelevanceFieldEnum)[keyof typeof blogOrderByRelevanceFieldEnum]


  export const contentpagesOrderByRelevanceFieldEnum: {
    cpagename: 'cpagename',
    cpagecontent: 'cpagecontent',
    cpagephoto: 'cpagephoto',
    cpagesbanner: 'cpagesbanner',
    cpagemenu: 'cpagemenu',
    cpagelinkname: 'cpagelinkname',
    cpage_postedby: 'cpage_postedby'
  };

  export type contentpagesOrderByRelevanceFieldEnum = (typeof contentpagesOrderByRelevanceFieldEnum)[keyof typeof contentpagesOrderByRelevanceFieldEnum]


  export const driver_paymentsOrderByRelevanceFieldEnum: {
    dpayref: 'dpayref',
    dpaypaystackref: 'dpaypaystackref'
  };

  export type driver_paymentsOrderByRelevanceFieldEnum = (typeof driver_paymentsOrderByRelevanceFieldEnum)[keyof typeof driver_paymentsOrderByRelevanceFieldEnum]


  export const faqsOrderByRelevanceFieldEnum: {
    faqcat: 'faqcat',
    faqquestion: 'faqquestion',
    faqanswer: 'faqanswer',
    faqslug: 'faqslug',
    faqpostedby: 'faqpostedby'
  };

  export type faqsOrderByRelevanceFieldEnum = (typeof faqsOrderByRelevanceFieldEnum)[keyof typeof faqsOrderByRelevanceFieldEnum]


  export const loc_statesOrderByRelevanceFieldEnum: {
    state: 'state'
  };

  export type loc_statesOrderByRelevanceFieldEnum = (typeof loc_statesOrderByRelevanceFieldEnum)[keyof typeof loc_statesOrderByRelevanceFieldEnum]


  export const media_assetsOrderByRelevanceFieldEnum: {
    masset: 'masset'
  };

  export type media_assetsOrderByRelevanceFieldEnum = (typeof media_assetsOrderByRelevanceFieldEnum)[keyof typeof media_assetsOrderByRelevanceFieldEnum]


  export const newsletterOrderByRelevanceFieldEnum: {
    nlname: 'nlname',
    nlemail: 'nlemail'
  };

  export type newsletterOrderByRelevanceFieldEnum = (typeof newsletterOrderByRelevanceFieldEnum)[keyof typeof newsletterOrderByRelevanceFieldEnum]


  export const newsletter_bodyOrderByRelevanceFieldEnum: {
    nlb_title: 'nlb_title',
    nlb_story: 'nlb_story',
    nlb_finished: 'nlb_finished',
    nlb_postedby: 'nlb_postedby'
  };

  export type newsletter_bodyOrderByRelevanceFieldEnum = (typeof newsletter_bodyOrderByRelevanceFieldEnum)[keyof typeof newsletter_bodyOrderByRelevanceFieldEnum]


  export const paystackresponseOrderByRelevanceFieldEnum: {
    prbody: 'prbody',
    pracc_number: 'pracc_number',
    pracc_bank: 'pracc_bank'
  };

  export type paystackresponseOrderByRelevanceFieldEnum = (typeof paystackresponseOrderByRelevanceFieldEnum)[keyof typeof paystackresponseOrderByRelevanceFieldEnum]


  export const productcategoriesOrderByRelevanceFieldEnum: {
    pcatname: 'pcatname',
    pcatslug: 'pcatslug',
    pcatpicture: 'pcatpicture',
    pcatdesc: 'pcatdesc'
  };

  export type productcategoriesOrderByRelevanceFieldEnum = (typeof productcategoriesOrderByRelevanceFieldEnum)[keyof typeof productcategoriesOrderByRelevanceFieldEnum]


  export const productsOrderByRelevanceFieldEnum: {
    category: 'category',
    catslug: 'catslug',
    uuid: 'uuid',
    name: 'name',
    nameslug: 'nameslug',
    sku: 'sku',
    description: 'description',
    picture: 'picture',
    size: 'size',
    response_time: 'response_time',
    payment_account: 'payment_account'
  };

  export type productsOrderByRelevanceFieldEnum = (typeof productsOrderByRelevanceFieldEnum)[keyof typeof productsOrderByRelevanceFieldEnum]


  export const requestsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    orderref: 'orderref',
    orderdetails: 'orderdetails',
    req_type: 'req_type',
    task: 'task',
    productname: 'productname',
    customername: 'customername',
    customerphone: 'customerphone',
    customeraddress: 'customeraddress',
    customerarea: 'customerarea',
    customerareagroup: 'customerareagroup',
    third_party_delivery: 'third_party_delivery',
    third_party_name: 'third_party_name',
    third_party_phone: 'third_party_phone',
    third_party_areagroup: 'third_party_areagroup',
    third_party_address: 'third_party_address',
    address: 'address',
    drivername: 'drivername',
    driverphone: 'driverphone',
    driveremail: 'driveremail',
    drivervehicleplateno: 'drivervehicleplateno',
    status: 'status'
  };

  export type requestsOrderByRelevanceFieldEnum = (typeof requestsOrderByRelevanceFieldEnum)[keyof typeof requestsOrderByRelevanceFieldEnum]


  export const shopinfoOrderByRelevanceFieldEnum: {
    shopname: 'shopname',
    shopdescription: 'shopdescription',
    shoplogo: 'shoplogo',
    shmetakey: 'shmetakey',
    shmetadesc: 'shmetadesc',
    shopphone: 'shopphone',
    shopemailname: 'shopemailname',
    shopemailaddress: 'shopemailaddress',
    shoporderemail: 'shoporderemail',
    shopaddress: 'shopaddress',
    shopcity: 'shopcity',
    shopstate: 'shopstate',
    shopcountry: 'shopcountry',
    offlinemsg: 'offlinemsg',
    shopimage: 'shopimage',
    slfacebook: 'slfacebook',
    sltwitter: 'sltwitter',
    slinstagram: 'slinstagram',
    slyoutube: 'slyoutube',
    postedby: 'postedby'
  };

  export type shopinfoOrderByRelevanceFieldEnum = (typeof shopinfoOrderByRelevanceFieldEnum)[keyof typeof shopinfoOrderByRelevanceFieldEnum]


  export const sociallinksOrderByRelevanceFieldEnum: {
    slimage: 'slimage',
    sladdress: 'sladdress'
  };

  export type sociallinksOrderByRelevanceFieldEnum = (typeof sociallinksOrderByRelevanceFieldEnum)[keyof typeof sociallinksOrderByRelevanceFieldEnum]


  export const subscriptionOrderByRelevanceFieldEnum: {
    sm_title: 'sm_title',
    sm_initials: 'sm_initials',
    sm_surname: 'sm_surname',
    sm_business: 'sm_business',
    sm_address: 'sm_address',
    sm_postcode: 'sm_postcode',
    sm_country: 'sm_country',
    sm_telephone: 'sm_telephone',
    sm_email: 'sm_email',
    sm_amount: 'sm_amount',
    sm_paid: 'sm_paid',
    sm_datepaid: 'sm_datepaid',
    sm_from: 'sm_from',
    sm_to: 'sm_to'
  };

  export type subscriptionOrderByRelevanceFieldEnum = (typeof subscriptionOrderByRelevanceFieldEnum)[keyof typeof subscriptionOrderByRelevanceFieldEnum]


  export const team_categoryOrderByRelevanceFieldEnum: {
    teamcategory: 'teamcategory',
    teamcat_slug: 'teamcat_slug'
  };

  export type team_categoryOrderByRelevanceFieldEnum = (typeof team_categoryOrderByRelevanceFieldEnum)[keyof typeof team_categoryOrderByRelevanceFieldEnum]


  export const team_membersOrderByRelevanceFieldEnum: {
    tmcategory: 'tmcategory',
    tmember: 'tmember',
    tmember_slug: 'tmember_slug',
    tmemberposition: 'tmemberposition',
    tmemberphoto: 'tmemberphoto',
    tmemberprofile: 'tmemberprofile',
    tmembersummary: 'tmembersummary',
    tmemberpostedby: 'tmemberpostedby',
    tmember_email: 'tmember_email',
    tmember_phone: 'tmember_phone',
    tmember_facebook: 'tmember_facebook',
    tmember_twitter: 'tmember_twitter',
    tmember_linkedin: 'tmember_linkedin',
    tmember_instagram: 'tmember_instagram'
  };

  export type team_membersOrderByRelevanceFieldEnum = (typeof team_membersOrderByRelevanceFieldEnum)[keyof typeof team_membersOrderByRelevanceFieldEnum]


  export const testimonialsOrderByRelevanceFieldEnum: {
    tcustomer: 'tcustomer',
    trole: 'trole',
    tphoto: 'tphoto',
    tmessage: 'tmessage'
  };

  export type testimonialsOrderByRelevanceFieldEnum = (typeof testimonialsOrderByRelevanceFieldEnum)[keyof typeof testimonialsOrderByRelevanceFieldEnum]


  export const transactionsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    orderref: 'orderref',
    productname: 'productname',
    product_subscription: 'product_subscription',
    orderdetails: 'orderdetails',
    req_type: 'req_type',
    task: 'task',
    driverid: 'driverid',
    drivername: 'drivername',
    driverphone: 'driverphone',
    driveremail: 'driveremail',
    drivervehicleplateno: 'drivervehicleplateno',
    driverphoto: 'driverphoto',
    fleetid: 'fleetid',
    driveraccept: 'driveraccept',
    customerid: 'customerid',
    customername: 'customername',
    customeremail: 'customeremail',
    customerphone: 'customerphone',
    customeraddress: 'customeraddress',
    customerarea: 'customerarea',
    customerareagroup: 'customerareagroup',
    third_party_delivery: 'third_party_delivery',
    third_party_name: 'third_party_name',
    third_party_phone: 'third_party_phone',
    third_party_areagroup: 'third_party_areagroup',
    third_party_address: 'third_party_address',
    status: 'status',
    paymentstatus: 'paymentstatus',
    paymentmode: 'paymentmode',
    paymenttime: 'paymenttime',
    driverdeliverystatus: 'driverdeliverystatus',
    driverdeliverystatustime: 'driverdeliverystatustime',
    customerdeliverystatus: 'customerdeliverystatus',
    customerdeliverystatustime: 'customerdeliverystatustime',
    driverfeedback: 'driverfeedback',
    notes: 'notes'
  };

  export type transactionsOrderByRelevanceFieldEnum = (typeof transactionsOrderByRelevanceFieldEnum)[keyof typeof transactionsOrderByRelevanceFieldEnum]


  export const usermessagesOrderByRelevanceFieldEnum: {
    umsg_user: 'umsg_user',
    umsg_cat: 'umsg_cat',
    umsg_title: 'umsg_title',
    umsg_body: 'umsg_body',
    umsg_sender: 'umsg_sender'
  };

  export type usermessagesOrderByRelevanceFieldEnum = (typeof usermessagesOrderByRelevanceFieldEnum)[keyof typeof usermessagesOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    name: 'name',
    first_name: 'first_name',
    last_name: 'last_name',
    username: 'username',
    email: 'email',
    password: 'password',
    phone: 'phone',
    dob: 'dob',
    subscription_plan: 'subscription_plan',
    address: 'address',
    area: 'area',
    areagroup: 'areagroup',
    residencestate: 'residencestate',
    role: 'role',
    user_type: 'user_type',
    expotoken: 'expotoken',
    photo: 'photo',
    identification: 'identification',
    identification_back: 'identification_back',
    drv_license: 'drv_license',
    drv_license_back: 'drv_license_back',
    drv_vehicle_license_plate_no: 'drv_vehicle_license_plate_no',
    drv_vehicle_capacity: 'drv_vehicle_capacity',
    drv_vehicle_make: 'drv_vehicle_make',
    drv_vehicle_meterid: 'drv_vehicle_meterid',
    drv_account_name: 'drv_account_name',
    drv_account_no: 'drv_account_no',
    drv_bank: 'drv_bank',
    psv_customer_name: 'psv_customer_name',
    psv_account_name: 'psv_account_name',
    psv_account_number: 'psv_account_number',
    psv_bank: 'psv_bank',
    verifiedby: 'verifiedby',
    isavailable_by: 'isavailable_by',
    isavailable_reason: 'isavailable_reason',
    commission_payment_ref: 'commission_payment_ref',
    enable2fa: 'enable2fa',
    code2fa: 'code2fa',
    expiry2fa: 'expiry2fa',
    signupotp: 'signupotp'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const videocatOrderByRelevanceFieldEnum: {
    vidcat: 'vidcat'
  };

  export type videocatOrderByRelevanceFieldEnum = (typeof videocatOrderByRelevanceFieldEnum)[keyof typeof videocatOrderByRelevanceFieldEnum]


  export const videosOrderByRelevanceFieldEnum: {
    vidcategory: 'vidcategory',
    vidtitle: 'vidtitle',
    viddesc: 'viddesc',
    vidurl: 'vidurl',
    vidembed: 'vidembed',
    vidpostedby: 'vidpostedby',
    vidextra: 'vidextra'
  };

  export type videosOrderByRelevanceFieldEnum = (typeof videosOrderByRelevanceFieldEnum)[keyof typeof videosOrderByRelevanceFieldEnum]


  export const meter_domestic_entriesOrderByRelevanceFieldEnum: {
    md_unique_id: 'md_unique_id',
    md_userid: 'md_userid',
    md_area: 'md_area',
    md_consumption_rate: 'md_consumption_rate',
    md_valve_state: 'md_valve_state'
  };

  export type meter_domestic_entriesOrderByRelevanceFieldEnum = (typeof meter_domestic_entriesOrderByRelevanceFieldEnum)[keyof typeof meter_domestic_entriesOrderByRelevanceFieldEnum]


  export const meter_supply_entriesOrderByRelevanceFieldEnum: {
    ms_unique_id: 'ms_unique_id',
    ms_userid: 'ms_userid',
    ms_supply_rate: 'ms_supply_rate',
    ms_temperature_c: 'ms_temperature_c',
    ms_temperature_f: 'ms_temperature_f',
    ms_turbidity_level: 'ms_turbidity_level',
    ms_ph_level: 'ms_ph_level',
    ms_valve_state: 'ms_valve_state'
  };

  export type meter_supply_entriesOrderByRelevanceFieldEnum = (typeof meter_supply_entriesOrderByRelevanceFieldEnum)[keyof typeof meter_supply_entriesOrderByRelevanceFieldEnum]


  export const meter_tanker_entriesOrderByRelevanceFieldEnum: {
    mt_unique_id: 'mt_unique_id',
    mt_tankerid: 'mt_tankerid',
    mt_delivery_rate: 'mt_delivery_rate',
    mt_valve_state: 'mt_valve_state'
  };

  export type meter_tanker_entriesOrderByRelevanceFieldEnum = (typeof meter_tanker_entriesOrderByRelevanceFieldEnum)[keyof typeof meter_tanker_entriesOrderByRelevanceFieldEnum]


  export const metersOrderByRelevanceFieldEnum: {
    m_account_number: 'm_account_number',
    m_unique_id: 'm_unique_id',
    m_for: 'm_for',
    m_assigned: 'm_assigned',
    m_assigned_to: 'm_assigned_to',
    m_assigned_name: 'm_assigned_name',
    m_assigned_phone: 'm_assigned_phone',
    m_assigned_address: 'm_assigned_address',
    m_area: 'm_area',
    m_status: 'm_status',
    m_valve_state: 'm_valve_state'
  };

  export type metersOrderByRelevanceFieldEnum = (typeof metersOrderByRelevanceFieldEnum)[keyof typeof metersOrderByRelevanceFieldEnum]


  export const contact_messagesOrderByRelevanceFieldEnum: {
    cname: 'cname',
    cphone: 'cphone',
    cemail: 'cemail',
    csubject: 'csubject',
    cmessage: 'cmessage',
    cstatus: 'cstatus'
  };

  export type contact_messagesOrderByRelevanceFieldEnum = (typeof contact_messagesOrderByRelevanceFieldEnum)[keyof typeof contact_messagesOrderByRelevanceFieldEnum]


  export const meter_numbersOrderByRelevanceFieldEnum: {
    meter_type: 'meter_type',
    meter_uuid: 'meter_uuid',
    meter_uuid_used: 'meter_uuid_used',
    meter_assigned: 'meter_assigned'
  };

  export type meter_numbersOrderByRelevanceFieldEnum = (typeof meter_numbersOrderByRelevanceFieldEnum)[keyof typeof meter_numbersOrderByRelevanceFieldEnum]


  export const driverequestsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    address: 'address',
    status: 'status'
  };

  export type driverequestsOrderByRelevanceFieldEnum = (typeof driverequestsOrderByRelevanceFieldEnum)[keyof typeof driverequestsOrderByRelevanceFieldEnum]


  export const order_tableOrderByRelevanceFieldEnum: {
    order_trans_id: 'order_trans_id',
    username: 'username',
    status: 'status',
    customercomment: 'customercomment',
    notes: 'notes',
    shipping_first_name: 'shipping_first_name',
    shipping_last_name: 'shipping_last_name',
    shipping_address1: 'shipping_address1',
    shipping_address2: 'shipping_address2',
    shipping_phone: 'shipping_phone',
    shipping_email: 'shipping_email',
    shipping_city: 'shipping_city',
    shipping_state: 'shipping_state',
    shipping_country: 'shipping_country',
    delivery_type: 'delivery_type',
    gwcustid: 'gwcustid',
    gwstatusmsg: 'gwstatusmsg',
    o_sesid: 'o_sesid',
    shipping_option: 'shipping_option',
    payment_option: 'payment_option',
    payment_status: 'payment_status'
  };

  export type order_tableOrderByRelevanceFieldEnum = (typeof order_tableOrderByRelevanceFieldEnum)[keyof typeof order_tableOrderByRelevanceFieldEnum]


  export const packagesOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    name: 'name',
    sku: 'sku',
    description: 'description',
    picture: 'picture',
    size: 'size'
  };

  export type packagesOrderByRelevanceFieldEnum = (typeof packagesOrderByRelevanceFieldEnum)[keyof typeof packagesOrderByRelevanceFieldEnum]


  export const ratingsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    orderid: 'orderid',
    comment: 'comment'
  };

  export type ratingsOrderByRelevanceFieldEnum = (typeof ratingsOrderByRelevanceFieldEnum)[keyof typeof ratingsOrderByRelevanceFieldEnum]


  export const usercatOrderByRelevanceFieldEnum: {
    usercategory: 'usercategory',
    usercatdesc: 'usercatdesc'
  };

  export type usercatOrderByRelevanceFieldEnum = (typeof usercatOrderByRelevanceFieldEnum)[keyof typeof usercatOrderByRelevanceFieldEnum]


  export const complaints_repliesOrderByRelevanceFieldEnum: {
    creplysubject: 'creplysubject',
    creplyname: 'creplyname',
    creplyphone: 'creplyphone',
    creplymessage: 'creplymessage'
  };

  export type complaints_repliesOrderByRelevanceFieldEnum = (typeof complaints_repliesOrderByRelevanceFieldEnum)[keyof typeof complaints_repliesOrderByRelevanceFieldEnum]


  export const subscriptionsOrderByRelevanceFieldEnum: {
    subplantype: 'subplantype',
    subplanusername: 'subplanusername',
    subplan_status: 'subplan_status',
    subplan_pay_status: 'subplan_pay_status',
    subplan_area: 'subplan_area',
    subplan_admin: 'subplan_admin'
  };

  export type subscriptionsOrderByRelevanceFieldEnum = (typeof subscriptionsOrderByRelevanceFieldEnum)[keyof typeof subscriptionsOrderByRelevanceFieldEnum]


  export const trucksOrderByRelevanceFieldEnum: {
    truck_make: 'truck_make',
    truck_plateno: 'truck_plateno',
    truck_meterid: 'truck_meterid',
    truck_driver: 'truck_driver',
    truck_status: 'truck_status'
  };

  export type trucksOrderByRelevanceFieldEnum = (typeof trucksOrderByRelevanceFieldEnum)[keyof typeof trucksOrderByRelevanceFieldEnum]


  export const area_groupsOrderByRelevanceFieldEnum: {
    agname: 'agname',
    agareas: 'agareas'
  };

  export type area_groupsOrderByRelevanceFieldEnum = (typeof area_groupsOrderByRelevanceFieldEnum)[keyof typeof area_groupsOrderByRelevanceFieldEnum]


  export const product_prices_areasOrderByRelevanceFieldEnum: {
    pparea: 'pparea',
    pp_subscription: 'pp_subscription'
  };

  export type product_prices_areasOrderByRelevanceFieldEnum = (typeof product_prices_areasOrderByRelevanceFieldEnum)[keyof typeof product_prices_areasOrderByRelevanceFieldEnum]


  export const articlesOrderByRelevanceFieldEnum: {
    artcategory: 'artcategory',
    title: 'title',
    titleslug: 'titleslug',
    fullcontent: 'fullcontent',
    mkeys: 'mkeys',
    mdesc: 'mdesc',
    artsource: 'artsource',
    artsource_url: 'artsource_url',
    artphoto: 'artphoto',
    artphotocaption: 'artphotocaption',
    artphotourl: 'artphotourl',
    author: 'author',
    artstatus: 'artstatus',
    published_date: 'published_date'
  };

  export type articlesOrderByRelevanceFieldEnum = (typeof articlesOrderByRelevanceFieldEnum)[keyof typeof articlesOrderByRelevanceFieldEnum]


  export const subscription_plansOrderByRelevanceFieldEnum: {
    subplan_cat: 'subplan_cat',
    subplan: 'subplan',
    subplan_months: 'subplan_months',
    subplan_include: 'subplan_include',
    subplan_exclude: 'subplan_exclude'
  };

  export type subscription_plansOrderByRelevanceFieldEnum = (typeof subscription_plansOrderByRelevanceFieldEnum)[keyof typeof subscription_plansOrderByRelevanceFieldEnum]


  export const vendorreportsOrderByRelevanceFieldEnum: {
    customerid: 'customerid',
    customername: 'customername',
    vendorid: 'vendorid',
    plateno: 'plateno'
  };

  export type vendorreportsOrderByRelevanceFieldEnum = (typeof vendorreportsOrderByRelevanceFieldEnum)[keyof typeof vendorreportsOrderByRelevanceFieldEnum]


  export const water_purchasesOrderByRelevanceFieldEnum: {
    wp_orderref: 'wp_orderref',
    wp_type: 'wp_type',
    wp_merchant_id: 'wp_merchant_id',
    wp_merchant_name: 'wp_merchant_name',
    wp_merchant_address: 'wp_merchant_address',
    wp_volume: 'wp_volume',
    wp_driver_id: 'wp_driver_id',
    wp_driver_name: 'wp_driver_name',
    wp_fleetid: 'wp_fleetid',
    wp_remark: 'wp_remark'
  };

  export type water_purchasesOrderByRelevanceFieldEnum = (typeof water_purchasesOrderByRelevanceFieldEnum)[keyof typeof water_purchasesOrderByRelevanceFieldEnum]


  export const MeterReadingsOrderByRelevanceFieldEnum: {
    first_reading: 'first_reading',
    afternoon_reading: 'afternoon_reading',
    last_reading: 'last_reading'
  };

  export type MeterReadingsOrderByRelevanceFieldEnum = (typeof MeterReadingsOrderByRelevanceFieldEnum)[keyof typeof MeterReadingsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'order_table_last_update_by'
   */
  export type Enumorder_table_last_update_byFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'order_table_last_update_by'>
    
  /**
   * Deep Input Types
   */


  export type banneradsWhereInput = {
    AND?: banneradsWhereInput | banneradsWhereInput[]
    OR?: banneradsWhereInput[]
    NOT?: banneradsWhereInput | banneradsWhereInput[]
    id_ad?: IntFilter<"bannerads"> | number
    title_ad?: StringFilter<"bannerads"> | string
    descr_ad?: StringFilter<"bannerads"> | string
    adcode?: StringFilter<"bannerads"> | string
    file_ad?: StringFilter<"bannerads"> | string
    topfile_ad?: StringNullableFilter<"bannerads"> | string | null
    url_ad?: StringFilter<"bannerads"> | string
    banner_rank?: IntFilter<"bannerads"> | number
    addedon_ad?: DateTimeFilter<"bannerads"> | Date | string
    startdate_ad?: DateTimeFilter<"bannerads"> | Date | string
    enddate_ad?: DateTimeFilter<"bannerads"> | Date | string
    daysno_ad?: StringFilter<"bannerads"> | string
    width_ad?: StringNullableFilter<"bannerads"> | string | null
    height_ad?: StringNullableFilter<"bannerads"> | string | null
    position_ad?: StringFilter<"bannerads"> | string
    banner_status?: StringFilter<"bannerads"> | string
    visible_ad?: IntFilter<"bannerads"> | number
    userid_ad?: StringFilter<"bannerads"> | string
    username_ad?: StringFilter<"bannerads"> | string
    paid?: IntFilter<"bannerads"> | number
    amount?: DecimalNullableFilter<"bannerads"> | Decimal | DecimalJsLike | number | string | null
    datepaid?: DateTimeNullableFilter<"bannerads"> | Date | string | null
    remark?: StringNullableFilter<"bannerads"> | string | null
    views_ad?: IntFilter<"bannerads"> | number
    clicks_ad?: IntFilter<"bannerads"> | number
  }

  export type banneradsOrderByWithRelationInput = {
    id_ad?: SortOrder
    title_ad?: SortOrder
    descr_ad?: SortOrder
    adcode?: SortOrder
    file_ad?: SortOrder
    topfile_ad?: SortOrderInput | SortOrder
    url_ad?: SortOrder
    banner_rank?: SortOrder
    addedon_ad?: SortOrder
    startdate_ad?: SortOrder
    enddate_ad?: SortOrder
    daysno_ad?: SortOrder
    width_ad?: SortOrderInput | SortOrder
    height_ad?: SortOrderInput | SortOrder
    position_ad?: SortOrder
    banner_status?: SortOrder
    visible_ad?: SortOrder
    userid_ad?: SortOrder
    username_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrderInput | SortOrder
    datepaid?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
    _relevance?: banneradsOrderByRelevanceInput
  }

  export type banneradsWhereUniqueInput = Prisma.AtLeast<{
    id_ad?: number
    AND?: banneradsWhereInput | banneradsWhereInput[]
    OR?: banneradsWhereInput[]
    NOT?: banneradsWhereInput | banneradsWhereInput[]
    title_ad?: StringFilter<"bannerads"> | string
    descr_ad?: StringFilter<"bannerads"> | string
    adcode?: StringFilter<"bannerads"> | string
    file_ad?: StringFilter<"bannerads"> | string
    topfile_ad?: StringNullableFilter<"bannerads"> | string | null
    url_ad?: StringFilter<"bannerads"> | string
    banner_rank?: IntFilter<"bannerads"> | number
    addedon_ad?: DateTimeFilter<"bannerads"> | Date | string
    startdate_ad?: DateTimeFilter<"bannerads"> | Date | string
    enddate_ad?: DateTimeFilter<"bannerads"> | Date | string
    daysno_ad?: StringFilter<"bannerads"> | string
    width_ad?: StringNullableFilter<"bannerads"> | string | null
    height_ad?: StringNullableFilter<"bannerads"> | string | null
    position_ad?: StringFilter<"bannerads"> | string
    banner_status?: StringFilter<"bannerads"> | string
    visible_ad?: IntFilter<"bannerads"> | number
    userid_ad?: StringFilter<"bannerads"> | string
    username_ad?: StringFilter<"bannerads"> | string
    paid?: IntFilter<"bannerads"> | number
    amount?: DecimalNullableFilter<"bannerads"> | Decimal | DecimalJsLike | number | string | null
    datepaid?: DateTimeNullableFilter<"bannerads"> | Date | string | null
    remark?: StringNullableFilter<"bannerads"> | string | null
    views_ad?: IntFilter<"bannerads"> | number
    clicks_ad?: IntFilter<"bannerads"> | number
  }, "id_ad">

  export type banneradsOrderByWithAggregationInput = {
    id_ad?: SortOrder
    title_ad?: SortOrder
    descr_ad?: SortOrder
    adcode?: SortOrder
    file_ad?: SortOrder
    topfile_ad?: SortOrderInput | SortOrder
    url_ad?: SortOrder
    banner_rank?: SortOrder
    addedon_ad?: SortOrder
    startdate_ad?: SortOrder
    enddate_ad?: SortOrder
    daysno_ad?: SortOrder
    width_ad?: SortOrderInput | SortOrder
    height_ad?: SortOrderInput | SortOrder
    position_ad?: SortOrder
    banner_status?: SortOrder
    visible_ad?: SortOrder
    userid_ad?: SortOrder
    username_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrderInput | SortOrder
    datepaid?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
    _count?: banneradsCountOrderByAggregateInput
    _avg?: banneradsAvgOrderByAggregateInput
    _max?: banneradsMaxOrderByAggregateInput
    _min?: banneradsMinOrderByAggregateInput
    _sum?: banneradsSumOrderByAggregateInput
  }

  export type banneradsScalarWhereWithAggregatesInput = {
    AND?: banneradsScalarWhereWithAggregatesInput | banneradsScalarWhereWithAggregatesInput[]
    OR?: banneradsScalarWhereWithAggregatesInput[]
    NOT?: banneradsScalarWhereWithAggregatesInput | banneradsScalarWhereWithAggregatesInput[]
    id_ad?: IntWithAggregatesFilter<"bannerads"> | number
    title_ad?: StringWithAggregatesFilter<"bannerads"> | string
    descr_ad?: StringWithAggregatesFilter<"bannerads"> | string
    adcode?: StringWithAggregatesFilter<"bannerads"> | string
    file_ad?: StringWithAggregatesFilter<"bannerads"> | string
    topfile_ad?: StringNullableWithAggregatesFilter<"bannerads"> | string | null
    url_ad?: StringWithAggregatesFilter<"bannerads"> | string
    banner_rank?: IntWithAggregatesFilter<"bannerads"> | number
    addedon_ad?: DateTimeWithAggregatesFilter<"bannerads"> | Date | string
    startdate_ad?: DateTimeWithAggregatesFilter<"bannerads"> | Date | string
    enddate_ad?: DateTimeWithAggregatesFilter<"bannerads"> | Date | string
    daysno_ad?: StringWithAggregatesFilter<"bannerads"> | string
    width_ad?: StringNullableWithAggregatesFilter<"bannerads"> | string | null
    height_ad?: StringNullableWithAggregatesFilter<"bannerads"> | string | null
    position_ad?: StringWithAggregatesFilter<"bannerads"> | string
    banner_status?: StringWithAggregatesFilter<"bannerads"> | string
    visible_ad?: IntWithAggregatesFilter<"bannerads"> | number
    userid_ad?: StringWithAggregatesFilter<"bannerads"> | string
    username_ad?: StringWithAggregatesFilter<"bannerads"> | string
    paid?: IntWithAggregatesFilter<"bannerads"> | number
    amount?: DecimalNullableWithAggregatesFilter<"bannerads"> | Decimal | DecimalJsLike | number | string | null
    datepaid?: DateTimeNullableWithAggregatesFilter<"bannerads"> | Date | string | null
    remark?: StringNullableWithAggregatesFilter<"bannerads"> | string | null
    views_ad?: IntWithAggregatesFilter<"bannerads"> | number
    clicks_ad?: IntWithAggregatesFilter<"bannerads"> | number
  }

  export type blogWhereInput = {
    AND?: blogWhereInput | blogWhereInput[]
    OR?: blogWhereInput[]
    NOT?: blogWhereInput | blogWhereInput[]
    artid?: IntFilter<"blog"> | number
    artcategory?: StringFilter<"blog"> | string
    title?: StringFilter<"blog"> | string
    titleslug?: StringFilter<"blog"> | string
    brief?: StringFilter<"blog"> | string
    fullcontent?: StringFilter<"blog"> | string
    artphoto?: StringNullableFilter<"blog"> | string | null
    artphotocaption?: StringFilter<"blog"> | string
    author?: StringNullableFilter<"blog"> | string | null
    artsource?: StringNullableFilter<"blog"> | string | null
    artsource_url?: StringNullableFilter<"blog"> | string | null
    published_date?: DateTimeFilter<"blog"> | Date | string
    artstatus?: StringFilter<"blog"> | string
    nstatus?: StringFilter<"blog"> | string
    views?: IntFilter<"blog"> | number
    artsubmit?: DateTimeFilter<"blog"> | Date | string
    artusername?: StringFilter<"blog"> | string
    youtube_embed?: StringNullableFilter<"blog"> | string | null
    vidurl?: StringFilter<"blog"> | string
    homepage?: IntFilter<"blog"> | number
    createdAt?: DateTimeFilter<"blog"> | Date | string
    updatedAt?: DateTimeFilter<"blog"> | Date | string
  }

  export type blogOrderByWithRelationInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    brief?: SortOrder
    fullcontent?: SortOrder
    artphoto?: SortOrderInput | SortOrder
    artphotocaption?: SortOrder
    author?: SortOrderInput | SortOrder
    artsource?: SortOrderInput | SortOrder
    artsource_url?: SortOrderInput | SortOrder
    published_date?: SortOrder
    artstatus?: SortOrder
    nstatus?: SortOrder
    views?: SortOrder
    artsubmit?: SortOrder
    artusername?: SortOrder
    youtube_embed?: SortOrderInput | SortOrder
    vidurl?: SortOrder
    homepage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: blogOrderByRelevanceInput
  }

  export type blogWhereUniqueInput = Prisma.AtLeast<{
    artid?: number
    AND?: blogWhereInput | blogWhereInput[]
    OR?: blogWhereInput[]
    NOT?: blogWhereInput | blogWhereInput[]
    artcategory?: StringFilter<"blog"> | string
    title?: StringFilter<"blog"> | string
    titleslug?: StringFilter<"blog"> | string
    brief?: StringFilter<"blog"> | string
    fullcontent?: StringFilter<"blog"> | string
    artphoto?: StringNullableFilter<"blog"> | string | null
    artphotocaption?: StringFilter<"blog"> | string
    author?: StringNullableFilter<"blog"> | string | null
    artsource?: StringNullableFilter<"blog"> | string | null
    artsource_url?: StringNullableFilter<"blog"> | string | null
    published_date?: DateTimeFilter<"blog"> | Date | string
    artstatus?: StringFilter<"blog"> | string
    nstatus?: StringFilter<"blog"> | string
    views?: IntFilter<"blog"> | number
    artsubmit?: DateTimeFilter<"blog"> | Date | string
    artusername?: StringFilter<"blog"> | string
    youtube_embed?: StringNullableFilter<"blog"> | string | null
    vidurl?: StringFilter<"blog"> | string
    homepage?: IntFilter<"blog"> | number
    createdAt?: DateTimeFilter<"blog"> | Date | string
    updatedAt?: DateTimeFilter<"blog"> | Date | string
  }, "artid">

  export type blogOrderByWithAggregationInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    brief?: SortOrder
    fullcontent?: SortOrder
    artphoto?: SortOrderInput | SortOrder
    artphotocaption?: SortOrder
    author?: SortOrderInput | SortOrder
    artsource?: SortOrderInput | SortOrder
    artsource_url?: SortOrderInput | SortOrder
    published_date?: SortOrder
    artstatus?: SortOrder
    nstatus?: SortOrder
    views?: SortOrder
    artsubmit?: SortOrder
    artusername?: SortOrder
    youtube_embed?: SortOrderInput | SortOrder
    vidurl?: SortOrder
    homepage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: blogCountOrderByAggregateInput
    _avg?: blogAvgOrderByAggregateInput
    _max?: blogMaxOrderByAggregateInput
    _min?: blogMinOrderByAggregateInput
    _sum?: blogSumOrderByAggregateInput
  }

  export type blogScalarWhereWithAggregatesInput = {
    AND?: blogScalarWhereWithAggregatesInput | blogScalarWhereWithAggregatesInput[]
    OR?: blogScalarWhereWithAggregatesInput[]
    NOT?: blogScalarWhereWithAggregatesInput | blogScalarWhereWithAggregatesInput[]
    artid?: IntWithAggregatesFilter<"blog"> | number
    artcategory?: StringWithAggregatesFilter<"blog"> | string
    title?: StringWithAggregatesFilter<"blog"> | string
    titleslug?: StringWithAggregatesFilter<"blog"> | string
    brief?: StringWithAggregatesFilter<"blog"> | string
    fullcontent?: StringWithAggregatesFilter<"blog"> | string
    artphoto?: StringNullableWithAggregatesFilter<"blog"> | string | null
    artphotocaption?: StringWithAggregatesFilter<"blog"> | string
    author?: StringNullableWithAggregatesFilter<"blog"> | string | null
    artsource?: StringNullableWithAggregatesFilter<"blog"> | string | null
    artsource_url?: StringNullableWithAggregatesFilter<"blog"> | string | null
    published_date?: DateTimeWithAggregatesFilter<"blog"> | Date | string
    artstatus?: StringWithAggregatesFilter<"blog"> | string
    nstatus?: StringWithAggregatesFilter<"blog"> | string
    views?: IntWithAggregatesFilter<"blog"> | number
    artsubmit?: DateTimeWithAggregatesFilter<"blog"> | Date | string
    artusername?: StringWithAggregatesFilter<"blog"> | string
    youtube_embed?: StringNullableWithAggregatesFilter<"blog"> | string | null
    vidurl?: StringWithAggregatesFilter<"blog"> | string
    homepage?: IntWithAggregatesFilter<"blog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"blog"> | Date | string
  }

  export type contentpagesWhereInput = {
    AND?: contentpagesWhereInput | contentpagesWhereInput[]
    OR?: contentpagesWhereInput[]
    NOT?: contentpagesWhereInput | contentpagesWhereInput[]
    cpageid?: IntFilter<"contentpages"> | number
    cpagename?: StringFilter<"contentpages"> | string
    cpagecontent?: StringFilter<"contentpages"> | string
    cpagephoto?: StringNullableFilter<"contentpages"> | string | null
    cpagesbanner?: StringNullableFilter<"contentpages"> | string | null
    cpagemenu?: StringFilter<"contentpages"> | string
    cpagelinkname?: StringFilter<"contentpages"> | string
    cpage_postedby?: StringFilter<"contentpages"> | string
    createdAt?: DateTimeFilter<"contentpages"> | Date | string
    updatedAt?: DateTimeFilter<"contentpages"> | Date | string
  }

  export type contentpagesOrderByWithRelationInput = {
    cpageid?: SortOrder
    cpagename?: SortOrder
    cpagecontent?: SortOrder
    cpagephoto?: SortOrderInput | SortOrder
    cpagesbanner?: SortOrderInput | SortOrder
    cpagemenu?: SortOrder
    cpagelinkname?: SortOrder
    cpage_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: contentpagesOrderByRelevanceInput
  }

  export type contentpagesWhereUniqueInput = Prisma.AtLeast<{
    cpageid?: number
    AND?: contentpagesWhereInput | contentpagesWhereInput[]
    OR?: contentpagesWhereInput[]
    NOT?: contentpagesWhereInput | contentpagesWhereInput[]
    cpagename?: StringFilter<"contentpages"> | string
    cpagecontent?: StringFilter<"contentpages"> | string
    cpagephoto?: StringNullableFilter<"contentpages"> | string | null
    cpagesbanner?: StringNullableFilter<"contentpages"> | string | null
    cpagemenu?: StringFilter<"contentpages"> | string
    cpagelinkname?: StringFilter<"contentpages"> | string
    cpage_postedby?: StringFilter<"contentpages"> | string
    createdAt?: DateTimeFilter<"contentpages"> | Date | string
    updatedAt?: DateTimeFilter<"contentpages"> | Date | string
  }, "cpageid">

  export type contentpagesOrderByWithAggregationInput = {
    cpageid?: SortOrder
    cpagename?: SortOrder
    cpagecontent?: SortOrder
    cpagephoto?: SortOrderInput | SortOrder
    cpagesbanner?: SortOrderInput | SortOrder
    cpagemenu?: SortOrder
    cpagelinkname?: SortOrder
    cpage_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: contentpagesCountOrderByAggregateInput
    _avg?: contentpagesAvgOrderByAggregateInput
    _max?: contentpagesMaxOrderByAggregateInput
    _min?: contentpagesMinOrderByAggregateInput
    _sum?: contentpagesSumOrderByAggregateInput
  }

  export type contentpagesScalarWhereWithAggregatesInput = {
    AND?: contentpagesScalarWhereWithAggregatesInput | contentpagesScalarWhereWithAggregatesInput[]
    OR?: contentpagesScalarWhereWithAggregatesInput[]
    NOT?: contentpagesScalarWhereWithAggregatesInput | contentpagesScalarWhereWithAggregatesInput[]
    cpageid?: IntWithAggregatesFilter<"contentpages"> | number
    cpagename?: StringWithAggregatesFilter<"contentpages"> | string
    cpagecontent?: StringWithAggregatesFilter<"contentpages"> | string
    cpagephoto?: StringNullableWithAggregatesFilter<"contentpages"> | string | null
    cpagesbanner?: StringNullableWithAggregatesFilter<"contentpages"> | string | null
    cpagemenu?: StringWithAggregatesFilter<"contentpages"> | string
    cpagelinkname?: StringWithAggregatesFilter<"contentpages"> | string
    cpage_postedby?: StringWithAggregatesFilter<"contentpages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"contentpages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"contentpages"> | Date | string
  }

  export type driver_paymentsWhereInput = {
    AND?: driver_paymentsWhereInput | driver_paymentsWhereInput[]
    OR?: driver_paymentsWhereInput[]
    NOT?: driver_paymentsWhereInput | driver_paymentsWhereInput[]
    dpayid?: IntFilter<"driver_payments"> | number
    dpayref?: StringFilter<"driver_payments"> | string
    dpaydriver?: IntFilter<"driver_payments"> | number
    dpayoutstanding?: FloatFilter<"driver_payments"> | number
    dpaypaystackref?: StringFilter<"driver_payments"> | string
    createdAt?: DateTimeFilter<"driver_payments"> | Date | string
    updatedAt?: DateTimeFilter<"driver_payments"> | Date | string
  }

  export type driver_paymentsOrderByWithRelationInput = {
    dpayid?: SortOrder
    dpayref?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
    dpaypaystackref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: driver_paymentsOrderByRelevanceInput
  }

  export type driver_paymentsWhereUniqueInput = Prisma.AtLeast<{
    dpayid?: number
    AND?: driver_paymentsWhereInput | driver_paymentsWhereInput[]
    OR?: driver_paymentsWhereInput[]
    NOT?: driver_paymentsWhereInput | driver_paymentsWhereInput[]
    dpayref?: StringFilter<"driver_payments"> | string
    dpaydriver?: IntFilter<"driver_payments"> | number
    dpayoutstanding?: FloatFilter<"driver_payments"> | number
    dpaypaystackref?: StringFilter<"driver_payments"> | string
    createdAt?: DateTimeFilter<"driver_payments"> | Date | string
    updatedAt?: DateTimeFilter<"driver_payments"> | Date | string
  }, "dpayid">

  export type driver_paymentsOrderByWithAggregationInput = {
    dpayid?: SortOrder
    dpayref?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
    dpaypaystackref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: driver_paymentsCountOrderByAggregateInput
    _avg?: driver_paymentsAvgOrderByAggregateInput
    _max?: driver_paymentsMaxOrderByAggregateInput
    _min?: driver_paymentsMinOrderByAggregateInput
    _sum?: driver_paymentsSumOrderByAggregateInput
  }

  export type driver_paymentsScalarWhereWithAggregatesInput = {
    AND?: driver_paymentsScalarWhereWithAggregatesInput | driver_paymentsScalarWhereWithAggregatesInput[]
    OR?: driver_paymentsScalarWhereWithAggregatesInput[]
    NOT?: driver_paymentsScalarWhereWithAggregatesInput | driver_paymentsScalarWhereWithAggregatesInput[]
    dpayid?: IntWithAggregatesFilter<"driver_payments"> | number
    dpayref?: StringWithAggregatesFilter<"driver_payments"> | string
    dpaydriver?: IntWithAggregatesFilter<"driver_payments"> | number
    dpayoutstanding?: FloatWithAggregatesFilter<"driver_payments"> | number
    dpaypaystackref?: StringWithAggregatesFilter<"driver_payments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"driver_payments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"driver_payments"> | Date | string
  }

  export type faqsWhereInput = {
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    faqid?: IntFilter<"faqs"> | number
    faqcat?: StringFilter<"faqs"> | string
    faqquestion?: StringFilter<"faqs"> | string
    faqanswer?: StringFilter<"faqs"> | string
    faqslug?: StringFilter<"faqs"> | string
    faqpostedby?: StringFilter<"faqs"> | string
    createdAt?: DateTimeFilter<"faqs"> | Date | string
    updatedAt?: DateTimeFilter<"faqs"> | Date | string
  }

  export type faqsOrderByWithRelationInput = {
    faqid?: SortOrder
    faqcat?: SortOrder
    faqquestion?: SortOrder
    faqanswer?: SortOrder
    faqslug?: SortOrder
    faqpostedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: faqsOrderByRelevanceInput
  }

  export type faqsWhereUniqueInput = Prisma.AtLeast<{
    faqid?: number
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    faqcat?: StringFilter<"faqs"> | string
    faqquestion?: StringFilter<"faqs"> | string
    faqanswer?: StringFilter<"faqs"> | string
    faqslug?: StringFilter<"faqs"> | string
    faqpostedby?: StringFilter<"faqs"> | string
    createdAt?: DateTimeFilter<"faqs"> | Date | string
    updatedAt?: DateTimeFilter<"faqs"> | Date | string
  }, "faqid">

  export type faqsOrderByWithAggregationInput = {
    faqid?: SortOrder
    faqcat?: SortOrder
    faqquestion?: SortOrder
    faqanswer?: SortOrder
    faqslug?: SortOrder
    faqpostedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: faqsCountOrderByAggregateInput
    _avg?: faqsAvgOrderByAggregateInput
    _max?: faqsMaxOrderByAggregateInput
    _min?: faqsMinOrderByAggregateInput
    _sum?: faqsSumOrderByAggregateInput
  }

  export type faqsScalarWhereWithAggregatesInput = {
    AND?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    OR?: faqsScalarWhereWithAggregatesInput[]
    NOT?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    faqid?: IntWithAggregatesFilter<"faqs"> | number
    faqcat?: StringWithAggregatesFilter<"faqs"> | string
    faqquestion?: StringWithAggregatesFilter<"faqs"> | string
    faqanswer?: StringWithAggregatesFilter<"faqs"> | string
    faqslug?: StringWithAggregatesFilter<"faqs"> | string
    faqpostedby?: StringWithAggregatesFilter<"faqs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
  }

  export type loc_statesWhereInput = {
    AND?: loc_statesWhereInput | loc_statesWhereInput[]
    OR?: loc_statesWhereInput[]
    NOT?: loc_statesWhereInput | loc_statesWhereInput[]
    stateid?: IntFilter<"loc_states"> | number
    state?: StringFilter<"loc_states"> | string
  }

  export type loc_statesOrderByWithRelationInput = {
    stateid?: SortOrder
    state?: SortOrder
    _relevance?: loc_statesOrderByRelevanceInput
  }

  export type loc_statesWhereUniqueInput = Prisma.AtLeast<{
    stateid?: number
    AND?: loc_statesWhereInput | loc_statesWhereInput[]
    OR?: loc_statesWhereInput[]
    NOT?: loc_statesWhereInput | loc_statesWhereInput[]
    state?: StringFilter<"loc_states"> | string
  }, "stateid">

  export type loc_statesOrderByWithAggregationInput = {
    stateid?: SortOrder
    state?: SortOrder
    _count?: loc_statesCountOrderByAggregateInput
    _avg?: loc_statesAvgOrderByAggregateInput
    _max?: loc_statesMaxOrderByAggregateInput
    _min?: loc_statesMinOrderByAggregateInput
    _sum?: loc_statesSumOrderByAggregateInput
  }

  export type loc_statesScalarWhereWithAggregatesInput = {
    AND?: loc_statesScalarWhereWithAggregatesInput | loc_statesScalarWhereWithAggregatesInput[]
    OR?: loc_statesScalarWhereWithAggregatesInput[]
    NOT?: loc_statesScalarWhereWithAggregatesInput | loc_statesScalarWhereWithAggregatesInput[]
    stateid?: IntWithAggregatesFilter<"loc_states"> | number
    state?: StringWithAggregatesFilter<"loc_states"> | string
  }

  export type media_assetsWhereInput = {
    AND?: media_assetsWhereInput | media_assetsWhereInput[]
    OR?: media_assetsWhereInput[]
    NOT?: media_assetsWhereInput | media_assetsWhereInput[]
    massetid?: IntFilter<"media_assets"> | number
    masset?: StringFilter<"media_assets"> | string
    massetdate?: DateTimeFilter<"media_assets"> | Date | string
  }

  export type media_assetsOrderByWithRelationInput = {
    massetid?: SortOrder
    masset?: SortOrder
    massetdate?: SortOrder
    _relevance?: media_assetsOrderByRelevanceInput
  }

  export type media_assetsWhereUniqueInput = Prisma.AtLeast<{
    massetid?: number
    AND?: media_assetsWhereInput | media_assetsWhereInput[]
    OR?: media_assetsWhereInput[]
    NOT?: media_assetsWhereInput | media_assetsWhereInput[]
    masset?: StringFilter<"media_assets"> | string
    massetdate?: DateTimeFilter<"media_assets"> | Date | string
  }, "massetid">

  export type media_assetsOrderByWithAggregationInput = {
    massetid?: SortOrder
    masset?: SortOrder
    massetdate?: SortOrder
    _count?: media_assetsCountOrderByAggregateInput
    _avg?: media_assetsAvgOrderByAggregateInput
    _max?: media_assetsMaxOrderByAggregateInput
    _min?: media_assetsMinOrderByAggregateInput
    _sum?: media_assetsSumOrderByAggregateInput
  }

  export type media_assetsScalarWhereWithAggregatesInput = {
    AND?: media_assetsScalarWhereWithAggregatesInput | media_assetsScalarWhereWithAggregatesInput[]
    OR?: media_assetsScalarWhereWithAggregatesInput[]
    NOT?: media_assetsScalarWhereWithAggregatesInput | media_assetsScalarWhereWithAggregatesInput[]
    massetid?: IntWithAggregatesFilter<"media_assets"> | number
    masset?: StringWithAggregatesFilter<"media_assets"> | string
    massetdate?: DateTimeWithAggregatesFilter<"media_assets"> | Date | string
  }

  export type newsletterWhereInput = {
    AND?: newsletterWhereInput | newsletterWhereInput[]
    OR?: newsletterWhereInput[]
    NOT?: newsletterWhereInput | newsletterWhereInput[]
    nlid?: IntFilter<"newsletter"> | number
    nlname?: StringFilter<"newsletter"> | string
    nlemail?: StringFilter<"newsletter"> | string
    nlstatus?: IntFilter<"newsletter"> | number
    nl_received?: IntFilter<"newsletter"> | number
    nl_id?: IntFilter<"newsletter"> | number
  }

  export type newsletterOrderByWithRelationInput = {
    nlid?: SortOrder
    nlname?: SortOrder
    nlemail?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
    _relevance?: newsletterOrderByRelevanceInput
  }

  export type newsletterWhereUniqueInput = Prisma.AtLeast<{
    nlid?: number
    nlemail?: string
    AND?: newsletterWhereInput | newsletterWhereInput[]
    OR?: newsletterWhereInput[]
    NOT?: newsletterWhereInput | newsletterWhereInput[]
    nlname?: StringFilter<"newsletter"> | string
    nlstatus?: IntFilter<"newsletter"> | number
    nl_received?: IntFilter<"newsletter"> | number
    nl_id?: IntFilter<"newsletter"> | number
  }, "nlid" | "nlemail">

  export type newsletterOrderByWithAggregationInput = {
    nlid?: SortOrder
    nlname?: SortOrder
    nlemail?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
    _count?: newsletterCountOrderByAggregateInput
    _avg?: newsletterAvgOrderByAggregateInput
    _max?: newsletterMaxOrderByAggregateInput
    _min?: newsletterMinOrderByAggregateInput
    _sum?: newsletterSumOrderByAggregateInput
  }

  export type newsletterScalarWhereWithAggregatesInput = {
    AND?: newsletterScalarWhereWithAggregatesInput | newsletterScalarWhereWithAggregatesInput[]
    OR?: newsletterScalarWhereWithAggregatesInput[]
    NOT?: newsletterScalarWhereWithAggregatesInput | newsletterScalarWhereWithAggregatesInput[]
    nlid?: IntWithAggregatesFilter<"newsletter"> | number
    nlname?: StringWithAggregatesFilter<"newsletter"> | string
    nlemail?: StringWithAggregatesFilter<"newsletter"> | string
    nlstatus?: IntWithAggregatesFilter<"newsletter"> | number
    nl_received?: IntWithAggregatesFilter<"newsletter"> | number
    nl_id?: IntWithAggregatesFilter<"newsletter"> | number
  }

  export type newsletter_bodyWhereInput = {
    AND?: newsletter_bodyWhereInput | newsletter_bodyWhereInput[]
    OR?: newsletter_bodyWhereInput[]
    NOT?: newsletter_bodyWhereInput | newsletter_bodyWhereInput[]
    nlb_id?: IntFilter<"newsletter_body"> | number
    nlb_title?: StringFilter<"newsletter_body"> | string
    nlb_story?: StringFilter<"newsletter_body"> | string
    nlb_finished?: StringFilter<"newsletter_body"> | string
    nlb_postedby?: StringFilter<"newsletter_body"> | string
    createdAt?: DateTimeFilter<"newsletter_body"> | Date | string
    updatedAt?: DateTimeNullableFilter<"newsletter_body"> | Date | string | null
  }

  export type newsletter_bodyOrderByWithRelationInput = {
    nlb_id?: SortOrder
    nlb_title?: SortOrder
    nlb_story?: SortOrder
    nlb_finished?: SortOrder
    nlb_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: newsletter_bodyOrderByRelevanceInput
  }

  export type newsletter_bodyWhereUniqueInput = Prisma.AtLeast<{
    nlb_id?: number
    AND?: newsletter_bodyWhereInput | newsletter_bodyWhereInput[]
    OR?: newsletter_bodyWhereInput[]
    NOT?: newsletter_bodyWhereInput | newsletter_bodyWhereInput[]
    nlb_title?: StringFilter<"newsletter_body"> | string
    nlb_story?: StringFilter<"newsletter_body"> | string
    nlb_finished?: StringFilter<"newsletter_body"> | string
    nlb_postedby?: StringFilter<"newsletter_body"> | string
    createdAt?: DateTimeFilter<"newsletter_body"> | Date | string
    updatedAt?: DateTimeNullableFilter<"newsletter_body"> | Date | string | null
  }, "nlb_id">

  export type newsletter_bodyOrderByWithAggregationInput = {
    nlb_id?: SortOrder
    nlb_title?: SortOrder
    nlb_story?: SortOrder
    nlb_finished?: SortOrder
    nlb_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: newsletter_bodyCountOrderByAggregateInput
    _avg?: newsletter_bodyAvgOrderByAggregateInput
    _max?: newsletter_bodyMaxOrderByAggregateInput
    _min?: newsletter_bodyMinOrderByAggregateInput
    _sum?: newsletter_bodySumOrderByAggregateInput
  }

  export type newsletter_bodyScalarWhereWithAggregatesInput = {
    AND?: newsletter_bodyScalarWhereWithAggregatesInput | newsletter_bodyScalarWhereWithAggregatesInput[]
    OR?: newsletter_bodyScalarWhereWithAggregatesInput[]
    NOT?: newsletter_bodyScalarWhereWithAggregatesInput | newsletter_bodyScalarWhereWithAggregatesInput[]
    nlb_id?: IntWithAggregatesFilter<"newsletter_body"> | number
    nlb_title?: StringWithAggregatesFilter<"newsletter_body"> | string
    nlb_story?: StringWithAggregatesFilter<"newsletter_body"> | string
    nlb_finished?: StringWithAggregatesFilter<"newsletter_body"> | string
    nlb_postedby?: StringWithAggregatesFilter<"newsletter_body"> | string
    createdAt?: DateTimeWithAggregatesFilter<"newsletter_body"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"newsletter_body"> | Date | string | null
  }

  export type paystackresponseWhereInput = {
    AND?: paystackresponseWhereInput | paystackresponseWhereInput[]
    OR?: paystackresponseWhereInput[]
    NOT?: paystackresponseWhereInput | paystackresponseWhereInput[]
    prid?: IntFilter<"paystackresponse"> | number
    prbody?: StringFilter<"paystackresponse"> | string
    pracc_number?: StringNullableFilter<"paystackresponse"> | string | null
    pracc_bank?: StringNullableFilter<"paystackresponse"> | string | null
    createdAt?: DateTimeFilter<"paystackresponse"> | Date | string
  }

  export type paystackresponseOrderByWithRelationInput = {
    prid?: SortOrder
    prbody?: SortOrder
    pracc_number?: SortOrderInput | SortOrder
    pracc_bank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: paystackresponseOrderByRelevanceInput
  }

  export type paystackresponseWhereUniqueInput = Prisma.AtLeast<{
    prid?: number
    AND?: paystackresponseWhereInput | paystackresponseWhereInput[]
    OR?: paystackresponseWhereInput[]
    NOT?: paystackresponseWhereInput | paystackresponseWhereInput[]
    prbody?: StringFilter<"paystackresponse"> | string
    pracc_number?: StringNullableFilter<"paystackresponse"> | string | null
    pracc_bank?: StringNullableFilter<"paystackresponse"> | string | null
    createdAt?: DateTimeFilter<"paystackresponse"> | Date | string
  }, "prid">

  export type paystackresponseOrderByWithAggregationInput = {
    prid?: SortOrder
    prbody?: SortOrder
    pracc_number?: SortOrderInput | SortOrder
    pracc_bank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: paystackresponseCountOrderByAggregateInput
    _avg?: paystackresponseAvgOrderByAggregateInput
    _max?: paystackresponseMaxOrderByAggregateInput
    _min?: paystackresponseMinOrderByAggregateInput
    _sum?: paystackresponseSumOrderByAggregateInput
  }

  export type paystackresponseScalarWhereWithAggregatesInput = {
    AND?: paystackresponseScalarWhereWithAggregatesInput | paystackresponseScalarWhereWithAggregatesInput[]
    OR?: paystackresponseScalarWhereWithAggregatesInput[]
    NOT?: paystackresponseScalarWhereWithAggregatesInput | paystackresponseScalarWhereWithAggregatesInput[]
    prid?: IntWithAggregatesFilter<"paystackresponse"> | number
    prbody?: StringWithAggregatesFilter<"paystackresponse"> | string
    pracc_number?: StringNullableWithAggregatesFilter<"paystackresponse"> | string | null
    pracc_bank?: StringNullableWithAggregatesFilter<"paystackresponse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"paystackresponse"> | Date | string
  }

  export type productcategoriesWhereInput = {
    AND?: productcategoriesWhereInput | productcategoriesWhereInput[]
    OR?: productcategoriesWhereInput[]
    NOT?: productcategoriesWhereInput | productcategoriesWhereInput[]
    pcid?: IntFilter<"productcategories"> | number
    pcatname?: StringFilter<"productcategories"> | string
    pcatslug?: StringFilter<"productcategories"> | string
    pcatpicture?: StringFilter<"productcategories"> | string
    pcatdesc?: StringFilter<"productcategories"> | string
    createdAt?: DateTimeFilter<"productcategories"> | Date | string
    updatedAt?: DateTimeFilter<"productcategories"> | Date | string
  }

  export type productcategoriesOrderByWithRelationInput = {
    pcid?: SortOrder
    pcatname?: SortOrder
    pcatslug?: SortOrder
    pcatpicture?: SortOrder
    pcatdesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: productcategoriesOrderByRelevanceInput
  }

  export type productcategoriesWhereUniqueInput = Prisma.AtLeast<{
    pcid?: number
    AND?: productcategoriesWhereInput | productcategoriesWhereInput[]
    OR?: productcategoriesWhereInput[]
    NOT?: productcategoriesWhereInput | productcategoriesWhereInput[]
    pcatname?: StringFilter<"productcategories"> | string
    pcatslug?: StringFilter<"productcategories"> | string
    pcatpicture?: StringFilter<"productcategories"> | string
    pcatdesc?: StringFilter<"productcategories"> | string
    createdAt?: DateTimeFilter<"productcategories"> | Date | string
    updatedAt?: DateTimeFilter<"productcategories"> | Date | string
  }, "pcid">

  export type productcategoriesOrderByWithAggregationInput = {
    pcid?: SortOrder
    pcatname?: SortOrder
    pcatslug?: SortOrder
    pcatpicture?: SortOrder
    pcatdesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: productcategoriesCountOrderByAggregateInput
    _avg?: productcategoriesAvgOrderByAggregateInput
    _max?: productcategoriesMaxOrderByAggregateInput
    _min?: productcategoriesMinOrderByAggregateInput
    _sum?: productcategoriesSumOrderByAggregateInput
  }

  export type productcategoriesScalarWhereWithAggregatesInput = {
    AND?: productcategoriesScalarWhereWithAggregatesInput | productcategoriesScalarWhereWithAggregatesInput[]
    OR?: productcategoriesScalarWhereWithAggregatesInput[]
    NOT?: productcategoriesScalarWhereWithAggregatesInput | productcategoriesScalarWhereWithAggregatesInput[]
    pcid?: IntWithAggregatesFilter<"productcategories"> | number
    pcatname?: StringWithAggregatesFilter<"productcategories"> | string
    pcatslug?: StringWithAggregatesFilter<"productcategories"> | string
    pcatpicture?: StringWithAggregatesFilter<"productcategories"> | string
    pcatdesc?: StringWithAggregatesFilter<"productcategories"> | string
    createdAt?: DateTimeWithAggregatesFilter<"productcategories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"productcategories"> | Date | string
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: IntFilter<"products"> | number
    category?: StringFilter<"products"> | string
    catslug?: StringFilter<"products"> | string
    uuid?: StringNullableFilter<"products"> | string | null
    name?: StringFilter<"products"> | string
    nameslug?: StringFilter<"products"> | string
    sku?: StringFilter<"products"> | string
    description?: StringFilter<"products"> | string
    picture?: StringFilter<"products"> | string
    price?: FloatFilter<"products"> | number
    size?: StringFilter<"products"> | string
    response_time?: StringNullableFilter<"products"> | string | null
    status?: BoolFilter<"products"> | boolean
    payment_account?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    catslug?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    nameslug?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    response_time?: SortOrderInput | SortOrder
    status?: SortOrder
    payment_account?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: productsOrderByRelevanceInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    category?: StringFilter<"products"> | string
    catslug?: StringFilter<"products"> | string
    uuid?: StringNullableFilter<"products"> | string | null
    name?: StringFilter<"products"> | string
    nameslug?: StringFilter<"products"> | string
    sku?: StringFilter<"products"> | string
    description?: StringFilter<"products"> | string
    picture?: StringFilter<"products"> | string
    price?: FloatFilter<"products"> | number
    size?: StringFilter<"products"> | string
    response_time?: StringNullableFilter<"products"> | string | null
    status?: BoolFilter<"products"> | boolean
    payment_account?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
  }, "id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    catslug?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    nameslug?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    response_time?: SortOrderInput | SortOrder
    status?: SortOrder
    payment_account?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products"> | number
    category?: StringWithAggregatesFilter<"products"> | string
    catslug?: StringWithAggregatesFilter<"products"> | string
    uuid?: StringNullableWithAggregatesFilter<"products"> | string | null
    name?: StringWithAggregatesFilter<"products"> | string
    nameslug?: StringWithAggregatesFilter<"products"> | string
    sku?: StringWithAggregatesFilter<"products"> | string
    description?: StringWithAggregatesFilter<"products"> | string
    picture?: StringWithAggregatesFilter<"products"> | string
    price?: FloatWithAggregatesFilter<"products"> | number
    size?: StringWithAggregatesFilter<"products"> | string
    response_time?: StringNullableWithAggregatesFilter<"products"> | string | null
    status?: BoolWithAggregatesFilter<"products"> | boolean
    payment_account?: StringWithAggregatesFilter<"products"> | string
    createdAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
  }

  export type requestsWhereInput = {
    AND?: requestsWhereInput | requestsWhereInput[]
    OR?: requestsWhereInput[]
    NOT?: requestsWhereInput | requestsWhereInput[]
    id?: IntFilter<"requests"> | number
    uuid?: StringNullableFilter<"requests"> | string | null
    orderid?: IntFilter<"requests"> | number
    orderref?: StringFilter<"requests"> | string
    orderdetails?: StringFilter<"requests"> | string
    req_type?: StringFilter<"requests"> | string
    task?: StringNullableFilter<"requests"> | string | null
    howmany?: IntNullableFilter<"requests"> | number | null
    productid?: IntFilter<"requests"> | number
    productname?: StringFilter<"requests"> | string
    prod_waittime?: IntNullableFilter<"requests"> | number | null
    amount?: FloatFilter<"requests"> | number
    commission?: FloatFilter<"requests"> | number
    customerid?: IntFilter<"requests"> | number
    customername?: StringFilter<"requests"> | string
    customerphone?: StringFilter<"requests"> | string
    customeraddress?: StringFilter<"requests"> | string
    customerarea?: StringFilter<"requests"> | string
    customerareagroup?: StringNullableFilter<"requests"> | string | null
    third_party_delivery?: StringFilter<"requests"> | string
    third_party_name?: StringNullableFilter<"requests"> | string | null
    third_party_phone?: StringNullableFilter<"requests"> | string | null
    third_party_areagroup?: StringNullableFilter<"requests"> | string | null
    third_party_address?: StringNullableFilter<"requests"> | string | null
    customerlatitude?: DecimalFilter<"requests"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFilter<"requests"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableFilter<"requests"> | string | null
    driverid?: IntNullableFilter<"requests"> | number | null
    drivername?: StringNullableFilter<"requests"> | string | null
    driverphone?: StringNullableFilter<"requests"> | string | null
    driveremail?: StringNullableFilter<"requests"> | string | null
    drivervehicleplateno?: StringNullableFilter<"requests"> | string | null
    status?: StringFilter<"requests"> | string
    views?: IntFilter<"requests"> | number
    createdAt?: DateTimeFilter<"requests"> | Date | string
    updatedAt?: DateTimeFilter<"requests"> | Date | string
  }

  export type requestsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    orderref?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrderInput | SortOrder
    howmany?: SortOrderInput | SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrderInput | SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrderInput | SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrderInput | SortOrder
    third_party_phone?: SortOrderInput | SortOrder
    third_party_areagroup?: SortOrderInput | SortOrder
    third_party_address?: SortOrderInput | SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    address?: SortOrderInput | SortOrder
    driverid?: SortOrderInput | SortOrder
    drivername?: SortOrderInput | SortOrder
    driverphone?: SortOrderInput | SortOrder
    driveremail?: SortOrderInput | SortOrder
    drivervehicleplateno?: SortOrderInput | SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: requestsOrderByRelevanceInput
  }

  export type requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: requestsWhereInput | requestsWhereInput[]
    OR?: requestsWhereInput[]
    NOT?: requestsWhereInput | requestsWhereInput[]
    uuid?: StringNullableFilter<"requests"> | string | null
    orderid?: IntFilter<"requests"> | number
    orderref?: StringFilter<"requests"> | string
    orderdetails?: StringFilter<"requests"> | string
    req_type?: StringFilter<"requests"> | string
    task?: StringNullableFilter<"requests"> | string | null
    howmany?: IntNullableFilter<"requests"> | number | null
    productid?: IntFilter<"requests"> | number
    productname?: StringFilter<"requests"> | string
    prod_waittime?: IntNullableFilter<"requests"> | number | null
    amount?: FloatFilter<"requests"> | number
    commission?: FloatFilter<"requests"> | number
    customerid?: IntFilter<"requests"> | number
    customername?: StringFilter<"requests"> | string
    customerphone?: StringFilter<"requests"> | string
    customeraddress?: StringFilter<"requests"> | string
    customerarea?: StringFilter<"requests"> | string
    customerareagroup?: StringNullableFilter<"requests"> | string | null
    third_party_delivery?: StringFilter<"requests"> | string
    third_party_name?: StringNullableFilter<"requests"> | string | null
    third_party_phone?: StringNullableFilter<"requests"> | string | null
    third_party_areagroup?: StringNullableFilter<"requests"> | string | null
    third_party_address?: StringNullableFilter<"requests"> | string | null
    customerlatitude?: DecimalFilter<"requests"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFilter<"requests"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableFilter<"requests"> | string | null
    driverid?: IntNullableFilter<"requests"> | number | null
    drivername?: StringNullableFilter<"requests"> | string | null
    driverphone?: StringNullableFilter<"requests"> | string | null
    driveremail?: StringNullableFilter<"requests"> | string | null
    drivervehicleplateno?: StringNullableFilter<"requests"> | string | null
    status?: StringFilter<"requests"> | string
    views?: IntFilter<"requests"> | number
    createdAt?: DateTimeFilter<"requests"> | Date | string
    updatedAt?: DateTimeFilter<"requests"> | Date | string
  }, "id">

  export type requestsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    orderref?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrderInput | SortOrder
    howmany?: SortOrderInput | SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrderInput | SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrderInput | SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrderInput | SortOrder
    third_party_phone?: SortOrderInput | SortOrder
    third_party_areagroup?: SortOrderInput | SortOrder
    third_party_address?: SortOrderInput | SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    address?: SortOrderInput | SortOrder
    driverid?: SortOrderInput | SortOrder
    drivername?: SortOrderInput | SortOrder
    driverphone?: SortOrderInput | SortOrder
    driveremail?: SortOrderInput | SortOrder
    drivervehicleplateno?: SortOrderInput | SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: requestsCountOrderByAggregateInput
    _avg?: requestsAvgOrderByAggregateInput
    _max?: requestsMaxOrderByAggregateInput
    _min?: requestsMinOrderByAggregateInput
    _sum?: requestsSumOrderByAggregateInput
  }

  export type requestsScalarWhereWithAggregatesInput = {
    AND?: requestsScalarWhereWithAggregatesInput | requestsScalarWhereWithAggregatesInput[]
    OR?: requestsScalarWhereWithAggregatesInput[]
    NOT?: requestsScalarWhereWithAggregatesInput | requestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"requests"> | number
    uuid?: StringNullableWithAggregatesFilter<"requests"> | string | null
    orderid?: IntWithAggregatesFilter<"requests"> | number
    orderref?: StringWithAggregatesFilter<"requests"> | string
    orderdetails?: StringWithAggregatesFilter<"requests"> | string
    req_type?: StringWithAggregatesFilter<"requests"> | string
    task?: StringNullableWithAggregatesFilter<"requests"> | string | null
    howmany?: IntNullableWithAggregatesFilter<"requests"> | number | null
    productid?: IntWithAggregatesFilter<"requests"> | number
    productname?: StringWithAggregatesFilter<"requests"> | string
    prod_waittime?: IntNullableWithAggregatesFilter<"requests"> | number | null
    amount?: FloatWithAggregatesFilter<"requests"> | number
    commission?: FloatWithAggregatesFilter<"requests"> | number
    customerid?: IntWithAggregatesFilter<"requests"> | number
    customername?: StringWithAggregatesFilter<"requests"> | string
    customerphone?: StringWithAggregatesFilter<"requests"> | string
    customeraddress?: StringWithAggregatesFilter<"requests"> | string
    customerarea?: StringWithAggregatesFilter<"requests"> | string
    customerareagroup?: StringNullableWithAggregatesFilter<"requests"> | string | null
    third_party_delivery?: StringWithAggregatesFilter<"requests"> | string
    third_party_name?: StringNullableWithAggregatesFilter<"requests"> | string | null
    third_party_phone?: StringNullableWithAggregatesFilter<"requests"> | string | null
    third_party_areagroup?: StringNullableWithAggregatesFilter<"requests"> | string | null
    third_party_address?: StringNullableWithAggregatesFilter<"requests"> | string | null
    customerlatitude?: DecimalWithAggregatesFilter<"requests"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalWithAggregatesFilter<"requests"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableWithAggregatesFilter<"requests"> | string | null
    driverid?: IntNullableWithAggregatesFilter<"requests"> | number | null
    drivername?: StringNullableWithAggregatesFilter<"requests"> | string | null
    driverphone?: StringNullableWithAggregatesFilter<"requests"> | string | null
    driveremail?: StringNullableWithAggregatesFilter<"requests"> | string | null
    drivervehicleplateno?: StringNullableWithAggregatesFilter<"requests"> | string | null
    status?: StringWithAggregatesFilter<"requests"> | string
    views?: IntWithAggregatesFilter<"requests"> | number
    createdAt?: DateTimeWithAggregatesFilter<"requests"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"requests"> | Date | string
  }

  export type shopinfoWhereInput = {
    AND?: shopinfoWhereInput | shopinfoWhereInput[]
    OR?: shopinfoWhereInput[]
    NOT?: shopinfoWhereInput | shopinfoWhereInput[]
    shopid?: IntFilter<"shopinfo"> | number
    shopname?: StringFilter<"shopinfo"> | string
    shopdescription?: StringFilter<"shopinfo"> | string
    driver_commission?: FloatFilter<"shopinfo"> | number
    water_merchant_commission?: FloatFilter<"shopinfo"> | number
    shoplogo?: StringNullableFilter<"shopinfo"> | string | null
    shmetakey?: StringFilter<"shopinfo"> | string
    shmetadesc?: StringFilter<"shopinfo"> | string
    shopphone?: StringFilter<"shopinfo"> | string
    shopemailname?: StringFilter<"shopinfo"> | string
    shopemailaddress?: StringFilter<"shopinfo"> | string
    shoporderemail?: StringNullableFilter<"shopinfo"> | string | null
    shopaddress?: StringFilter<"shopinfo"> | string
    shopcity?: StringFilter<"shopinfo"> | string
    shopstate?: StringFilter<"shopinfo"> | string
    shopcountry?: StringFilter<"shopinfo"> | string
    latestonhome?: IntFilter<"shopinfo"> | number
    offline?: IntFilter<"shopinfo"> | number
    offlinemsg?: StringFilter<"shopinfo"> | string
    shopimage?: StringFilter<"shopinfo"> | string
    total_news?: IntFilter<"shopinfo"> | number
    slfacebook?: StringFilter<"shopinfo"> | string
    sltwitter?: StringFilter<"shopinfo"> | string
    slinstagram?: StringFilter<"shopinfo"> | string
    slyoutube?: StringFilter<"shopinfo"> | string
    postedby?: StringFilter<"shopinfo"> | string
    updatedAt?: DateTimeFilter<"shopinfo"> | Date | string
  }

  export type shopinfoOrderByWithRelationInput = {
    shopid?: SortOrder
    shopname?: SortOrder
    shopdescription?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    shoplogo?: SortOrderInput | SortOrder
    shmetakey?: SortOrder
    shmetadesc?: SortOrder
    shopphone?: SortOrder
    shopemailname?: SortOrder
    shopemailaddress?: SortOrder
    shoporderemail?: SortOrderInput | SortOrder
    shopaddress?: SortOrder
    shopcity?: SortOrder
    shopstate?: SortOrder
    shopcountry?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    offlinemsg?: SortOrder
    shopimage?: SortOrder
    total_news?: SortOrder
    slfacebook?: SortOrder
    sltwitter?: SortOrder
    slinstagram?: SortOrder
    slyoutube?: SortOrder
    postedby?: SortOrder
    updatedAt?: SortOrder
    _relevance?: shopinfoOrderByRelevanceInput
  }

  export type shopinfoWhereUniqueInput = Prisma.AtLeast<{
    shopid?: number
    AND?: shopinfoWhereInput | shopinfoWhereInput[]
    OR?: shopinfoWhereInput[]
    NOT?: shopinfoWhereInput | shopinfoWhereInput[]
    shopname?: StringFilter<"shopinfo"> | string
    shopdescription?: StringFilter<"shopinfo"> | string
    driver_commission?: FloatFilter<"shopinfo"> | number
    water_merchant_commission?: FloatFilter<"shopinfo"> | number
    shoplogo?: StringNullableFilter<"shopinfo"> | string | null
    shmetakey?: StringFilter<"shopinfo"> | string
    shmetadesc?: StringFilter<"shopinfo"> | string
    shopphone?: StringFilter<"shopinfo"> | string
    shopemailname?: StringFilter<"shopinfo"> | string
    shopemailaddress?: StringFilter<"shopinfo"> | string
    shoporderemail?: StringNullableFilter<"shopinfo"> | string | null
    shopaddress?: StringFilter<"shopinfo"> | string
    shopcity?: StringFilter<"shopinfo"> | string
    shopstate?: StringFilter<"shopinfo"> | string
    shopcountry?: StringFilter<"shopinfo"> | string
    latestonhome?: IntFilter<"shopinfo"> | number
    offline?: IntFilter<"shopinfo"> | number
    offlinemsg?: StringFilter<"shopinfo"> | string
    shopimage?: StringFilter<"shopinfo"> | string
    total_news?: IntFilter<"shopinfo"> | number
    slfacebook?: StringFilter<"shopinfo"> | string
    sltwitter?: StringFilter<"shopinfo"> | string
    slinstagram?: StringFilter<"shopinfo"> | string
    slyoutube?: StringFilter<"shopinfo"> | string
    postedby?: StringFilter<"shopinfo"> | string
    updatedAt?: DateTimeFilter<"shopinfo"> | Date | string
  }, "shopid">

  export type shopinfoOrderByWithAggregationInput = {
    shopid?: SortOrder
    shopname?: SortOrder
    shopdescription?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    shoplogo?: SortOrderInput | SortOrder
    shmetakey?: SortOrder
    shmetadesc?: SortOrder
    shopphone?: SortOrder
    shopemailname?: SortOrder
    shopemailaddress?: SortOrder
    shoporderemail?: SortOrderInput | SortOrder
    shopaddress?: SortOrder
    shopcity?: SortOrder
    shopstate?: SortOrder
    shopcountry?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    offlinemsg?: SortOrder
    shopimage?: SortOrder
    total_news?: SortOrder
    slfacebook?: SortOrder
    sltwitter?: SortOrder
    slinstagram?: SortOrder
    slyoutube?: SortOrder
    postedby?: SortOrder
    updatedAt?: SortOrder
    _count?: shopinfoCountOrderByAggregateInput
    _avg?: shopinfoAvgOrderByAggregateInput
    _max?: shopinfoMaxOrderByAggregateInput
    _min?: shopinfoMinOrderByAggregateInput
    _sum?: shopinfoSumOrderByAggregateInput
  }

  export type shopinfoScalarWhereWithAggregatesInput = {
    AND?: shopinfoScalarWhereWithAggregatesInput | shopinfoScalarWhereWithAggregatesInput[]
    OR?: shopinfoScalarWhereWithAggregatesInput[]
    NOT?: shopinfoScalarWhereWithAggregatesInput | shopinfoScalarWhereWithAggregatesInput[]
    shopid?: IntWithAggregatesFilter<"shopinfo"> | number
    shopname?: StringWithAggregatesFilter<"shopinfo"> | string
    shopdescription?: StringWithAggregatesFilter<"shopinfo"> | string
    driver_commission?: FloatWithAggregatesFilter<"shopinfo"> | number
    water_merchant_commission?: FloatWithAggregatesFilter<"shopinfo"> | number
    shoplogo?: StringNullableWithAggregatesFilter<"shopinfo"> | string | null
    shmetakey?: StringWithAggregatesFilter<"shopinfo"> | string
    shmetadesc?: StringWithAggregatesFilter<"shopinfo"> | string
    shopphone?: StringWithAggregatesFilter<"shopinfo"> | string
    shopemailname?: StringWithAggregatesFilter<"shopinfo"> | string
    shopemailaddress?: StringWithAggregatesFilter<"shopinfo"> | string
    shoporderemail?: StringNullableWithAggregatesFilter<"shopinfo"> | string | null
    shopaddress?: StringWithAggregatesFilter<"shopinfo"> | string
    shopcity?: StringWithAggregatesFilter<"shopinfo"> | string
    shopstate?: StringWithAggregatesFilter<"shopinfo"> | string
    shopcountry?: StringWithAggregatesFilter<"shopinfo"> | string
    latestonhome?: IntWithAggregatesFilter<"shopinfo"> | number
    offline?: IntWithAggregatesFilter<"shopinfo"> | number
    offlinemsg?: StringWithAggregatesFilter<"shopinfo"> | string
    shopimage?: StringWithAggregatesFilter<"shopinfo"> | string
    total_news?: IntWithAggregatesFilter<"shopinfo"> | number
    slfacebook?: StringWithAggregatesFilter<"shopinfo"> | string
    sltwitter?: StringWithAggregatesFilter<"shopinfo"> | string
    slinstagram?: StringWithAggregatesFilter<"shopinfo"> | string
    slyoutube?: StringWithAggregatesFilter<"shopinfo"> | string
    postedby?: StringWithAggregatesFilter<"shopinfo"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"shopinfo"> | Date | string
  }

  export type sociallinksWhereInput = {
    AND?: sociallinksWhereInput | sociallinksWhereInput[]
    OR?: sociallinksWhereInput[]
    NOT?: sociallinksWhereInput | sociallinksWhereInput[]
    slid?: IntFilter<"sociallinks"> | number
    slimage?: StringNullableFilter<"sociallinks"> | string | null
    sladdress?: StringFilter<"sociallinks"> | string
  }

  export type sociallinksOrderByWithRelationInput = {
    slid?: SortOrder
    slimage?: SortOrderInput | SortOrder
    sladdress?: SortOrder
    _relevance?: sociallinksOrderByRelevanceInput
  }

  export type sociallinksWhereUniqueInput = Prisma.AtLeast<{
    slid?: number
    AND?: sociallinksWhereInput | sociallinksWhereInput[]
    OR?: sociallinksWhereInput[]
    NOT?: sociallinksWhereInput | sociallinksWhereInput[]
    slimage?: StringNullableFilter<"sociallinks"> | string | null
    sladdress?: StringFilter<"sociallinks"> | string
  }, "slid">

  export type sociallinksOrderByWithAggregationInput = {
    slid?: SortOrder
    slimage?: SortOrderInput | SortOrder
    sladdress?: SortOrder
    _count?: sociallinksCountOrderByAggregateInput
    _avg?: sociallinksAvgOrderByAggregateInput
    _max?: sociallinksMaxOrderByAggregateInput
    _min?: sociallinksMinOrderByAggregateInput
    _sum?: sociallinksSumOrderByAggregateInput
  }

  export type sociallinksScalarWhereWithAggregatesInput = {
    AND?: sociallinksScalarWhereWithAggregatesInput | sociallinksScalarWhereWithAggregatesInput[]
    OR?: sociallinksScalarWhereWithAggregatesInput[]
    NOT?: sociallinksScalarWhereWithAggregatesInput | sociallinksScalarWhereWithAggregatesInput[]
    slid?: IntWithAggregatesFilter<"sociallinks"> | number
    slimage?: StringNullableWithAggregatesFilter<"sociallinks"> | string | null
    sladdress?: StringWithAggregatesFilter<"sociallinks"> | string
  }

  export type subscriptionWhereInput = {
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    submagid?: IntFilter<"subscription"> | number
    sm_title?: StringNullableFilter<"subscription"> | string | null
    sm_initials?: StringFilter<"subscription"> | string
    sm_surname?: StringFilter<"subscription"> | string
    sm_business?: StringFilter<"subscription"> | string
    sm_address?: StringFilter<"subscription"> | string
    sm_postcode?: StringNullableFilter<"subscription"> | string | null
    sm_country?: StringFilter<"subscription"> | string
    sm_telephone?: StringFilter<"subscription"> | string
    sm_email?: StringFilter<"subscription"> | string
    sm_dateposted?: DateTimeFilter<"subscription"> | Date | string
    sm_amount?: StringFilter<"subscription"> | string
    sm_paid?: StringFilter<"subscription"> | string
    sm_datepaid?: StringFilter<"subscription"> | string
    sm_from?: StringFilter<"subscription"> | string
    sm_to?: StringFilter<"subscription"> | string
  }

  export type subscriptionOrderByWithRelationInput = {
    submagid?: SortOrder
    sm_title?: SortOrderInput | SortOrder
    sm_initials?: SortOrder
    sm_surname?: SortOrder
    sm_business?: SortOrder
    sm_address?: SortOrder
    sm_postcode?: SortOrderInput | SortOrder
    sm_country?: SortOrder
    sm_telephone?: SortOrder
    sm_email?: SortOrder
    sm_dateposted?: SortOrder
    sm_amount?: SortOrder
    sm_paid?: SortOrder
    sm_datepaid?: SortOrder
    sm_from?: SortOrder
    sm_to?: SortOrder
    _relevance?: subscriptionOrderByRelevanceInput
  }

  export type subscriptionWhereUniqueInput = Prisma.AtLeast<{
    submagid?: number
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    sm_title?: StringNullableFilter<"subscription"> | string | null
    sm_initials?: StringFilter<"subscription"> | string
    sm_surname?: StringFilter<"subscription"> | string
    sm_business?: StringFilter<"subscription"> | string
    sm_address?: StringFilter<"subscription"> | string
    sm_postcode?: StringNullableFilter<"subscription"> | string | null
    sm_country?: StringFilter<"subscription"> | string
    sm_telephone?: StringFilter<"subscription"> | string
    sm_email?: StringFilter<"subscription"> | string
    sm_dateposted?: DateTimeFilter<"subscription"> | Date | string
    sm_amount?: StringFilter<"subscription"> | string
    sm_paid?: StringFilter<"subscription"> | string
    sm_datepaid?: StringFilter<"subscription"> | string
    sm_from?: StringFilter<"subscription"> | string
    sm_to?: StringFilter<"subscription"> | string
  }, "submagid">

  export type subscriptionOrderByWithAggregationInput = {
    submagid?: SortOrder
    sm_title?: SortOrderInput | SortOrder
    sm_initials?: SortOrder
    sm_surname?: SortOrder
    sm_business?: SortOrder
    sm_address?: SortOrder
    sm_postcode?: SortOrderInput | SortOrder
    sm_country?: SortOrder
    sm_telephone?: SortOrder
    sm_email?: SortOrder
    sm_dateposted?: SortOrder
    sm_amount?: SortOrder
    sm_paid?: SortOrder
    sm_datepaid?: SortOrder
    sm_from?: SortOrder
    sm_to?: SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _avg?: subscriptionAvgOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
    _sum?: subscriptionSumOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    OR?: subscriptionScalarWhereWithAggregatesInput[]
    NOT?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    submagid?: IntWithAggregatesFilter<"subscription"> | number
    sm_title?: StringNullableWithAggregatesFilter<"subscription"> | string | null
    sm_initials?: StringWithAggregatesFilter<"subscription"> | string
    sm_surname?: StringWithAggregatesFilter<"subscription"> | string
    sm_business?: StringWithAggregatesFilter<"subscription"> | string
    sm_address?: StringWithAggregatesFilter<"subscription"> | string
    sm_postcode?: StringNullableWithAggregatesFilter<"subscription"> | string | null
    sm_country?: StringWithAggregatesFilter<"subscription"> | string
    sm_telephone?: StringWithAggregatesFilter<"subscription"> | string
    sm_email?: StringWithAggregatesFilter<"subscription"> | string
    sm_dateposted?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
    sm_amount?: StringWithAggregatesFilter<"subscription"> | string
    sm_paid?: StringWithAggregatesFilter<"subscription"> | string
    sm_datepaid?: StringWithAggregatesFilter<"subscription"> | string
    sm_from?: StringWithAggregatesFilter<"subscription"> | string
    sm_to?: StringWithAggregatesFilter<"subscription"> | string
  }

  export type team_categoryWhereInput = {
    AND?: team_categoryWhereInput | team_categoryWhereInput[]
    OR?: team_categoryWhereInput[]
    NOT?: team_categoryWhereInput | team_categoryWhereInput[]
    teamcategoryid?: IntFilter<"team_category"> | number
    teamcategory?: StringFilter<"team_category"> | string
    teamcat_slug?: StringFilter<"team_category"> | string
  }

  export type team_categoryOrderByWithRelationInput = {
    teamcategoryid?: SortOrder
    teamcategory?: SortOrder
    teamcat_slug?: SortOrder
    _relevance?: team_categoryOrderByRelevanceInput
  }

  export type team_categoryWhereUniqueInput = Prisma.AtLeast<{
    teamcategoryid?: number
    AND?: team_categoryWhereInput | team_categoryWhereInput[]
    OR?: team_categoryWhereInput[]
    NOT?: team_categoryWhereInput | team_categoryWhereInput[]
    teamcategory?: StringFilter<"team_category"> | string
    teamcat_slug?: StringFilter<"team_category"> | string
  }, "teamcategoryid">

  export type team_categoryOrderByWithAggregationInput = {
    teamcategoryid?: SortOrder
    teamcategory?: SortOrder
    teamcat_slug?: SortOrder
    _count?: team_categoryCountOrderByAggregateInput
    _avg?: team_categoryAvgOrderByAggregateInput
    _max?: team_categoryMaxOrderByAggregateInput
    _min?: team_categoryMinOrderByAggregateInput
    _sum?: team_categorySumOrderByAggregateInput
  }

  export type team_categoryScalarWhereWithAggregatesInput = {
    AND?: team_categoryScalarWhereWithAggregatesInput | team_categoryScalarWhereWithAggregatesInput[]
    OR?: team_categoryScalarWhereWithAggregatesInput[]
    NOT?: team_categoryScalarWhereWithAggregatesInput | team_categoryScalarWhereWithAggregatesInput[]
    teamcategoryid?: IntWithAggregatesFilter<"team_category"> | number
    teamcategory?: StringWithAggregatesFilter<"team_category"> | string
    teamcat_slug?: StringWithAggregatesFilter<"team_category"> | string
  }

  export type team_membersWhereInput = {
    AND?: team_membersWhereInput | team_membersWhereInput[]
    OR?: team_membersWhereInput[]
    NOT?: team_membersWhereInput | team_membersWhereInput[]
    tmemberid?: IntFilter<"team_members"> | number
    tmcategory?: StringNullableFilter<"team_members"> | string | null
    tmember?: StringFilter<"team_members"> | string
    tmember_slug?: StringFilter<"team_members"> | string
    tmemberposition?: StringFilter<"team_members"> | string
    tmemberphoto?: StringFilter<"team_members"> | string
    tmemberprofile?: StringFilter<"team_members"> | string
    tmembersummary?: StringNullableFilter<"team_members"> | string | null
    tmemberdateadded?: DateTimeFilter<"team_members"> | Date | string
    tmemberpostedby?: StringNullableFilter<"team_members"> | string | null
    tmemberrank?: IntFilter<"team_members"> | number
    tmember_email?: StringNullableFilter<"team_members"> | string | null
    tmember_phone?: StringNullableFilter<"team_members"> | string | null
    tmember_facebook?: StringNullableFilter<"team_members"> | string | null
    tmember_twitter?: StringNullableFilter<"team_members"> | string | null
    tmember_linkedin?: StringNullableFilter<"team_members"> | string | null
    tmember_instagram?: StringNullableFilter<"team_members"> | string | null
  }

  export type team_membersOrderByWithRelationInput = {
    tmemberid?: SortOrder
    tmcategory?: SortOrderInput | SortOrder
    tmember?: SortOrder
    tmember_slug?: SortOrder
    tmemberposition?: SortOrder
    tmemberphoto?: SortOrder
    tmemberprofile?: SortOrder
    tmembersummary?: SortOrderInput | SortOrder
    tmemberdateadded?: SortOrder
    tmemberpostedby?: SortOrderInput | SortOrder
    tmemberrank?: SortOrder
    tmember_email?: SortOrderInput | SortOrder
    tmember_phone?: SortOrderInput | SortOrder
    tmember_facebook?: SortOrderInput | SortOrder
    tmember_twitter?: SortOrderInput | SortOrder
    tmember_linkedin?: SortOrderInput | SortOrder
    tmember_instagram?: SortOrderInput | SortOrder
    _relevance?: team_membersOrderByRelevanceInput
  }

  export type team_membersWhereUniqueInput = Prisma.AtLeast<{
    tmemberid?: number
    AND?: team_membersWhereInput | team_membersWhereInput[]
    OR?: team_membersWhereInput[]
    NOT?: team_membersWhereInput | team_membersWhereInput[]
    tmcategory?: StringNullableFilter<"team_members"> | string | null
    tmember?: StringFilter<"team_members"> | string
    tmember_slug?: StringFilter<"team_members"> | string
    tmemberposition?: StringFilter<"team_members"> | string
    tmemberphoto?: StringFilter<"team_members"> | string
    tmemberprofile?: StringFilter<"team_members"> | string
    tmembersummary?: StringNullableFilter<"team_members"> | string | null
    tmemberdateadded?: DateTimeFilter<"team_members"> | Date | string
    tmemberpostedby?: StringNullableFilter<"team_members"> | string | null
    tmemberrank?: IntFilter<"team_members"> | number
    tmember_email?: StringNullableFilter<"team_members"> | string | null
    tmember_phone?: StringNullableFilter<"team_members"> | string | null
    tmember_facebook?: StringNullableFilter<"team_members"> | string | null
    tmember_twitter?: StringNullableFilter<"team_members"> | string | null
    tmember_linkedin?: StringNullableFilter<"team_members"> | string | null
    tmember_instagram?: StringNullableFilter<"team_members"> | string | null
  }, "tmemberid">

  export type team_membersOrderByWithAggregationInput = {
    tmemberid?: SortOrder
    tmcategory?: SortOrderInput | SortOrder
    tmember?: SortOrder
    tmember_slug?: SortOrder
    tmemberposition?: SortOrder
    tmemberphoto?: SortOrder
    tmemberprofile?: SortOrder
    tmembersummary?: SortOrderInput | SortOrder
    tmemberdateadded?: SortOrder
    tmemberpostedby?: SortOrderInput | SortOrder
    tmemberrank?: SortOrder
    tmember_email?: SortOrderInput | SortOrder
    tmember_phone?: SortOrderInput | SortOrder
    tmember_facebook?: SortOrderInput | SortOrder
    tmember_twitter?: SortOrderInput | SortOrder
    tmember_linkedin?: SortOrderInput | SortOrder
    tmember_instagram?: SortOrderInput | SortOrder
    _count?: team_membersCountOrderByAggregateInput
    _avg?: team_membersAvgOrderByAggregateInput
    _max?: team_membersMaxOrderByAggregateInput
    _min?: team_membersMinOrderByAggregateInput
    _sum?: team_membersSumOrderByAggregateInput
  }

  export type team_membersScalarWhereWithAggregatesInput = {
    AND?: team_membersScalarWhereWithAggregatesInput | team_membersScalarWhereWithAggregatesInput[]
    OR?: team_membersScalarWhereWithAggregatesInput[]
    NOT?: team_membersScalarWhereWithAggregatesInput | team_membersScalarWhereWithAggregatesInput[]
    tmemberid?: IntWithAggregatesFilter<"team_members"> | number
    tmcategory?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember?: StringWithAggregatesFilter<"team_members"> | string
    tmember_slug?: StringWithAggregatesFilter<"team_members"> | string
    tmemberposition?: StringWithAggregatesFilter<"team_members"> | string
    tmemberphoto?: StringWithAggregatesFilter<"team_members"> | string
    tmemberprofile?: StringWithAggregatesFilter<"team_members"> | string
    tmembersummary?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmemberdateadded?: DateTimeWithAggregatesFilter<"team_members"> | Date | string
    tmemberpostedby?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmemberrank?: IntWithAggregatesFilter<"team_members"> | number
    tmember_email?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember_phone?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember_facebook?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember_twitter?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember_linkedin?: StringNullableWithAggregatesFilter<"team_members"> | string | null
    tmember_instagram?: StringNullableWithAggregatesFilter<"team_members"> | string | null
  }

  export type testimonialsWhereInput = {
    AND?: testimonialsWhereInput | testimonialsWhereInput[]
    OR?: testimonialsWhereInput[]
    NOT?: testimonialsWhereInput | testimonialsWhereInput[]
    tid?: IntFilter<"testimonials"> | number
    tcustomer?: StringFilter<"testimonials"> | string
    trole?: StringFilter<"testimonials"> | string
    tphoto?: StringFilter<"testimonials"> | string
    tmessage?: StringFilter<"testimonials"> | string
    tstars?: IntFilter<"testimonials"> | number
    tdate?: DateTimeFilter<"testimonials"> | Date | string
    tstatus?: IntFilter<"testimonials"> | number
  }

  export type testimonialsOrderByWithRelationInput = {
    tid?: SortOrder
    tcustomer?: SortOrder
    trole?: SortOrder
    tphoto?: SortOrder
    tmessage?: SortOrder
    tstars?: SortOrder
    tdate?: SortOrder
    tstatus?: SortOrder
    _relevance?: testimonialsOrderByRelevanceInput
  }

  export type testimonialsWhereUniqueInput = Prisma.AtLeast<{
    tid?: number
    AND?: testimonialsWhereInput | testimonialsWhereInput[]
    OR?: testimonialsWhereInput[]
    NOT?: testimonialsWhereInput | testimonialsWhereInput[]
    tcustomer?: StringFilter<"testimonials"> | string
    trole?: StringFilter<"testimonials"> | string
    tphoto?: StringFilter<"testimonials"> | string
    tmessage?: StringFilter<"testimonials"> | string
    tstars?: IntFilter<"testimonials"> | number
    tdate?: DateTimeFilter<"testimonials"> | Date | string
    tstatus?: IntFilter<"testimonials"> | number
  }, "tid">

  export type testimonialsOrderByWithAggregationInput = {
    tid?: SortOrder
    tcustomer?: SortOrder
    trole?: SortOrder
    tphoto?: SortOrder
    tmessage?: SortOrder
    tstars?: SortOrder
    tdate?: SortOrder
    tstatus?: SortOrder
    _count?: testimonialsCountOrderByAggregateInput
    _avg?: testimonialsAvgOrderByAggregateInput
    _max?: testimonialsMaxOrderByAggregateInput
    _min?: testimonialsMinOrderByAggregateInput
    _sum?: testimonialsSumOrderByAggregateInput
  }

  export type testimonialsScalarWhereWithAggregatesInput = {
    AND?: testimonialsScalarWhereWithAggregatesInput | testimonialsScalarWhereWithAggregatesInput[]
    OR?: testimonialsScalarWhereWithAggregatesInput[]
    NOT?: testimonialsScalarWhereWithAggregatesInput | testimonialsScalarWhereWithAggregatesInput[]
    tid?: IntWithAggregatesFilter<"testimonials"> | number
    tcustomer?: StringWithAggregatesFilter<"testimonials"> | string
    trole?: StringWithAggregatesFilter<"testimonials"> | string
    tphoto?: StringWithAggregatesFilter<"testimonials"> | string
    tmessage?: StringWithAggregatesFilter<"testimonials"> | string
    tstars?: IntWithAggregatesFilter<"testimonials"> | number
    tdate?: DateTimeWithAggregatesFilter<"testimonials"> | Date | string
    tstatus?: IntWithAggregatesFilter<"testimonials"> | number
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    id?: IntFilter<"transactions"> | number
    uuid?: StringNullableFilter<"transactions"> | string | null
    orderref?: StringFilter<"transactions"> | string
    productid?: IntFilter<"transactions"> | number
    productname?: StringFilter<"transactions"> | string
    prod_waittime?: IntNullableFilter<"transactions"> | number | null
    product_subscription?: StringFilter<"transactions"> | string
    qty?: IntFilter<"transactions"> | number
    orderdetails?: StringFilter<"transactions"> | string
    req_type?: StringFilter<"transactions"> | string
    task?: StringNullableFilter<"transactions"> | string | null
    howmany?: IntNullableFilter<"transactions"> | number | null
    amount?: FloatFilter<"transactions"> | number
    commission?: FloatFilter<"transactions"> | number
    driverfee?: FloatFilter<"transactions"> | number
    driverid?: StringNullableFilter<"transactions"> | string | null
    drivername?: StringFilter<"transactions"> | string
    driverphone?: StringFilter<"transactions"> | string
    driveremail?: StringFilter<"transactions"> | string
    drivervehicleplateno?: StringFilter<"transactions"> | string
    driverphoto?: StringFilter<"transactions"> | string
    fleetid?: StringNullableFilter<"transactions"> | string | null
    driverlatitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driveraccept?: StringNullableFilter<"transactions"> | string | null
    customerid?: StringNullableFilter<"transactions"> | string | null
    customername?: StringFilter<"transactions"> | string
    customeremail?: StringFilter<"transactions"> | string
    customerphone?: StringFilter<"transactions"> | string
    customeraddress?: StringFilter<"transactions"> | string
    customerarea?: StringFilter<"transactions"> | string
    customerareagroup?: StringNullableFilter<"transactions"> | string | null
    third_party_delivery?: StringFilter<"transactions"> | string
    third_party_name?: StringNullableFilter<"transactions"> | string | null
    third_party_phone?: StringNullableFilter<"transactions"> | string | null
    third_party_areagroup?: StringNullableFilter<"transactions"> | string | null
    third_party_address?: StringNullableFilter<"transactions"> | string | null
    customerlatitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"transactions"> | string
    paymentstatus?: StringFilter<"transactions"> | string
    paymentmode?: StringFilter<"transactions"> | string
    paymenttime?: StringNullableFilter<"transactions"> | string | null
    driverdeliverystatus?: StringFilter<"transactions"> | string
    driverdeliverystatustime?: StringNullableFilter<"transactions"> | string | null
    driverdeliverytime?: IntFilter<"transactions"> | number
    customerdeliverystatus?: StringFilter<"transactions"> | string
    customerdeliverystatustime?: StringNullableFilter<"transactions"> | string | null
    customerwaittime?: IntFilter<"transactions"> | number
    orderprocessed?: BoolFilter<"transactions"> | boolean
    commission_paid?: IntFilter<"transactions"> | number
    driverrating?: IntNullableFilter<"transactions"> | number | null
    driverfeedback?: StringNullableFilter<"transactions"> | string | null
    notes?: StringFilter<"transactions"> | string
    views?: IntFilter<"transactions"> | number
    createdAt?: DateTimeFilter<"transactions"> | Date | string
    updatedAt?: DateTimeFilter<"transactions"> | Date | string
  }

  export type transactionsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderref?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrderInput | SortOrder
    product_subscription?: SortOrder
    qty?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrderInput | SortOrder
    howmany?: SortOrderInput | SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverid?: SortOrderInput | SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    driverphoto?: SortOrder
    fleetid?: SortOrderInput | SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    driveraccept?: SortOrderInput | SortOrder
    customerid?: SortOrderInput | SortOrder
    customername?: SortOrder
    customeremail?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrderInput | SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrderInput | SortOrder
    third_party_phone?: SortOrderInput | SortOrder
    third_party_areagroup?: SortOrderInput | SortOrder
    third_party_address?: SortOrderInput | SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    status?: SortOrder
    paymentstatus?: SortOrder
    paymentmode?: SortOrder
    paymenttime?: SortOrderInput | SortOrder
    driverdeliverystatus?: SortOrder
    driverdeliverystatustime?: SortOrderInput | SortOrder
    driverdeliverytime?: SortOrder
    customerdeliverystatus?: SortOrder
    customerdeliverystatustime?: SortOrderInput | SortOrder
    customerwaittime?: SortOrder
    orderprocessed?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrderInput | SortOrder
    driverfeedback?: SortOrderInput | SortOrder
    notes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: transactionsOrderByRelevanceInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    uuid?: StringNullableFilter<"transactions"> | string | null
    orderref?: StringFilter<"transactions"> | string
    productid?: IntFilter<"transactions"> | number
    productname?: StringFilter<"transactions"> | string
    prod_waittime?: IntNullableFilter<"transactions"> | number | null
    product_subscription?: StringFilter<"transactions"> | string
    qty?: IntFilter<"transactions"> | number
    orderdetails?: StringFilter<"transactions"> | string
    req_type?: StringFilter<"transactions"> | string
    task?: StringNullableFilter<"transactions"> | string | null
    howmany?: IntNullableFilter<"transactions"> | number | null
    amount?: FloatFilter<"transactions"> | number
    commission?: FloatFilter<"transactions"> | number
    driverfee?: FloatFilter<"transactions"> | number
    driverid?: StringNullableFilter<"transactions"> | string | null
    drivername?: StringFilter<"transactions"> | string
    driverphone?: StringFilter<"transactions"> | string
    driveremail?: StringFilter<"transactions"> | string
    drivervehicleplateno?: StringFilter<"transactions"> | string
    driverphoto?: StringFilter<"transactions"> | string
    fleetid?: StringNullableFilter<"transactions"> | string | null
    driverlatitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driveraccept?: StringNullableFilter<"transactions"> | string | null
    customerid?: StringNullableFilter<"transactions"> | string | null
    customername?: StringFilter<"transactions"> | string
    customeremail?: StringFilter<"transactions"> | string
    customerphone?: StringFilter<"transactions"> | string
    customeraddress?: StringFilter<"transactions"> | string
    customerarea?: StringFilter<"transactions"> | string
    customerareagroup?: StringNullableFilter<"transactions"> | string | null
    third_party_delivery?: StringFilter<"transactions"> | string
    third_party_name?: StringNullableFilter<"transactions"> | string | null
    third_party_phone?: StringNullableFilter<"transactions"> | string | null
    third_party_areagroup?: StringNullableFilter<"transactions"> | string | null
    third_party_address?: StringNullableFilter<"transactions"> | string | null
    customerlatitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"transactions"> | string
    paymentstatus?: StringFilter<"transactions"> | string
    paymentmode?: StringFilter<"transactions"> | string
    paymenttime?: StringNullableFilter<"transactions"> | string | null
    driverdeliverystatus?: StringFilter<"transactions"> | string
    driverdeliverystatustime?: StringNullableFilter<"transactions"> | string | null
    driverdeliverytime?: IntFilter<"transactions"> | number
    customerdeliverystatus?: StringFilter<"transactions"> | string
    customerdeliverystatustime?: StringNullableFilter<"transactions"> | string | null
    customerwaittime?: IntFilter<"transactions"> | number
    orderprocessed?: BoolFilter<"transactions"> | boolean
    commission_paid?: IntFilter<"transactions"> | number
    driverrating?: IntNullableFilter<"transactions"> | number | null
    driverfeedback?: StringNullableFilter<"transactions"> | string | null
    notes?: StringFilter<"transactions"> | string
    views?: IntFilter<"transactions"> | number
    createdAt?: DateTimeFilter<"transactions"> | Date | string
    updatedAt?: DateTimeFilter<"transactions"> | Date | string
  }, "id">

  export type transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderref?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrderInput | SortOrder
    product_subscription?: SortOrder
    qty?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrderInput | SortOrder
    howmany?: SortOrderInput | SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverid?: SortOrderInput | SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    driverphoto?: SortOrder
    fleetid?: SortOrderInput | SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    driveraccept?: SortOrderInput | SortOrder
    customerid?: SortOrderInput | SortOrder
    customername?: SortOrder
    customeremail?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrderInput | SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrderInput | SortOrder
    third_party_phone?: SortOrderInput | SortOrder
    third_party_areagroup?: SortOrderInput | SortOrder
    third_party_address?: SortOrderInput | SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    status?: SortOrder
    paymentstatus?: SortOrder
    paymentmode?: SortOrder
    paymenttime?: SortOrderInput | SortOrder
    driverdeliverystatus?: SortOrder
    driverdeliverystatustime?: SortOrderInput | SortOrder
    driverdeliverytime?: SortOrder
    customerdeliverystatus?: SortOrder
    customerdeliverystatustime?: SortOrderInput | SortOrder
    customerwaittime?: SortOrder
    orderprocessed?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrderInput | SortOrder
    driverfeedback?: SortOrderInput | SortOrder
    notes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transactions"> | number
    uuid?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    orderref?: StringWithAggregatesFilter<"transactions"> | string
    productid?: IntWithAggregatesFilter<"transactions"> | number
    productname?: StringWithAggregatesFilter<"transactions"> | string
    prod_waittime?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    product_subscription?: StringWithAggregatesFilter<"transactions"> | string
    qty?: IntWithAggregatesFilter<"transactions"> | number
    orderdetails?: StringWithAggregatesFilter<"transactions"> | string
    req_type?: StringWithAggregatesFilter<"transactions"> | string
    task?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    howmany?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    amount?: FloatWithAggregatesFilter<"transactions"> | number
    commission?: FloatWithAggregatesFilter<"transactions"> | number
    driverfee?: FloatWithAggregatesFilter<"transactions"> | number
    driverid?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    drivername?: StringWithAggregatesFilter<"transactions"> | string
    driverphone?: StringWithAggregatesFilter<"transactions"> | string
    driveremail?: StringWithAggregatesFilter<"transactions"> | string
    drivervehicleplateno?: StringWithAggregatesFilter<"transactions"> | string
    driverphoto?: StringWithAggregatesFilter<"transactions"> | string
    fleetid?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    driverlatitude?: DecimalWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    driveraccept?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    customerid?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    customername?: StringWithAggregatesFilter<"transactions"> | string
    customeremail?: StringWithAggregatesFilter<"transactions"> | string
    customerphone?: StringWithAggregatesFilter<"transactions"> | string
    customeraddress?: StringWithAggregatesFilter<"transactions"> | string
    customerarea?: StringWithAggregatesFilter<"transactions"> | string
    customerareagroup?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    third_party_delivery?: StringWithAggregatesFilter<"transactions"> | string
    third_party_name?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    third_party_phone?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    third_party_areagroup?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    third_party_address?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    customerlatitude?: DecimalWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalWithAggregatesFilter<"transactions"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"transactions"> | string
    paymentstatus?: StringWithAggregatesFilter<"transactions"> | string
    paymentmode?: StringWithAggregatesFilter<"transactions"> | string
    paymenttime?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    driverdeliverystatus?: StringWithAggregatesFilter<"transactions"> | string
    driverdeliverystatustime?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    driverdeliverytime?: IntWithAggregatesFilter<"transactions"> | number
    customerdeliverystatus?: StringWithAggregatesFilter<"transactions"> | string
    customerdeliverystatustime?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    customerwaittime?: IntWithAggregatesFilter<"transactions"> | number
    orderprocessed?: BoolWithAggregatesFilter<"transactions"> | boolean
    commission_paid?: IntWithAggregatesFilter<"transactions"> | number
    driverrating?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    driverfeedback?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    notes?: StringWithAggregatesFilter<"transactions"> | string
    views?: IntWithAggregatesFilter<"transactions"> | number
    createdAt?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
  }

  export type usermessagesWhereInput = {
    AND?: usermessagesWhereInput | usermessagesWhereInput[]
    OR?: usermessagesWhereInput[]
    NOT?: usermessagesWhereInput | usermessagesWhereInput[]
    umsgid?: IntFilter<"usermessages"> | number
    umsg_user?: StringFilter<"usermessages"> | string
    umsg_cat?: StringFilter<"usermessages"> | string
    umsg_title?: StringFilter<"usermessages"> | string
    umsg_body?: StringFilter<"usermessages"> | string
    umsg_read?: IntFilter<"usermessages"> | number
    umsg_time?: DateTimeFilter<"usermessages"> | Date | string
    umsg_sender?: StringFilter<"usermessages"> | string
  }

  export type usermessagesOrderByWithRelationInput = {
    umsgid?: SortOrder
    umsg_user?: SortOrder
    umsg_cat?: SortOrder
    umsg_title?: SortOrder
    umsg_body?: SortOrder
    umsg_read?: SortOrder
    umsg_time?: SortOrder
    umsg_sender?: SortOrder
    _relevance?: usermessagesOrderByRelevanceInput
  }

  export type usermessagesWhereUniqueInput = Prisma.AtLeast<{
    umsgid?: number
    AND?: usermessagesWhereInput | usermessagesWhereInput[]
    OR?: usermessagesWhereInput[]
    NOT?: usermessagesWhereInput | usermessagesWhereInput[]
    umsg_user?: StringFilter<"usermessages"> | string
    umsg_cat?: StringFilter<"usermessages"> | string
    umsg_title?: StringFilter<"usermessages"> | string
    umsg_body?: StringFilter<"usermessages"> | string
    umsg_read?: IntFilter<"usermessages"> | number
    umsg_time?: DateTimeFilter<"usermessages"> | Date | string
    umsg_sender?: StringFilter<"usermessages"> | string
  }, "umsgid">

  export type usermessagesOrderByWithAggregationInput = {
    umsgid?: SortOrder
    umsg_user?: SortOrder
    umsg_cat?: SortOrder
    umsg_title?: SortOrder
    umsg_body?: SortOrder
    umsg_read?: SortOrder
    umsg_time?: SortOrder
    umsg_sender?: SortOrder
    _count?: usermessagesCountOrderByAggregateInput
    _avg?: usermessagesAvgOrderByAggregateInput
    _max?: usermessagesMaxOrderByAggregateInput
    _min?: usermessagesMinOrderByAggregateInput
    _sum?: usermessagesSumOrderByAggregateInput
  }

  export type usermessagesScalarWhereWithAggregatesInput = {
    AND?: usermessagesScalarWhereWithAggregatesInput | usermessagesScalarWhereWithAggregatesInput[]
    OR?: usermessagesScalarWhereWithAggregatesInput[]
    NOT?: usermessagesScalarWhereWithAggregatesInput | usermessagesScalarWhereWithAggregatesInput[]
    umsgid?: IntWithAggregatesFilter<"usermessages"> | number
    umsg_user?: StringWithAggregatesFilter<"usermessages"> | string
    umsg_cat?: StringWithAggregatesFilter<"usermessages"> | string
    umsg_title?: StringWithAggregatesFilter<"usermessages"> | string
    umsg_body?: StringWithAggregatesFilter<"usermessages"> | string
    umsg_read?: IntWithAggregatesFilter<"usermessages"> | number
    umsg_time?: DateTimeWithAggregatesFilter<"usermessages"> | Date | string
    umsg_sender?: StringWithAggregatesFilter<"usermessages"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    uuid?: StringNullableFilter<"users"> | string | null
    fleetid?: IntNullableFilter<"users"> | number | null
    name?: StringFilter<"users"> | string
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    dob?: StringNullableFilter<"users"> | string | null
    subscription_plan?: StringFilter<"users"> | string
    subscription_end?: DateTimeNullableFilter<"users"> | Date | string | null
    address?: StringNullableFilter<"users"> | string | null
    area?: StringNullableFilter<"users"> | string | null
    areagroup?: StringNullableFilter<"users"> | string | null
    residencestate?: StringNullableFilter<"users"> | string | null
    latitude?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    role?: StringFilter<"users"> | string
    user_type?: StringNullableFilter<"users"> | string | null
    expotoken?: StringNullableFilter<"users"> | string | null
    photo?: StringNullableFilter<"users"> | string | null
    identification?: StringNullableFilter<"users"> | string | null
    identification_back?: StringNullableFilter<"users"> | string | null
    drv_license?: StringNullableFilter<"users"> | string | null
    drv_license_back?: StringNullableFilter<"users"> | string | null
    drv_vehicle_license_plate_no?: StringNullableFilter<"users"> | string | null
    drv_vehicle_capacity?: StringNullableFilter<"users"> | string | null
    drv_vehicle_make?: StringNullableFilter<"users"> | string | null
    drv_vehicle_meterid?: StringNullableFilter<"users"> | string | null
    drv_account_name?: StringNullableFilter<"users"> | string | null
    drv_account_no?: StringNullableFilter<"users"> | string | null
    drv_bank?: StringNullableFilter<"users"> | string | null
    psv_customer_name?: StringNullableFilter<"users"> | string | null
    psv_account_name?: StringNullableFilter<"users"> | string | null
    psv_account_number?: StringNullableFilter<"users"> | string | null
    psv_bank?: StringNullableFilter<"users"> | string | null
    isverified?: BoolNullableFilter<"users"> | boolean | null
    verifiedby?: StringNullableFilter<"users"> | string | null
    isavailable?: BoolNullableFilter<"users"> | boolean | null
    isavailable_by?: StringNullableFilter<"users"> | string | null
    isavailable_reason?: StringNullableFilter<"users"> | string | null
    commissions_outstanding?: FloatNullableFilter<"users"> | number | null
    commission_payment_ref?: StringNullableFilter<"users"> | string | null
    isactive?: BoolNullableFilter<"users"> | boolean | null
    isadmin?: BoolNullableFilter<"users"> | boolean | null
    terms?: BoolNullableFilter<"users"> | boolean | null
    enable2fa?: StringFilter<"users"> | string
    code2fa?: StringNullableFilter<"users"> | string | null
    expiry2fa?: StringNullableFilter<"users"> | string | null
    signupotp?: StringNullableFilter<"users"> | string | null
    wm_wait_list?: IntFilter<"users"> | number
    views?: IntFilter<"users"> | number
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    first_meter_readings?: MeterReadingsListRelationFilter
    afternoon_meter_readings?: MeterReadingsListRelationFilter
    last_meter_readings?: MeterReadingsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    fleetid?: SortOrderInput | SortOrder
    name?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    subscription_plan?: SortOrder
    subscription_end?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    areagroup?: SortOrderInput | SortOrder
    residencestate?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    role?: SortOrder
    user_type?: SortOrderInput | SortOrder
    expotoken?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    identification_back?: SortOrderInput | SortOrder
    drv_license?: SortOrderInput | SortOrder
    drv_license_back?: SortOrderInput | SortOrder
    drv_vehicle_license_plate_no?: SortOrderInput | SortOrder
    drv_vehicle_capacity?: SortOrderInput | SortOrder
    drv_vehicle_make?: SortOrderInput | SortOrder
    drv_vehicle_meterid?: SortOrderInput | SortOrder
    drv_account_name?: SortOrderInput | SortOrder
    drv_account_no?: SortOrderInput | SortOrder
    drv_bank?: SortOrderInput | SortOrder
    psv_customer_name?: SortOrderInput | SortOrder
    psv_account_name?: SortOrderInput | SortOrder
    psv_account_number?: SortOrderInput | SortOrder
    psv_bank?: SortOrderInput | SortOrder
    isverified?: SortOrderInput | SortOrder
    verifiedby?: SortOrderInput | SortOrder
    isavailable?: SortOrderInput | SortOrder
    isavailable_by?: SortOrderInput | SortOrder
    isavailable_reason?: SortOrderInput | SortOrder
    commissions_outstanding?: SortOrderInput | SortOrder
    commission_payment_ref?: SortOrderInput | SortOrder
    isactive?: SortOrderInput | SortOrder
    isadmin?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    enable2fa?: SortOrder
    code2fa?: SortOrderInput | SortOrder
    expiry2fa?: SortOrderInput | SortOrder
    signupotp?: SortOrderInput | SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    first_meter_readings?: MeterReadingsOrderByRelationAggregateInput
    afternoon_meter_readings?: MeterReadingsOrderByRelationAggregateInput
    last_meter_readings?: MeterReadingsOrderByRelationAggregateInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    uuid?: StringNullableFilter<"users"> | string | null
    fleetid?: IntNullableFilter<"users"> | number | null
    name?: StringFilter<"users"> | string
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    password?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    dob?: StringNullableFilter<"users"> | string | null
    subscription_plan?: StringFilter<"users"> | string
    subscription_end?: DateTimeNullableFilter<"users"> | Date | string | null
    address?: StringNullableFilter<"users"> | string | null
    area?: StringNullableFilter<"users"> | string | null
    areagroup?: StringNullableFilter<"users"> | string | null
    residencestate?: StringNullableFilter<"users"> | string | null
    latitude?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    role?: StringFilter<"users"> | string
    user_type?: StringNullableFilter<"users"> | string | null
    expotoken?: StringNullableFilter<"users"> | string | null
    photo?: StringNullableFilter<"users"> | string | null
    identification?: StringNullableFilter<"users"> | string | null
    identification_back?: StringNullableFilter<"users"> | string | null
    drv_license?: StringNullableFilter<"users"> | string | null
    drv_license_back?: StringNullableFilter<"users"> | string | null
    drv_vehicle_license_plate_no?: StringNullableFilter<"users"> | string | null
    drv_vehicle_capacity?: StringNullableFilter<"users"> | string | null
    drv_vehicle_make?: StringNullableFilter<"users"> | string | null
    drv_vehicle_meterid?: StringNullableFilter<"users"> | string | null
    drv_account_name?: StringNullableFilter<"users"> | string | null
    drv_account_no?: StringNullableFilter<"users"> | string | null
    drv_bank?: StringNullableFilter<"users"> | string | null
    psv_customer_name?: StringNullableFilter<"users"> | string | null
    psv_account_name?: StringNullableFilter<"users"> | string | null
    psv_account_number?: StringNullableFilter<"users"> | string | null
    psv_bank?: StringNullableFilter<"users"> | string | null
    isverified?: BoolNullableFilter<"users"> | boolean | null
    verifiedby?: StringNullableFilter<"users"> | string | null
    isavailable?: BoolNullableFilter<"users"> | boolean | null
    isavailable_by?: StringNullableFilter<"users"> | string | null
    isavailable_reason?: StringNullableFilter<"users"> | string | null
    commissions_outstanding?: FloatNullableFilter<"users"> | number | null
    commission_payment_ref?: StringNullableFilter<"users"> | string | null
    isactive?: BoolNullableFilter<"users"> | boolean | null
    isadmin?: BoolNullableFilter<"users"> | boolean | null
    terms?: BoolNullableFilter<"users"> | boolean | null
    enable2fa?: StringFilter<"users"> | string
    code2fa?: StringNullableFilter<"users"> | string | null
    expiry2fa?: StringNullableFilter<"users"> | string | null
    signupotp?: StringNullableFilter<"users"> | string | null
    wm_wait_list?: IntFilter<"users"> | number
    views?: IntFilter<"users"> | number
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    first_meter_readings?: MeterReadingsListRelationFilter
    afternoon_meter_readings?: MeterReadingsListRelationFilter
    last_meter_readings?: MeterReadingsListRelationFilter
  }, "id" | "username" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    fleetid?: SortOrderInput | SortOrder
    name?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    subscription_plan?: SortOrder
    subscription_end?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    areagroup?: SortOrderInput | SortOrder
    residencestate?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    role?: SortOrder
    user_type?: SortOrderInput | SortOrder
    expotoken?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    identification_back?: SortOrderInput | SortOrder
    drv_license?: SortOrderInput | SortOrder
    drv_license_back?: SortOrderInput | SortOrder
    drv_vehicle_license_plate_no?: SortOrderInput | SortOrder
    drv_vehicle_capacity?: SortOrderInput | SortOrder
    drv_vehicle_make?: SortOrderInput | SortOrder
    drv_vehicle_meterid?: SortOrderInput | SortOrder
    drv_account_name?: SortOrderInput | SortOrder
    drv_account_no?: SortOrderInput | SortOrder
    drv_bank?: SortOrderInput | SortOrder
    psv_customer_name?: SortOrderInput | SortOrder
    psv_account_name?: SortOrderInput | SortOrder
    psv_account_number?: SortOrderInput | SortOrder
    psv_bank?: SortOrderInput | SortOrder
    isverified?: SortOrderInput | SortOrder
    verifiedby?: SortOrderInput | SortOrder
    isavailable?: SortOrderInput | SortOrder
    isavailable_by?: SortOrderInput | SortOrder
    isavailable_reason?: SortOrderInput | SortOrder
    commissions_outstanding?: SortOrderInput | SortOrder
    commission_payment_ref?: SortOrderInput | SortOrder
    isactive?: SortOrderInput | SortOrder
    isadmin?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    enable2fa?: SortOrder
    code2fa?: SortOrderInput | SortOrder
    expiry2fa?: SortOrderInput | SortOrder
    signupotp?: SortOrderInput | SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    uuid?: StringNullableWithAggregatesFilter<"users"> | string | null
    fleetid?: IntNullableWithAggregatesFilter<"users"> | number | null
    name?: StringWithAggregatesFilter<"users"> | string
    first_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    dob?: StringNullableWithAggregatesFilter<"users"> | string | null
    subscription_plan?: StringWithAggregatesFilter<"users"> | string
    subscription_end?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    area?: StringNullableWithAggregatesFilter<"users"> | string | null
    areagroup?: StringNullableWithAggregatesFilter<"users"> | string | null
    residencestate?: StringNullableWithAggregatesFilter<"users"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"users"> | Decimal | DecimalJsLike | number | string | null
    role?: StringWithAggregatesFilter<"users"> | string
    user_type?: StringNullableWithAggregatesFilter<"users"> | string | null
    expotoken?: StringNullableWithAggregatesFilter<"users"> | string | null
    photo?: StringNullableWithAggregatesFilter<"users"> | string | null
    identification?: StringNullableWithAggregatesFilter<"users"> | string | null
    identification_back?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_license?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_license_back?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_vehicle_license_plate_no?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_vehicle_capacity?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_vehicle_make?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_vehicle_meterid?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_account_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_account_no?: StringNullableWithAggregatesFilter<"users"> | string | null
    drv_bank?: StringNullableWithAggregatesFilter<"users"> | string | null
    psv_customer_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    psv_account_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    psv_account_number?: StringNullableWithAggregatesFilter<"users"> | string | null
    psv_bank?: StringNullableWithAggregatesFilter<"users"> | string | null
    isverified?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    verifiedby?: StringNullableWithAggregatesFilter<"users"> | string | null
    isavailable?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    isavailable_by?: StringNullableWithAggregatesFilter<"users"> | string | null
    isavailable_reason?: StringNullableWithAggregatesFilter<"users"> | string | null
    commissions_outstanding?: FloatNullableWithAggregatesFilter<"users"> | number | null
    commission_payment_ref?: StringNullableWithAggregatesFilter<"users"> | string | null
    isactive?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    isadmin?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    terms?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    enable2fa?: StringWithAggregatesFilter<"users"> | string
    code2fa?: StringNullableWithAggregatesFilter<"users"> | string | null
    expiry2fa?: StringNullableWithAggregatesFilter<"users"> | string | null
    signupotp?: StringNullableWithAggregatesFilter<"users"> | string | null
    wm_wait_list?: IntWithAggregatesFilter<"users"> | number
    views?: IntWithAggregatesFilter<"users"> | number
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type videocatWhereInput = {
    AND?: videocatWhereInput | videocatWhereInput[]
    OR?: videocatWhereInput[]
    NOT?: videocatWhereInput | videocatWhereInput[]
    vidcatid?: IntFilter<"videocat"> | number
    vidcat?: StringFilter<"videocat"> | string
  }

  export type videocatOrderByWithRelationInput = {
    vidcatid?: SortOrder
    vidcat?: SortOrder
    _relevance?: videocatOrderByRelevanceInput
  }

  export type videocatWhereUniqueInput = Prisma.AtLeast<{
    vidcatid?: number
    AND?: videocatWhereInput | videocatWhereInput[]
    OR?: videocatWhereInput[]
    NOT?: videocatWhereInput | videocatWhereInput[]
    vidcat?: StringFilter<"videocat"> | string
  }, "vidcatid">

  export type videocatOrderByWithAggregationInput = {
    vidcatid?: SortOrder
    vidcat?: SortOrder
    _count?: videocatCountOrderByAggregateInput
    _avg?: videocatAvgOrderByAggregateInput
    _max?: videocatMaxOrderByAggregateInput
    _min?: videocatMinOrderByAggregateInput
    _sum?: videocatSumOrderByAggregateInput
  }

  export type videocatScalarWhereWithAggregatesInput = {
    AND?: videocatScalarWhereWithAggregatesInput | videocatScalarWhereWithAggregatesInput[]
    OR?: videocatScalarWhereWithAggregatesInput[]
    NOT?: videocatScalarWhereWithAggregatesInput | videocatScalarWhereWithAggregatesInput[]
    vidcatid?: IntWithAggregatesFilter<"videocat"> | number
    vidcat?: StringWithAggregatesFilter<"videocat"> | string
  }

  export type videosWhereInput = {
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    videntryid?: IntFilter<"videos"> | number
    vcatid?: IntFilter<"videos"> | number
    vidcategory?: StringFilter<"videos"> | string
    vidtitle?: StringFilter<"videos"> | string
    viddesc?: StringFilter<"videos"> | string
    vidurl?: StringFilter<"videos"> | string
    vidembed?: StringFilter<"videos"> | string
    vidpostedby?: StringFilter<"videos"> | string
    vidtimeposted?: DateTimeFilter<"videos"> | Date | string
    vidhits?: IntFilter<"videos"> | number
    vidextra?: StringFilter<"videos"> | string
  }

  export type videosOrderByWithRelationInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidcategory?: SortOrder
    vidtitle?: SortOrder
    viddesc?: SortOrder
    vidurl?: SortOrder
    vidembed?: SortOrder
    vidpostedby?: SortOrder
    vidtimeposted?: SortOrder
    vidhits?: SortOrder
    vidextra?: SortOrder
    _relevance?: videosOrderByRelevanceInput
  }

  export type videosWhereUniqueInput = Prisma.AtLeast<{
    videntryid?: number
    AND?: videosWhereInput | videosWhereInput[]
    OR?: videosWhereInput[]
    NOT?: videosWhereInput | videosWhereInput[]
    vcatid?: IntFilter<"videos"> | number
    vidcategory?: StringFilter<"videos"> | string
    vidtitle?: StringFilter<"videos"> | string
    viddesc?: StringFilter<"videos"> | string
    vidurl?: StringFilter<"videos"> | string
    vidembed?: StringFilter<"videos"> | string
    vidpostedby?: StringFilter<"videos"> | string
    vidtimeposted?: DateTimeFilter<"videos"> | Date | string
    vidhits?: IntFilter<"videos"> | number
    vidextra?: StringFilter<"videos"> | string
  }, "videntryid">

  export type videosOrderByWithAggregationInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidcategory?: SortOrder
    vidtitle?: SortOrder
    viddesc?: SortOrder
    vidurl?: SortOrder
    vidembed?: SortOrder
    vidpostedby?: SortOrder
    vidtimeposted?: SortOrder
    vidhits?: SortOrder
    vidextra?: SortOrder
    _count?: videosCountOrderByAggregateInput
    _avg?: videosAvgOrderByAggregateInput
    _max?: videosMaxOrderByAggregateInput
    _min?: videosMinOrderByAggregateInput
    _sum?: videosSumOrderByAggregateInput
  }

  export type videosScalarWhereWithAggregatesInput = {
    AND?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    OR?: videosScalarWhereWithAggregatesInput[]
    NOT?: videosScalarWhereWithAggregatesInput | videosScalarWhereWithAggregatesInput[]
    videntryid?: IntWithAggregatesFilter<"videos"> | number
    vcatid?: IntWithAggregatesFilter<"videos"> | number
    vidcategory?: StringWithAggregatesFilter<"videos"> | string
    vidtitle?: StringWithAggregatesFilter<"videos"> | string
    viddesc?: StringWithAggregatesFilter<"videos"> | string
    vidurl?: StringWithAggregatesFilter<"videos"> | string
    vidembed?: StringWithAggregatesFilter<"videos"> | string
    vidpostedby?: StringWithAggregatesFilter<"videos"> | string
    vidtimeposted?: DateTimeWithAggregatesFilter<"videos"> | Date | string
    vidhits?: IntWithAggregatesFilter<"videos"> | number
    vidextra?: StringWithAggregatesFilter<"videos"> | string
  }

  export type meter_domestic_entriesWhereInput = {
    AND?: meter_domestic_entriesWhereInput | meter_domestic_entriesWhereInput[]
    OR?: meter_domestic_entriesWhereInput[]
    NOT?: meter_domestic_entriesWhereInput | meter_domestic_entriesWhereInput[]
    mdid?: IntFilter<"meter_domestic_entries"> | number
    md_unique_id?: StringFilter<"meter_domestic_entries"> | string
    md_userid?: StringNullableFilter<"meter_domestic_entries"> | string | null
    md_area?: StringNullableFilter<"meter_domestic_entries"> | string | null
    md_consumption_rate?: StringFilter<"meter_domestic_entries"> | string
    md_volume_received?: IntFilter<"meter_domestic_entries"> | number
    md_valve_state?: StringFilter<"meter_domestic_entries"> | string
    createdAt?: DateTimeFilter<"meter_domestic_entries"> | Date | string
  }

  export type meter_domestic_entriesOrderByWithRelationInput = {
    mdid?: SortOrder
    md_unique_id?: SortOrder
    md_userid?: SortOrderInput | SortOrder
    md_area?: SortOrderInput | SortOrder
    md_consumption_rate?: SortOrder
    md_volume_received?: SortOrder
    md_valve_state?: SortOrder
    createdAt?: SortOrder
    _relevance?: meter_domestic_entriesOrderByRelevanceInput
  }

  export type meter_domestic_entriesWhereUniqueInput = Prisma.AtLeast<{
    mdid?: number
    AND?: meter_domestic_entriesWhereInput | meter_domestic_entriesWhereInput[]
    OR?: meter_domestic_entriesWhereInput[]
    NOT?: meter_domestic_entriesWhereInput | meter_domestic_entriesWhereInput[]
    md_unique_id?: StringFilter<"meter_domestic_entries"> | string
    md_userid?: StringNullableFilter<"meter_domestic_entries"> | string | null
    md_area?: StringNullableFilter<"meter_domestic_entries"> | string | null
    md_consumption_rate?: StringFilter<"meter_domestic_entries"> | string
    md_volume_received?: IntFilter<"meter_domestic_entries"> | number
    md_valve_state?: StringFilter<"meter_domestic_entries"> | string
    createdAt?: DateTimeFilter<"meter_domestic_entries"> | Date | string
  }, "mdid">

  export type meter_domestic_entriesOrderByWithAggregationInput = {
    mdid?: SortOrder
    md_unique_id?: SortOrder
    md_userid?: SortOrderInput | SortOrder
    md_area?: SortOrderInput | SortOrder
    md_consumption_rate?: SortOrder
    md_volume_received?: SortOrder
    md_valve_state?: SortOrder
    createdAt?: SortOrder
    _count?: meter_domestic_entriesCountOrderByAggregateInput
    _avg?: meter_domestic_entriesAvgOrderByAggregateInput
    _max?: meter_domestic_entriesMaxOrderByAggregateInput
    _min?: meter_domestic_entriesMinOrderByAggregateInput
    _sum?: meter_domestic_entriesSumOrderByAggregateInput
  }

  export type meter_domestic_entriesScalarWhereWithAggregatesInput = {
    AND?: meter_domestic_entriesScalarWhereWithAggregatesInput | meter_domestic_entriesScalarWhereWithAggregatesInput[]
    OR?: meter_domestic_entriesScalarWhereWithAggregatesInput[]
    NOT?: meter_domestic_entriesScalarWhereWithAggregatesInput | meter_domestic_entriesScalarWhereWithAggregatesInput[]
    mdid?: IntWithAggregatesFilter<"meter_domestic_entries"> | number
    md_unique_id?: StringWithAggregatesFilter<"meter_domestic_entries"> | string
    md_userid?: StringNullableWithAggregatesFilter<"meter_domestic_entries"> | string | null
    md_area?: StringNullableWithAggregatesFilter<"meter_domestic_entries"> | string | null
    md_consumption_rate?: StringWithAggregatesFilter<"meter_domestic_entries"> | string
    md_volume_received?: IntWithAggregatesFilter<"meter_domestic_entries"> | number
    md_valve_state?: StringWithAggregatesFilter<"meter_domestic_entries"> | string
    createdAt?: DateTimeWithAggregatesFilter<"meter_domestic_entries"> | Date | string
  }

  export type meter_supply_entriesWhereInput = {
    AND?: meter_supply_entriesWhereInput | meter_supply_entriesWhereInput[]
    OR?: meter_supply_entriesWhereInput[]
    NOT?: meter_supply_entriesWhereInput | meter_supply_entriesWhereInput[]
    msid?: IntFilter<"meter_supply_entries"> | number
    ms_unique_id?: StringFilter<"meter_supply_entries"> | string
    ms_userid?: StringNullableFilter<"meter_supply_entries"> | string | null
    ms_supply_rate?: StringFilter<"meter_supply_entries"> | string
    ms_volume_supplied?: IntFilter<"meter_supply_entries"> | number
    ms_temperature_c?: StringFilter<"meter_supply_entries"> | string
    ms_temperature_f?: StringFilter<"meter_supply_entries"> | string
    ms_turbidity_level?: StringFilter<"meter_supply_entries"> | string
    ms_ph_level?: StringFilter<"meter_supply_entries"> | string
    ms_valve_state?: StringFilter<"meter_supply_entries"> | string
    createdAt?: DateTimeFilter<"meter_supply_entries"> | Date | string
  }

  export type meter_supply_entriesOrderByWithRelationInput = {
    msid?: SortOrder
    ms_unique_id?: SortOrder
    ms_userid?: SortOrderInput | SortOrder
    ms_supply_rate?: SortOrder
    ms_volume_supplied?: SortOrder
    ms_temperature_c?: SortOrder
    ms_temperature_f?: SortOrder
    ms_turbidity_level?: SortOrder
    ms_ph_level?: SortOrder
    ms_valve_state?: SortOrder
    createdAt?: SortOrder
    _relevance?: meter_supply_entriesOrderByRelevanceInput
  }

  export type meter_supply_entriesWhereUniqueInput = Prisma.AtLeast<{
    msid?: number
    AND?: meter_supply_entriesWhereInput | meter_supply_entriesWhereInput[]
    OR?: meter_supply_entriesWhereInput[]
    NOT?: meter_supply_entriesWhereInput | meter_supply_entriesWhereInput[]
    ms_unique_id?: StringFilter<"meter_supply_entries"> | string
    ms_userid?: StringNullableFilter<"meter_supply_entries"> | string | null
    ms_supply_rate?: StringFilter<"meter_supply_entries"> | string
    ms_volume_supplied?: IntFilter<"meter_supply_entries"> | number
    ms_temperature_c?: StringFilter<"meter_supply_entries"> | string
    ms_temperature_f?: StringFilter<"meter_supply_entries"> | string
    ms_turbidity_level?: StringFilter<"meter_supply_entries"> | string
    ms_ph_level?: StringFilter<"meter_supply_entries"> | string
    ms_valve_state?: StringFilter<"meter_supply_entries"> | string
    createdAt?: DateTimeFilter<"meter_supply_entries"> | Date | string
  }, "msid">

  export type meter_supply_entriesOrderByWithAggregationInput = {
    msid?: SortOrder
    ms_unique_id?: SortOrder
    ms_userid?: SortOrderInput | SortOrder
    ms_supply_rate?: SortOrder
    ms_volume_supplied?: SortOrder
    ms_temperature_c?: SortOrder
    ms_temperature_f?: SortOrder
    ms_turbidity_level?: SortOrder
    ms_ph_level?: SortOrder
    ms_valve_state?: SortOrder
    createdAt?: SortOrder
    _count?: meter_supply_entriesCountOrderByAggregateInput
    _avg?: meter_supply_entriesAvgOrderByAggregateInput
    _max?: meter_supply_entriesMaxOrderByAggregateInput
    _min?: meter_supply_entriesMinOrderByAggregateInput
    _sum?: meter_supply_entriesSumOrderByAggregateInput
  }

  export type meter_supply_entriesScalarWhereWithAggregatesInput = {
    AND?: meter_supply_entriesScalarWhereWithAggregatesInput | meter_supply_entriesScalarWhereWithAggregatesInput[]
    OR?: meter_supply_entriesScalarWhereWithAggregatesInput[]
    NOT?: meter_supply_entriesScalarWhereWithAggregatesInput | meter_supply_entriesScalarWhereWithAggregatesInput[]
    msid?: IntWithAggregatesFilter<"meter_supply_entries"> | number
    ms_unique_id?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_userid?: StringNullableWithAggregatesFilter<"meter_supply_entries"> | string | null
    ms_supply_rate?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_volume_supplied?: IntWithAggregatesFilter<"meter_supply_entries"> | number
    ms_temperature_c?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_temperature_f?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_turbidity_level?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_ph_level?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    ms_valve_state?: StringWithAggregatesFilter<"meter_supply_entries"> | string
    createdAt?: DateTimeWithAggregatesFilter<"meter_supply_entries"> | Date | string
  }

  export type meter_tanker_entriesWhereInput = {
    AND?: meter_tanker_entriesWhereInput | meter_tanker_entriesWhereInput[]
    OR?: meter_tanker_entriesWhereInput[]
    NOT?: meter_tanker_entriesWhereInput | meter_tanker_entriesWhereInput[]
    mtid?: IntFilter<"meter_tanker_entries"> | number
    mt_unique_id?: StringFilter<"meter_tanker_entries"> | string
    mt_tankerid?: StringNullableFilter<"meter_tanker_entries"> | string | null
    mt_delivery_rate?: StringFilter<"meter_tanker_entries"> | string
    mt_volume_delivered?: IntFilter<"meter_tanker_entries"> | number
    mt_valve_state?: StringFilter<"meter_tanker_entries"> | string
    createdAt?: DateTimeFilter<"meter_tanker_entries"> | Date | string
  }

  export type meter_tanker_entriesOrderByWithRelationInput = {
    mtid?: SortOrder
    mt_unique_id?: SortOrder
    mt_tankerid?: SortOrderInput | SortOrder
    mt_delivery_rate?: SortOrder
    mt_volume_delivered?: SortOrder
    mt_valve_state?: SortOrder
    createdAt?: SortOrder
    _relevance?: meter_tanker_entriesOrderByRelevanceInput
  }

  export type meter_tanker_entriesWhereUniqueInput = Prisma.AtLeast<{
    mtid?: number
    AND?: meter_tanker_entriesWhereInput | meter_tanker_entriesWhereInput[]
    OR?: meter_tanker_entriesWhereInput[]
    NOT?: meter_tanker_entriesWhereInput | meter_tanker_entriesWhereInput[]
    mt_unique_id?: StringFilter<"meter_tanker_entries"> | string
    mt_tankerid?: StringNullableFilter<"meter_tanker_entries"> | string | null
    mt_delivery_rate?: StringFilter<"meter_tanker_entries"> | string
    mt_volume_delivered?: IntFilter<"meter_tanker_entries"> | number
    mt_valve_state?: StringFilter<"meter_tanker_entries"> | string
    createdAt?: DateTimeFilter<"meter_tanker_entries"> | Date | string
  }, "mtid">

  export type meter_tanker_entriesOrderByWithAggregationInput = {
    mtid?: SortOrder
    mt_unique_id?: SortOrder
    mt_tankerid?: SortOrderInput | SortOrder
    mt_delivery_rate?: SortOrder
    mt_volume_delivered?: SortOrder
    mt_valve_state?: SortOrder
    createdAt?: SortOrder
    _count?: meter_tanker_entriesCountOrderByAggregateInput
    _avg?: meter_tanker_entriesAvgOrderByAggregateInput
    _max?: meter_tanker_entriesMaxOrderByAggregateInput
    _min?: meter_tanker_entriesMinOrderByAggregateInput
    _sum?: meter_tanker_entriesSumOrderByAggregateInput
  }

  export type meter_tanker_entriesScalarWhereWithAggregatesInput = {
    AND?: meter_tanker_entriesScalarWhereWithAggregatesInput | meter_tanker_entriesScalarWhereWithAggregatesInput[]
    OR?: meter_tanker_entriesScalarWhereWithAggregatesInput[]
    NOT?: meter_tanker_entriesScalarWhereWithAggregatesInput | meter_tanker_entriesScalarWhereWithAggregatesInput[]
    mtid?: IntWithAggregatesFilter<"meter_tanker_entries"> | number
    mt_unique_id?: StringWithAggregatesFilter<"meter_tanker_entries"> | string
    mt_tankerid?: StringNullableWithAggregatesFilter<"meter_tanker_entries"> | string | null
    mt_delivery_rate?: StringWithAggregatesFilter<"meter_tanker_entries"> | string
    mt_volume_delivered?: IntWithAggregatesFilter<"meter_tanker_entries"> | number
    mt_valve_state?: StringWithAggregatesFilter<"meter_tanker_entries"> | string
    createdAt?: DateTimeWithAggregatesFilter<"meter_tanker_entries"> | Date | string
  }

  export type metersWhereInput = {
    AND?: metersWhereInput | metersWhereInput[]
    OR?: metersWhereInput[]
    NOT?: metersWhereInput | metersWhereInput[]
    meterid?: IntFilter<"meters"> | number
    m_account_number?: StringNullableFilter<"meters"> | string | null
    m_unique_id?: StringFilter<"meters"> | string
    m_for?: StringFilter<"meters"> | string
    m_assigned?: StringFilter<"meters"> | string
    m_assigned_to?: StringNullableFilter<"meters"> | string | null
    m_assigned_name?: StringNullableFilter<"meters"> | string | null
    m_assigned_phone?: StringNullableFilter<"meters"> | string | null
    m_assigned_address?: StringNullableFilter<"meters"> | string | null
    m_area?: StringNullableFilter<"meters"> | string | null
    m_status?: StringFilter<"meters"> | string
    m_valve_state?: StringFilter<"meters"> | string
    m_water_unit_price?: FloatFilter<"meters"> | number
    createdAt?: DateTimeFilter<"meters"> | Date | string
    updatedAt?: DateTimeFilter<"meters"> | Date | string
    meter_readings?: MeterReadingsListRelationFilter
  }

  export type metersOrderByWithRelationInput = {
    meterid?: SortOrder
    m_account_number?: SortOrderInput | SortOrder
    m_unique_id?: SortOrder
    m_for?: SortOrder
    m_assigned?: SortOrder
    m_assigned_to?: SortOrderInput | SortOrder
    m_assigned_name?: SortOrderInput | SortOrder
    m_assigned_phone?: SortOrderInput | SortOrder
    m_assigned_address?: SortOrderInput | SortOrder
    m_area?: SortOrderInput | SortOrder
    m_status?: SortOrder
    m_valve_state?: SortOrder
    m_water_unit_price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meter_readings?: MeterReadingsOrderByRelationAggregateInput
    _relevance?: metersOrderByRelevanceInput
  }

  export type metersWhereUniqueInput = Prisma.AtLeast<{
    meterid?: number
    m_unique_id?: string
    AND?: metersWhereInput | metersWhereInput[]
    OR?: metersWhereInput[]
    NOT?: metersWhereInput | metersWhereInput[]
    m_account_number?: StringNullableFilter<"meters"> | string | null
    m_for?: StringFilter<"meters"> | string
    m_assigned?: StringFilter<"meters"> | string
    m_assigned_to?: StringNullableFilter<"meters"> | string | null
    m_assigned_name?: StringNullableFilter<"meters"> | string | null
    m_assigned_phone?: StringNullableFilter<"meters"> | string | null
    m_assigned_address?: StringNullableFilter<"meters"> | string | null
    m_area?: StringNullableFilter<"meters"> | string | null
    m_status?: StringFilter<"meters"> | string
    m_valve_state?: StringFilter<"meters"> | string
    m_water_unit_price?: FloatFilter<"meters"> | number
    createdAt?: DateTimeFilter<"meters"> | Date | string
    updatedAt?: DateTimeFilter<"meters"> | Date | string
    meter_readings?: MeterReadingsListRelationFilter
  }, "meterid" | "m_unique_id">

  export type metersOrderByWithAggregationInput = {
    meterid?: SortOrder
    m_account_number?: SortOrderInput | SortOrder
    m_unique_id?: SortOrder
    m_for?: SortOrder
    m_assigned?: SortOrder
    m_assigned_to?: SortOrderInput | SortOrder
    m_assigned_name?: SortOrderInput | SortOrder
    m_assigned_phone?: SortOrderInput | SortOrder
    m_assigned_address?: SortOrderInput | SortOrder
    m_area?: SortOrderInput | SortOrder
    m_status?: SortOrder
    m_valve_state?: SortOrder
    m_water_unit_price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: metersCountOrderByAggregateInput
    _avg?: metersAvgOrderByAggregateInput
    _max?: metersMaxOrderByAggregateInput
    _min?: metersMinOrderByAggregateInput
    _sum?: metersSumOrderByAggregateInput
  }

  export type metersScalarWhereWithAggregatesInput = {
    AND?: metersScalarWhereWithAggregatesInput | metersScalarWhereWithAggregatesInput[]
    OR?: metersScalarWhereWithAggregatesInput[]
    NOT?: metersScalarWhereWithAggregatesInput | metersScalarWhereWithAggregatesInput[]
    meterid?: IntWithAggregatesFilter<"meters"> | number
    m_account_number?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_unique_id?: StringWithAggregatesFilter<"meters"> | string
    m_for?: StringWithAggregatesFilter<"meters"> | string
    m_assigned?: StringWithAggregatesFilter<"meters"> | string
    m_assigned_to?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_assigned_name?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_assigned_phone?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_assigned_address?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_area?: StringNullableWithAggregatesFilter<"meters"> | string | null
    m_status?: StringWithAggregatesFilter<"meters"> | string
    m_valve_state?: StringWithAggregatesFilter<"meters"> | string
    m_water_unit_price?: FloatWithAggregatesFilter<"meters"> | number
    createdAt?: DateTimeWithAggregatesFilter<"meters"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meters"> | Date | string
  }

  export type contact_messagesWhereInput = {
    AND?: contact_messagesWhereInput | contact_messagesWhereInput[]
    OR?: contact_messagesWhereInput[]
    NOT?: contact_messagesWhereInput | contact_messagesWhereInput[]
    cid?: IntFilter<"contact_messages"> | number
    cname?: StringFilter<"contact_messages"> | string
    cphone?: StringFilter<"contact_messages"> | string
    cemail?: StringFilter<"contact_messages"> | string
    csubject?: StringFilter<"contact_messages"> | string
    cmessage?: StringFilter<"contact_messages"> | string
    cstatus?: StringFilter<"contact_messages"> | string
    createdAt?: DateTimeFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeFilter<"contact_messages"> | Date | string
  }

  export type contact_messagesOrderByWithRelationInput = {
    cid?: SortOrder
    cname?: SortOrder
    cphone?: SortOrder
    cemail?: SortOrder
    csubject?: SortOrder
    cmessage?: SortOrder
    cstatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: contact_messagesOrderByRelevanceInput
  }

  export type contact_messagesWhereUniqueInput = Prisma.AtLeast<{
    cid?: number
    AND?: contact_messagesWhereInput | contact_messagesWhereInput[]
    OR?: contact_messagesWhereInput[]
    NOT?: contact_messagesWhereInput | contact_messagesWhereInput[]
    cname?: StringFilter<"contact_messages"> | string
    cphone?: StringFilter<"contact_messages"> | string
    cemail?: StringFilter<"contact_messages"> | string
    csubject?: StringFilter<"contact_messages"> | string
    cmessage?: StringFilter<"contact_messages"> | string
    cstatus?: StringFilter<"contact_messages"> | string
    createdAt?: DateTimeFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeFilter<"contact_messages"> | Date | string
  }, "cid">

  export type contact_messagesOrderByWithAggregationInput = {
    cid?: SortOrder
    cname?: SortOrder
    cphone?: SortOrder
    cemail?: SortOrder
    csubject?: SortOrder
    cmessage?: SortOrder
    cstatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: contact_messagesCountOrderByAggregateInput
    _avg?: contact_messagesAvgOrderByAggregateInput
    _max?: contact_messagesMaxOrderByAggregateInput
    _min?: contact_messagesMinOrderByAggregateInput
    _sum?: contact_messagesSumOrderByAggregateInput
  }

  export type contact_messagesScalarWhereWithAggregatesInput = {
    AND?: contact_messagesScalarWhereWithAggregatesInput | contact_messagesScalarWhereWithAggregatesInput[]
    OR?: contact_messagesScalarWhereWithAggregatesInput[]
    NOT?: contact_messagesScalarWhereWithAggregatesInput | contact_messagesScalarWhereWithAggregatesInput[]
    cid?: IntWithAggregatesFilter<"contact_messages"> | number
    cname?: StringWithAggregatesFilter<"contact_messages"> | string
    cphone?: StringWithAggregatesFilter<"contact_messages"> | string
    cemail?: StringWithAggregatesFilter<"contact_messages"> | string
    csubject?: StringWithAggregatesFilter<"contact_messages"> | string
    cmessage?: StringWithAggregatesFilter<"contact_messages"> | string
    cstatus?: StringWithAggregatesFilter<"contact_messages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"contact_messages"> | Date | string
  }

  export type meter_numbersWhereInput = {
    AND?: meter_numbersWhereInput | meter_numbersWhereInput[]
    OR?: meter_numbersWhereInput[]
    NOT?: meter_numbersWhereInput | meter_numbersWhereInput[]
    meter_uuid_id?: IntFilter<"meter_numbers"> | number
    meter_type?: StringFilter<"meter_numbers"> | string
    meter_uuid?: StringFilter<"meter_numbers"> | string
    meter_uuid_used?: StringFilter<"meter_numbers"> | string
    meter_assigned?: StringFilter<"meter_numbers"> | string
    createdAt?: DateTimeFilter<"meter_numbers"> | Date | string
  }

  export type meter_numbersOrderByWithRelationInput = {
    meter_uuid_id?: SortOrder
    meter_type?: SortOrder
    meter_uuid?: SortOrder
    meter_uuid_used?: SortOrder
    meter_assigned?: SortOrder
    createdAt?: SortOrder
    _relevance?: meter_numbersOrderByRelevanceInput
  }

  export type meter_numbersWhereUniqueInput = Prisma.AtLeast<{
    meter_uuid_id?: number
    AND?: meter_numbersWhereInput | meter_numbersWhereInput[]
    OR?: meter_numbersWhereInput[]
    NOT?: meter_numbersWhereInput | meter_numbersWhereInput[]
    meter_type?: StringFilter<"meter_numbers"> | string
    meter_uuid?: StringFilter<"meter_numbers"> | string
    meter_uuid_used?: StringFilter<"meter_numbers"> | string
    meter_assigned?: StringFilter<"meter_numbers"> | string
    createdAt?: DateTimeFilter<"meter_numbers"> | Date | string
  }, "meter_uuid_id">

  export type meter_numbersOrderByWithAggregationInput = {
    meter_uuid_id?: SortOrder
    meter_type?: SortOrder
    meter_uuid?: SortOrder
    meter_uuid_used?: SortOrder
    meter_assigned?: SortOrder
    createdAt?: SortOrder
    _count?: meter_numbersCountOrderByAggregateInput
    _avg?: meter_numbersAvgOrderByAggregateInput
    _max?: meter_numbersMaxOrderByAggregateInput
    _min?: meter_numbersMinOrderByAggregateInput
    _sum?: meter_numbersSumOrderByAggregateInput
  }

  export type meter_numbersScalarWhereWithAggregatesInput = {
    AND?: meter_numbersScalarWhereWithAggregatesInput | meter_numbersScalarWhereWithAggregatesInput[]
    OR?: meter_numbersScalarWhereWithAggregatesInput[]
    NOT?: meter_numbersScalarWhereWithAggregatesInput | meter_numbersScalarWhereWithAggregatesInput[]
    meter_uuid_id?: IntWithAggregatesFilter<"meter_numbers"> | number
    meter_type?: StringWithAggregatesFilter<"meter_numbers"> | string
    meter_uuid?: StringWithAggregatesFilter<"meter_numbers"> | string
    meter_uuid_used?: StringWithAggregatesFilter<"meter_numbers"> | string
    meter_assigned?: StringWithAggregatesFilter<"meter_numbers"> | string
    createdAt?: DateTimeWithAggregatesFilter<"meter_numbers"> | Date | string
  }

  export type driverequestsWhereInput = {
    AND?: driverequestsWhereInput | driverequestsWhereInput[]
    OR?: driverequestsWhereInput[]
    NOT?: driverequestsWhereInput | driverequestsWhereInput[]
    id?: IntFilter<"driverequests"> | number
    uuid?: StringNullableFilter<"driverequests"> | string | null
    orderid?: IntFilter<"driverequests"> | number
    customerid?: IntFilter<"driverequests"> | number
    address?: StringFilter<"driverequests"> | string
    driverid?: IntFilter<"driverequests"> | number
    status?: StringFilter<"driverequests"> | string
    createdAt?: DateTimeFilter<"driverequests"> | Date | string
    updatedAt?: DateTimeFilter<"driverequests"> | Date | string
  }

  export type driverequestsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: driverequestsOrderByRelevanceInput
  }

  export type driverequestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: driverequestsWhereInput | driverequestsWhereInput[]
    OR?: driverequestsWhereInput[]
    NOT?: driverequestsWhereInput | driverequestsWhereInput[]
    uuid?: StringNullableFilter<"driverequests"> | string | null
    orderid?: IntFilter<"driverequests"> | number
    customerid?: IntFilter<"driverequests"> | number
    address?: StringFilter<"driverequests"> | string
    driverid?: IntFilter<"driverequests"> | number
    status?: StringFilter<"driverequests"> | string
    createdAt?: DateTimeFilter<"driverequests"> | Date | string
    updatedAt?: DateTimeFilter<"driverequests"> | Date | string
  }, "id">

  export type driverequestsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: driverequestsCountOrderByAggregateInput
    _avg?: driverequestsAvgOrderByAggregateInput
    _max?: driverequestsMaxOrderByAggregateInput
    _min?: driverequestsMinOrderByAggregateInput
    _sum?: driverequestsSumOrderByAggregateInput
  }

  export type driverequestsScalarWhereWithAggregatesInput = {
    AND?: driverequestsScalarWhereWithAggregatesInput | driverequestsScalarWhereWithAggregatesInput[]
    OR?: driverequestsScalarWhereWithAggregatesInput[]
    NOT?: driverequestsScalarWhereWithAggregatesInput | driverequestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"driverequests"> | number
    uuid?: StringNullableWithAggregatesFilter<"driverequests"> | string | null
    orderid?: IntWithAggregatesFilter<"driverequests"> | number
    customerid?: IntWithAggregatesFilter<"driverequests"> | number
    address?: StringWithAggregatesFilter<"driverequests"> | string
    driverid?: IntWithAggregatesFilter<"driverequests"> | number
    status?: StringWithAggregatesFilter<"driverequests"> | string
    createdAt?: DateTimeWithAggregatesFilter<"driverequests"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"driverequests"> | Date | string
  }

  export type order_tableWhereInput = {
    AND?: order_tableWhereInput | order_tableWhereInput[]
    OR?: order_tableWhereInput[]
    NOT?: order_tableWhereInput | order_tableWhereInput[]
    order_id?: IntFilter<"order_table"> | number
    order_trans_id?: StringFilter<"order_table"> | string
    username?: StringNullableFilter<"order_table"> | string | null
    order_date?: DateTimeNullableFilter<"order_table"> | Date | string | null
    order_time?: DateTimeFilter<"order_table"> | Date | string
    status?: StringFilter<"order_table"> | string
    customercomment?: StringNullableFilter<"order_table"> | string | null
    notes?: StringFilter<"order_table"> | string
    shipping_first_name?: StringFilter<"order_table"> | string
    shipping_last_name?: StringFilter<"order_table"> | string
    shipping_address1?: StringFilter<"order_table"> | string
    shipping_address2?: StringFilter<"order_table"> | string
    shipping_phone?: StringFilter<"order_table"> | string
    shipping_email?: StringNullableFilter<"order_table"> | string | null
    shipping_city?: StringFilter<"order_table"> | string
    shipping_state?: StringFilter<"order_table"> | string
    shipping_country?: StringFilter<"order_table"> | string
    order_total?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFilter<"order_table"> | string
    shipping_cost?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFilter<"order_table"> | number
    gwtranxid?: IntNullableFilter<"order_table"> | number | null
    gwcustid?: StringNullableFilter<"order_table"> | string | null
    gwtranxamt?: DecimalNullableFilter<"order_table"> | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: IntNullableFilter<"order_table"> | number | null
    gwstatusmsg?: StringNullableFilter<"order_table"> | string | null
    o_sesid?: StringFilter<"order_table"> | string
    last_update_by?: Enumorder_table_last_update_byFilter<"order_table"> | $Enums.order_table_last_update_by
    order_stage?: IntFilter<"order_table"> | number
    shipping_option?: StringFilter<"order_table"> | string
    payment_option?: StringFilter<"order_table"> | string
    payment_status?: StringFilter<"order_table"> | string
  }

  export type order_tableOrderByWithRelationInput = {
    order_id?: SortOrder
    order_trans_id?: SortOrder
    username?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    order_time?: SortOrder
    status?: SortOrder
    customercomment?: SortOrderInput | SortOrder
    notes?: SortOrder
    shipping_first_name?: SortOrder
    shipping_last_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrderInput | SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    order_total?: SortOrder
    delivery_type?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrderInput | SortOrder
    gwcustid?: SortOrderInput | SortOrder
    gwtranxamt?: SortOrderInput | SortOrder
    gwstatuscode?: SortOrderInput | SortOrder
    gwstatusmsg?: SortOrderInput | SortOrder
    o_sesid?: SortOrder
    last_update_by?: SortOrder
    order_stage?: SortOrder
    shipping_option?: SortOrder
    payment_option?: SortOrder
    payment_status?: SortOrder
    _relevance?: order_tableOrderByRelevanceInput
  }

  export type order_tableWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: order_tableWhereInput | order_tableWhereInput[]
    OR?: order_tableWhereInput[]
    NOT?: order_tableWhereInput | order_tableWhereInput[]
    order_trans_id?: StringFilter<"order_table"> | string
    username?: StringNullableFilter<"order_table"> | string | null
    order_date?: DateTimeNullableFilter<"order_table"> | Date | string | null
    order_time?: DateTimeFilter<"order_table"> | Date | string
    status?: StringFilter<"order_table"> | string
    customercomment?: StringNullableFilter<"order_table"> | string | null
    notes?: StringFilter<"order_table"> | string
    shipping_first_name?: StringFilter<"order_table"> | string
    shipping_last_name?: StringFilter<"order_table"> | string
    shipping_address1?: StringFilter<"order_table"> | string
    shipping_address2?: StringFilter<"order_table"> | string
    shipping_phone?: StringFilter<"order_table"> | string
    shipping_email?: StringNullableFilter<"order_table"> | string | null
    shipping_city?: StringFilter<"order_table"> | string
    shipping_state?: StringFilter<"order_table"> | string
    shipping_country?: StringFilter<"order_table"> | string
    order_total?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFilter<"order_table"> | string
    shipping_cost?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFilter<"order_table"> | number
    gwtranxid?: IntNullableFilter<"order_table"> | number | null
    gwcustid?: StringNullableFilter<"order_table"> | string | null
    gwtranxamt?: DecimalNullableFilter<"order_table"> | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: IntNullableFilter<"order_table"> | number | null
    gwstatusmsg?: StringNullableFilter<"order_table"> | string | null
    o_sesid?: StringFilter<"order_table"> | string
    last_update_by?: Enumorder_table_last_update_byFilter<"order_table"> | $Enums.order_table_last_update_by
    order_stage?: IntFilter<"order_table"> | number
    shipping_option?: StringFilter<"order_table"> | string
    payment_option?: StringFilter<"order_table"> | string
    payment_status?: StringFilter<"order_table"> | string
  }, "order_id">

  export type order_tableOrderByWithAggregationInput = {
    order_id?: SortOrder
    order_trans_id?: SortOrder
    username?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    order_time?: SortOrder
    status?: SortOrder
    customercomment?: SortOrderInput | SortOrder
    notes?: SortOrder
    shipping_first_name?: SortOrder
    shipping_last_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrderInput | SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    order_total?: SortOrder
    delivery_type?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrderInput | SortOrder
    gwcustid?: SortOrderInput | SortOrder
    gwtranxamt?: SortOrderInput | SortOrder
    gwstatuscode?: SortOrderInput | SortOrder
    gwstatusmsg?: SortOrderInput | SortOrder
    o_sesid?: SortOrder
    last_update_by?: SortOrder
    order_stage?: SortOrder
    shipping_option?: SortOrder
    payment_option?: SortOrder
    payment_status?: SortOrder
    _count?: order_tableCountOrderByAggregateInput
    _avg?: order_tableAvgOrderByAggregateInput
    _max?: order_tableMaxOrderByAggregateInput
    _min?: order_tableMinOrderByAggregateInput
    _sum?: order_tableSumOrderByAggregateInput
  }

  export type order_tableScalarWhereWithAggregatesInput = {
    AND?: order_tableScalarWhereWithAggregatesInput | order_tableScalarWhereWithAggregatesInput[]
    OR?: order_tableScalarWhereWithAggregatesInput[]
    NOT?: order_tableScalarWhereWithAggregatesInput | order_tableScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"order_table"> | number
    order_trans_id?: StringWithAggregatesFilter<"order_table"> | string
    username?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    order_date?: DateTimeNullableWithAggregatesFilter<"order_table"> | Date | string | null
    order_time?: DateTimeWithAggregatesFilter<"order_table"> | Date | string
    status?: StringWithAggregatesFilter<"order_table"> | string
    customercomment?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    notes?: StringWithAggregatesFilter<"order_table"> | string
    shipping_first_name?: StringWithAggregatesFilter<"order_table"> | string
    shipping_last_name?: StringWithAggregatesFilter<"order_table"> | string
    shipping_address1?: StringWithAggregatesFilter<"order_table"> | string
    shipping_address2?: StringWithAggregatesFilter<"order_table"> | string
    shipping_phone?: StringWithAggregatesFilter<"order_table"> | string
    shipping_email?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    shipping_city?: StringWithAggregatesFilter<"order_table"> | string
    shipping_state?: StringWithAggregatesFilter<"order_table"> | string
    shipping_country?: StringWithAggregatesFilter<"order_table"> | string
    order_total?: DecimalWithAggregatesFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    delivery_type?: StringWithAggregatesFilter<"order_table"> | string
    shipping_cost?: DecimalWithAggregatesFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalWithAggregatesFilter<"order_table"> | Decimal | DecimalJsLike | number | string
    gatewayid?: IntWithAggregatesFilter<"order_table"> | number
    gwtranxid?: IntNullableWithAggregatesFilter<"order_table"> | number | null
    gwcustid?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    gwtranxamt?: DecimalNullableWithAggregatesFilter<"order_table"> | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: IntNullableWithAggregatesFilter<"order_table"> | number | null
    gwstatusmsg?: StringNullableWithAggregatesFilter<"order_table"> | string | null
    o_sesid?: StringWithAggregatesFilter<"order_table"> | string
    last_update_by?: Enumorder_table_last_update_byWithAggregatesFilter<"order_table"> | $Enums.order_table_last_update_by
    order_stage?: IntWithAggregatesFilter<"order_table"> | number
    shipping_option?: StringWithAggregatesFilter<"order_table"> | string
    payment_option?: StringWithAggregatesFilter<"order_table"> | string
    payment_status?: StringWithAggregatesFilter<"order_table"> | string
  }

  export type packagesWhereInput = {
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    id?: IntFilter<"packages"> | number
    uuid?: StringNullableFilter<"packages"> | string | null
    name?: StringFilter<"packages"> | string
    sku?: StringFilter<"packages"> | string
    description?: StringFilter<"packages"> | string
    picture?: StringFilter<"packages"> | string
    price?: FloatFilter<"packages"> | number
    size?: StringFilter<"packages"> | string
    status?: BoolFilter<"packages"> | boolean
    createdAt?: DateTimeFilter<"packages"> | Date | string
    updatedAt?: DateTimeFilter<"packages"> | Date | string
  }

  export type packagesOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: packagesOrderByRelevanceInput
  }

  export type packagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    uuid?: StringNullableFilter<"packages"> | string | null
    name?: StringFilter<"packages"> | string
    sku?: StringFilter<"packages"> | string
    description?: StringFilter<"packages"> | string
    picture?: StringFilter<"packages"> | string
    price?: FloatFilter<"packages"> | number
    size?: StringFilter<"packages"> | string
    status?: BoolFilter<"packages"> | boolean
    createdAt?: DateTimeFilter<"packages"> | Date | string
    updatedAt?: DateTimeFilter<"packages"> | Date | string
  }, "id">

  export type packagesOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: packagesCountOrderByAggregateInput
    _avg?: packagesAvgOrderByAggregateInput
    _max?: packagesMaxOrderByAggregateInput
    _min?: packagesMinOrderByAggregateInput
    _sum?: packagesSumOrderByAggregateInput
  }

  export type packagesScalarWhereWithAggregatesInput = {
    AND?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    OR?: packagesScalarWhereWithAggregatesInput[]
    NOT?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"packages"> | number
    uuid?: StringNullableWithAggregatesFilter<"packages"> | string | null
    name?: StringWithAggregatesFilter<"packages"> | string
    sku?: StringWithAggregatesFilter<"packages"> | string
    description?: StringWithAggregatesFilter<"packages"> | string
    picture?: StringWithAggregatesFilter<"packages"> | string
    price?: FloatWithAggregatesFilter<"packages"> | number
    size?: StringWithAggregatesFilter<"packages"> | string
    status?: BoolWithAggregatesFilter<"packages"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"packages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"packages"> | Date | string
  }

  export type ratingsWhereInput = {
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    id?: IntFilter<"ratings"> | number
    uuid?: StringNullableFilter<"ratings"> | string | null
    orderid?: StringFilter<"ratings"> | string
    driverid?: IntFilter<"ratings"> | number
    stars?: IntFilter<"ratings"> | number
    comment?: StringFilter<"ratings"> | string
    customerid?: IntFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
  }

  export type ratingsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    customerid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ratingsOrderByRelevanceInput
  }

  export type ratingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    uuid?: StringNullableFilter<"ratings"> | string | null
    orderid?: StringFilter<"ratings"> | string
    driverid?: IntFilter<"ratings"> | number
    stars?: IntFilter<"ratings"> | number
    comment?: StringFilter<"ratings"> | string
    customerid?: IntFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
  }, "id">

  export type ratingsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    orderid?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    customerid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ratingsCountOrderByAggregateInput
    _avg?: ratingsAvgOrderByAggregateInput
    _max?: ratingsMaxOrderByAggregateInput
    _min?: ratingsMinOrderByAggregateInput
    _sum?: ratingsSumOrderByAggregateInput
  }

  export type ratingsScalarWhereWithAggregatesInput = {
    AND?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    OR?: ratingsScalarWhereWithAggregatesInput[]
    NOT?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ratings"> | number
    uuid?: StringNullableWithAggregatesFilter<"ratings"> | string | null
    orderid?: StringWithAggregatesFilter<"ratings"> | string
    driverid?: IntWithAggregatesFilter<"ratings"> | number
    stars?: IntWithAggregatesFilter<"ratings"> | number
    comment?: StringWithAggregatesFilter<"ratings"> | string
    customerid?: IntWithAggregatesFilter<"ratings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
  }

  export type usercatWhereInput = {
    AND?: usercatWhereInput | usercatWhereInput[]
    OR?: usercatWhereInput[]
    NOT?: usercatWhereInput | usercatWhereInput[]
    usercatid?: IntFilter<"usercat"> | number
    usercategory?: StringFilter<"usercat"> | string
    usercatdesc?: StringFilter<"usercat"> | string
  }

  export type usercatOrderByWithRelationInput = {
    usercatid?: SortOrder
    usercategory?: SortOrder
    usercatdesc?: SortOrder
    _relevance?: usercatOrderByRelevanceInput
  }

  export type usercatWhereUniqueInput = Prisma.AtLeast<{
    usercatid?: number
    AND?: usercatWhereInput | usercatWhereInput[]
    OR?: usercatWhereInput[]
    NOT?: usercatWhereInput | usercatWhereInput[]
    usercategory?: StringFilter<"usercat"> | string
    usercatdesc?: StringFilter<"usercat"> | string
  }, "usercatid">

  export type usercatOrderByWithAggregationInput = {
    usercatid?: SortOrder
    usercategory?: SortOrder
    usercatdesc?: SortOrder
    _count?: usercatCountOrderByAggregateInput
    _avg?: usercatAvgOrderByAggregateInput
    _max?: usercatMaxOrderByAggregateInput
    _min?: usercatMinOrderByAggregateInput
    _sum?: usercatSumOrderByAggregateInput
  }

  export type usercatScalarWhereWithAggregatesInput = {
    AND?: usercatScalarWhereWithAggregatesInput | usercatScalarWhereWithAggregatesInput[]
    OR?: usercatScalarWhereWithAggregatesInput[]
    NOT?: usercatScalarWhereWithAggregatesInput | usercatScalarWhereWithAggregatesInput[]
    usercatid?: IntWithAggregatesFilter<"usercat"> | number
    usercategory?: StringWithAggregatesFilter<"usercat"> | string
    usercatdesc?: StringWithAggregatesFilter<"usercat"> | string
  }

  export type complaints_repliesWhereInput = {
    AND?: complaints_repliesWhereInput | complaints_repliesWhereInput[]
    OR?: complaints_repliesWhereInput[]
    NOT?: complaints_repliesWhereInput | complaints_repliesWhereInput[]
    creplyid?: IntFilter<"complaints_replies"> | number
    complaintid?: IntFilter<"complaints_replies"> | number
    creplysubject?: StringFilter<"complaints_replies"> | string
    creplyname?: StringFilter<"complaints_replies"> | string
    creplyphone?: StringFilter<"complaints_replies"> | string
    creplymessage?: StringFilter<"complaints_replies"> | string
    createdAt?: DateTimeFilter<"complaints_replies"> | Date | string
  }

  export type complaints_repliesOrderByWithRelationInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
    creplysubject?: SortOrder
    creplyname?: SortOrder
    creplyphone?: SortOrder
    creplymessage?: SortOrder
    createdAt?: SortOrder
    _relevance?: complaints_repliesOrderByRelevanceInput
  }

  export type complaints_repliesWhereUniqueInput = Prisma.AtLeast<{
    creplyid?: number
    AND?: complaints_repliesWhereInput | complaints_repliesWhereInput[]
    OR?: complaints_repliesWhereInput[]
    NOT?: complaints_repliesWhereInput | complaints_repliesWhereInput[]
    complaintid?: IntFilter<"complaints_replies"> | number
    creplysubject?: StringFilter<"complaints_replies"> | string
    creplyname?: StringFilter<"complaints_replies"> | string
    creplyphone?: StringFilter<"complaints_replies"> | string
    creplymessage?: StringFilter<"complaints_replies"> | string
    createdAt?: DateTimeFilter<"complaints_replies"> | Date | string
  }, "creplyid">

  export type complaints_repliesOrderByWithAggregationInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
    creplysubject?: SortOrder
    creplyname?: SortOrder
    creplyphone?: SortOrder
    creplymessage?: SortOrder
    createdAt?: SortOrder
    _count?: complaints_repliesCountOrderByAggregateInput
    _avg?: complaints_repliesAvgOrderByAggregateInput
    _max?: complaints_repliesMaxOrderByAggregateInput
    _min?: complaints_repliesMinOrderByAggregateInput
    _sum?: complaints_repliesSumOrderByAggregateInput
  }

  export type complaints_repliesScalarWhereWithAggregatesInput = {
    AND?: complaints_repliesScalarWhereWithAggregatesInput | complaints_repliesScalarWhereWithAggregatesInput[]
    OR?: complaints_repliesScalarWhereWithAggregatesInput[]
    NOT?: complaints_repliesScalarWhereWithAggregatesInput | complaints_repliesScalarWhereWithAggregatesInput[]
    creplyid?: IntWithAggregatesFilter<"complaints_replies"> | number
    complaintid?: IntWithAggregatesFilter<"complaints_replies"> | number
    creplysubject?: StringWithAggregatesFilter<"complaints_replies"> | string
    creplyname?: StringWithAggregatesFilter<"complaints_replies"> | string
    creplyphone?: StringWithAggregatesFilter<"complaints_replies"> | string
    creplymessage?: StringWithAggregatesFilter<"complaints_replies"> | string
    createdAt?: DateTimeWithAggregatesFilter<"complaints_replies"> | Date | string
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    subplanid?: IntFilter<"subscriptions"> | number
    subplantype?: StringFilter<"subscriptions"> | string
    subplanusername?: StringFilter<"subscriptions"> | string
    subplanamt?: IntFilter<"subscriptions"> | number
    subplan_from?: DateTimeFilter<"subscriptions"> | Date | string
    subplan_to?: DateTimeFilter<"subscriptions"> | Date | string
    subplan_status?: StringFilter<"subscriptions"> | string
    subplan_pay_status?: StringFilter<"subscriptions"> | string
    subplan_area?: StringFilter<"subscriptions"> | string
    subplan_admin?: StringFilter<"subscriptions"> | string
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
  }

  export type subscriptionsOrderByWithRelationInput = {
    subplanid?: SortOrder
    subplantype?: SortOrder
    subplanusername?: SortOrder
    subplanamt?: SortOrder
    subplan_from?: SortOrder
    subplan_to?: SortOrder
    subplan_status?: SortOrder
    subplan_pay_status?: SortOrder
    subplan_area?: SortOrder
    subplan_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: subscriptionsOrderByRelevanceInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    subplanid?: number
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    subplantype?: StringFilter<"subscriptions"> | string
    subplanusername?: StringFilter<"subscriptions"> | string
    subplanamt?: IntFilter<"subscriptions"> | number
    subplan_from?: DateTimeFilter<"subscriptions"> | Date | string
    subplan_to?: DateTimeFilter<"subscriptions"> | Date | string
    subplan_status?: StringFilter<"subscriptions"> | string
    subplan_pay_status?: StringFilter<"subscriptions"> | string
    subplan_area?: StringFilter<"subscriptions"> | string
    subplan_admin?: StringFilter<"subscriptions"> | string
    createdAt?: DateTimeFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"subscriptions"> | Date | string
  }, "subplanid">

  export type subscriptionsOrderByWithAggregationInput = {
    subplanid?: SortOrder
    subplantype?: SortOrder
    subplanusername?: SortOrder
    subplanamt?: SortOrder
    subplan_from?: SortOrder
    subplan_to?: SortOrder
    subplan_status?: SortOrder
    subplan_pay_status?: SortOrder
    subplan_area?: SortOrder
    subplan_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _avg?: subscriptionsAvgOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
    _sum?: subscriptionsSumOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    subplanid?: IntWithAggregatesFilter<"subscriptions"> | number
    subplantype?: StringWithAggregatesFilter<"subscriptions"> | string
    subplanusername?: StringWithAggregatesFilter<"subscriptions"> | string
    subplanamt?: IntWithAggregatesFilter<"subscriptions"> | number
    subplan_from?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    subplan_to?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    subplan_status?: StringWithAggregatesFilter<"subscriptions"> | string
    subplan_pay_status?: StringWithAggregatesFilter<"subscriptions"> | string
    subplan_area?: StringWithAggregatesFilter<"subscriptions"> | string
    subplan_admin?: StringWithAggregatesFilter<"subscriptions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
  }

  export type trucksWhereInput = {
    AND?: trucksWhereInput | trucksWhereInput[]
    OR?: trucksWhereInput[]
    NOT?: trucksWhereInput | trucksWhereInput[]
    truckid?: IntFilter<"trucks"> | number
    truck_make?: StringFilter<"trucks"> | string
    truck_plateno?: StringFilter<"trucks"> | string
    truck_fleetowner?: IntNullableFilter<"trucks"> | number | null
    truck_meterid?: StringNullableFilter<"trucks"> | string | null
    truck_driver?: StringNullableFilter<"trucks"> | string | null
    truck_status?: StringFilter<"trucks"> | string
    createdAt?: DateTimeFilter<"trucks"> | Date | string
    updatedAt?: DateTimeFilter<"trucks"> | Date | string
  }

  export type trucksOrderByWithRelationInput = {
    truckid?: SortOrder
    truck_make?: SortOrder
    truck_plateno?: SortOrder
    truck_fleetowner?: SortOrderInput | SortOrder
    truck_meterid?: SortOrderInput | SortOrder
    truck_driver?: SortOrderInput | SortOrder
    truck_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: trucksOrderByRelevanceInput
  }

  export type trucksWhereUniqueInput = Prisma.AtLeast<{
    truckid?: number
    AND?: trucksWhereInput | trucksWhereInput[]
    OR?: trucksWhereInput[]
    NOT?: trucksWhereInput | trucksWhereInput[]
    truck_make?: StringFilter<"trucks"> | string
    truck_plateno?: StringFilter<"trucks"> | string
    truck_fleetowner?: IntNullableFilter<"trucks"> | number | null
    truck_meterid?: StringNullableFilter<"trucks"> | string | null
    truck_driver?: StringNullableFilter<"trucks"> | string | null
    truck_status?: StringFilter<"trucks"> | string
    createdAt?: DateTimeFilter<"trucks"> | Date | string
    updatedAt?: DateTimeFilter<"trucks"> | Date | string
  }, "truckid">

  export type trucksOrderByWithAggregationInput = {
    truckid?: SortOrder
    truck_make?: SortOrder
    truck_plateno?: SortOrder
    truck_fleetowner?: SortOrderInput | SortOrder
    truck_meterid?: SortOrderInput | SortOrder
    truck_driver?: SortOrderInput | SortOrder
    truck_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: trucksCountOrderByAggregateInput
    _avg?: trucksAvgOrderByAggregateInput
    _max?: trucksMaxOrderByAggregateInput
    _min?: trucksMinOrderByAggregateInput
    _sum?: trucksSumOrderByAggregateInput
  }

  export type trucksScalarWhereWithAggregatesInput = {
    AND?: trucksScalarWhereWithAggregatesInput | trucksScalarWhereWithAggregatesInput[]
    OR?: trucksScalarWhereWithAggregatesInput[]
    NOT?: trucksScalarWhereWithAggregatesInput | trucksScalarWhereWithAggregatesInput[]
    truckid?: IntWithAggregatesFilter<"trucks"> | number
    truck_make?: StringWithAggregatesFilter<"trucks"> | string
    truck_plateno?: StringWithAggregatesFilter<"trucks"> | string
    truck_fleetowner?: IntNullableWithAggregatesFilter<"trucks"> | number | null
    truck_meterid?: StringNullableWithAggregatesFilter<"trucks"> | string | null
    truck_driver?: StringNullableWithAggregatesFilter<"trucks"> | string | null
    truck_status?: StringWithAggregatesFilter<"trucks"> | string
    createdAt?: DateTimeWithAggregatesFilter<"trucks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"trucks"> | Date | string
  }

  export type area_groupsWhereInput = {
    AND?: area_groupsWhereInput | area_groupsWhereInput[]
    OR?: area_groupsWhereInput[]
    NOT?: area_groupsWhereInput | area_groupsWhereInput[]
    agid?: IntFilter<"area_groups"> | number
    agname?: StringFilter<"area_groups"> | string
    agareas?: StringFilter<"area_groups"> | string
  }

  export type area_groupsOrderByWithRelationInput = {
    agid?: SortOrder
    agname?: SortOrder
    agareas?: SortOrder
    _relevance?: area_groupsOrderByRelevanceInput
  }

  export type area_groupsWhereUniqueInput = Prisma.AtLeast<{
    agid?: number
    AND?: area_groupsWhereInput | area_groupsWhereInput[]
    OR?: area_groupsWhereInput[]
    NOT?: area_groupsWhereInput | area_groupsWhereInput[]
    agname?: StringFilter<"area_groups"> | string
    agareas?: StringFilter<"area_groups"> | string
  }, "agid">

  export type area_groupsOrderByWithAggregationInput = {
    agid?: SortOrder
    agname?: SortOrder
    agareas?: SortOrder
    _count?: area_groupsCountOrderByAggregateInput
    _avg?: area_groupsAvgOrderByAggregateInput
    _max?: area_groupsMaxOrderByAggregateInput
    _min?: area_groupsMinOrderByAggregateInput
    _sum?: area_groupsSumOrderByAggregateInput
  }

  export type area_groupsScalarWhereWithAggregatesInput = {
    AND?: area_groupsScalarWhereWithAggregatesInput | area_groupsScalarWhereWithAggregatesInput[]
    OR?: area_groupsScalarWhereWithAggregatesInput[]
    NOT?: area_groupsScalarWhereWithAggregatesInput | area_groupsScalarWhereWithAggregatesInput[]
    agid?: IntWithAggregatesFilter<"area_groups"> | number
    agname?: StringWithAggregatesFilter<"area_groups"> | string
    agareas?: StringWithAggregatesFilter<"area_groups"> | string
  }

  export type product_prices_areasWhereInput = {
    AND?: product_prices_areasWhereInput | product_prices_areasWhereInput[]
    OR?: product_prices_areasWhereInput[]
    NOT?: product_prices_areasWhereInput | product_prices_areasWhereInput[]
    ppid?: IntFilter<"product_prices_areas"> | number
    ppa_pid?: IntFilter<"product_prices_areas"> | number
    pparea?: StringFilter<"product_prices_areas"> | string
    pp_subscription?: StringFilter<"product_prices_areas"> | string
    pp_rate?: IntFilter<"product_prices_areas"> | number
  }

  export type product_prices_areasOrderByWithRelationInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pparea?: SortOrder
    pp_subscription?: SortOrder
    pp_rate?: SortOrder
    _relevance?: product_prices_areasOrderByRelevanceInput
  }

  export type product_prices_areasWhereUniqueInput = Prisma.AtLeast<{
    ppid?: number
    AND?: product_prices_areasWhereInput | product_prices_areasWhereInput[]
    OR?: product_prices_areasWhereInput[]
    NOT?: product_prices_areasWhereInput | product_prices_areasWhereInput[]
    ppa_pid?: IntFilter<"product_prices_areas"> | number
    pparea?: StringFilter<"product_prices_areas"> | string
    pp_subscription?: StringFilter<"product_prices_areas"> | string
    pp_rate?: IntFilter<"product_prices_areas"> | number
  }, "ppid">

  export type product_prices_areasOrderByWithAggregationInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pparea?: SortOrder
    pp_subscription?: SortOrder
    pp_rate?: SortOrder
    _count?: product_prices_areasCountOrderByAggregateInput
    _avg?: product_prices_areasAvgOrderByAggregateInput
    _max?: product_prices_areasMaxOrderByAggregateInput
    _min?: product_prices_areasMinOrderByAggregateInput
    _sum?: product_prices_areasSumOrderByAggregateInput
  }

  export type product_prices_areasScalarWhereWithAggregatesInput = {
    AND?: product_prices_areasScalarWhereWithAggregatesInput | product_prices_areasScalarWhereWithAggregatesInput[]
    OR?: product_prices_areasScalarWhereWithAggregatesInput[]
    NOT?: product_prices_areasScalarWhereWithAggregatesInput | product_prices_areasScalarWhereWithAggregatesInput[]
    ppid?: IntWithAggregatesFilter<"product_prices_areas"> | number
    ppa_pid?: IntWithAggregatesFilter<"product_prices_areas"> | number
    pparea?: StringWithAggregatesFilter<"product_prices_areas"> | string
    pp_subscription?: StringWithAggregatesFilter<"product_prices_areas"> | string
    pp_rate?: IntWithAggregatesFilter<"product_prices_areas"> | number
  }

  export type articlesWhereInput = {
    AND?: articlesWhereInput | articlesWhereInput[]
    OR?: articlesWhereInput[]
    NOT?: articlesWhereInput | articlesWhereInput[]
    artid?: IntFilter<"articles"> | number
    artcategory?: StringFilter<"articles"> | string
    title?: StringFilter<"articles"> | string
    titleslug?: StringFilter<"articles"> | string
    fullcontent?: StringFilter<"articles"> | string
    mkeys?: StringFilter<"articles"> | string
    mdesc?: StringFilter<"articles"> | string
    artsource?: StringNullableFilter<"articles"> | string | null
    artsource_url?: StringNullableFilter<"articles"> | string | null
    artphoto?: StringNullableFilter<"articles"> | string | null
    artphotocaption?: StringFilter<"articles"> | string
    artphotourl?: StringNullableFilter<"articles"> | string | null
    author?: StringNullableFilter<"articles"> | string | null
    artstatus?: StringFilter<"articles"> | string
    views?: IntFilter<"articles"> | number
    published_date?: StringFilter<"articles"> | string
    createdAt?: DateTimeFilter<"articles"> | Date | string
    updatedAt?: DateTimeFilter<"articles"> | Date | string
  }

  export type articlesOrderByWithRelationInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    fullcontent?: SortOrder
    mkeys?: SortOrder
    mdesc?: SortOrder
    artsource?: SortOrderInput | SortOrder
    artsource_url?: SortOrderInput | SortOrder
    artphoto?: SortOrderInput | SortOrder
    artphotocaption?: SortOrder
    artphotourl?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    artstatus?: SortOrder
    views?: SortOrder
    published_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: articlesOrderByRelevanceInput
  }

  export type articlesWhereUniqueInput = Prisma.AtLeast<{
    artid?: number
    AND?: articlesWhereInput | articlesWhereInput[]
    OR?: articlesWhereInput[]
    NOT?: articlesWhereInput | articlesWhereInput[]
    artcategory?: StringFilter<"articles"> | string
    title?: StringFilter<"articles"> | string
    titleslug?: StringFilter<"articles"> | string
    fullcontent?: StringFilter<"articles"> | string
    mkeys?: StringFilter<"articles"> | string
    mdesc?: StringFilter<"articles"> | string
    artsource?: StringNullableFilter<"articles"> | string | null
    artsource_url?: StringNullableFilter<"articles"> | string | null
    artphoto?: StringNullableFilter<"articles"> | string | null
    artphotocaption?: StringFilter<"articles"> | string
    artphotourl?: StringNullableFilter<"articles"> | string | null
    author?: StringNullableFilter<"articles"> | string | null
    artstatus?: StringFilter<"articles"> | string
    views?: IntFilter<"articles"> | number
    published_date?: StringFilter<"articles"> | string
    createdAt?: DateTimeFilter<"articles"> | Date | string
    updatedAt?: DateTimeFilter<"articles"> | Date | string
  }, "artid">

  export type articlesOrderByWithAggregationInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    fullcontent?: SortOrder
    mkeys?: SortOrder
    mdesc?: SortOrder
    artsource?: SortOrderInput | SortOrder
    artsource_url?: SortOrderInput | SortOrder
    artphoto?: SortOrderInput | SortOrder
    artphotocaption?: SortOrder
    artphotourl?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    artstatus?: SortOrder
    views?: SortOrder
    published_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: articlesCountOrderByAggregateInput
    _avg?: articlesAvgOrderByAggregateInput
    _max?: articlesMaxOrderByAggregateInput
    _min?: articlesMinOrderByAggregateInput
    _sum?: articlesSumOrderByAggregateInput
  }

  export type articlesScalarWhereWithAggregatesInput = {
    AND?: articlesScalarWhereWithAggregatesInput | articlesScalarWhereWithAggregatesInput[]
    OR?: articlesScalarWhereWithAggregatesInput[]
    NOT?: articlesScalarWhereWithAggregatesInput | articlesScalarWhereWithAggregatesInput[]
    artid?: IntWithAggregatesFilter<"articles"> | number
    artcategory?: StringWithAggregatesFilter<"articles"> | string
    title?: StringWithAggregatesFilter<"articles"> | string
    titleslug?: StringWithAggregatesFilter<"articles"> | string
    fullcontent?: StringWithAggregatesFilter<"articles"> | string
    mkeys?: StringWithAggregatesFilter<"articles"> | string
    mdesc?: StringWithAggregatesFilter<"articles"> | string
    artsource?: StringNullableWithAggregatesFilter<"articles"> | string | null
    artsource_url?: StringNullableWithAggregatesFilter<"articles"> | string | null
    artphoto?: StringNullableWithAggregatesFilter<"articles"> | string | null
    artphotocaption?: StringWithAggregatesFilter<"articles"> | string
    artphotourl?: StringNullableWithAggregatesFilter<"articles"> | string | null
    author?: StringNullableWithAggregatesFilter<"articles"> | string | null
    artstatus?: StringWithAggregatesFilter<"articles"> | string
    views?: IntWithAggregatesFilter<"articles"> | number
    published_date?: StringWithAggregatesFilter<"articles"> | string
    createdAt?: DateTimeWithAggregatesFilter<"articles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"articles"> | Date | string
  }

  export type subscription_plansWhereInput = {
    AND?: subscription_plansWhereInput | subscription_plansWhereInput[]
    OR?: subscription_plansWhereInput[]
    NOT?: subscription_plansWhereInput | subscription_plansWhereInput[]
    subplanid?: IntFilter<"subscription_plans"> | number
    subplan_cat?: StringFilter<"subscription_plans"> | string
    subplan?: StringFilter<"subscription_plans"> | string
    subplan_amount?: FloatFilter<"subscription_plans"> | number
    subplan_months?: StringFilter<"subscription_plans"> | string
    subplan_include?: StringFilter<"subscription_plans"> | string
    subplan_exclude?: StringFilter<"subscription_plans"> | string
    createdAt?: DateTimeFilter<"subscription_plans"> | Date | string
    updatedAt?: DateTimeFilter<"subscription_plans"> | Date | string
  }

  export type subscription_plansOrderByWithRelationInput = {
    subplanid?: SortOrder
    subplan_cat?: SortOrder
    subplan?: SortOrder
    subplan_amount?: SortOrder
    subplan_months?: SortOrder
    subplan_include?: SortOrder
    subplan_exclude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: subscription_plansOrderByRelevanceInput
  }

  export type subscription_plansWhereUniqueInput = Prisma.AtLeast<{
    subplanid?: number
    AND?: subscription_plansWhereInput | subscription_plansWhereInput[]
    OR?: subscription_plansWhereInput[]
    NOT?: subscription_plansWhereInput | subscription_plansWhereInput[]
    subplan_cat?: StringFilter<"subscription_plans"> | string
    subplan?: StringFilter<"subscription_plans"> | string
    subplan_amount?: FloatFilter<"subscription_plans"> | number
    subplan_months?: StringFilter<"subscription_plans"> | string
    subplan_include?: StringFilter<"subscription_plans"> | string
    subplan_exclude?: StringFilter<"subscription_plans"> | string
    createdAt?: DateTimeFilter<"subscription_plans"> | Date | string
    updatedAt?: DateTimeFilter<"subscription_plans"> | Date | string
  }, "subplanid">

  export type subscription_plansOrderByWithAggregationInput = {
    subplanid?: SortOrder
    subplan_cat?: SortOrder
    subplan?: SortOrder
    subplan_amount?: SortOrder
    subplan_months?: SortOrder
    subplan_include?: SortOrder
    subplan_exclude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subscription_plansCountOrderByAggregateInput
    _avg?: subscription_plansAvgOrderByAggregateInput
    _max?: subscription_plansMaxOrderByAggregateInput
    _min?: subscription_plansMinOrderByAggregateInput
    _sum?: subscription_plansSumOrderByAggregateInput
  }

  export type subscription_plansScalarWhereWithAggregatesInput = {
    AND?: subscription_plansScalarWhereWithAggregatesInput | subscription_plansScalarWhereWithAggregatesInput[]
    OR?: subscription_plansScalarWhereWithAggregatesInput[]
    NOT?: subscription_plansScalarWhereWithAggregatesInput | subscription_plansScalarWhereWithAggregatesInput[]
    subplanid?: IntWithAggregatesFilter<"subscription_plans"> | number
    subplan_cat?: StringWithAggregatesFilter<"subscription_plans"> | string
    subplan?: StringWithAggregatesFilter<"subscription_plans"> | string
    subplan_amount?: FloatWithAggregatesFilter<"subscription_plans"> | number
    subplan_months?: StringWithAggregatesFilter<"subscription_plans"> | string
    subplan_include?: StringWithAggregatesFilter<"subscription_plans"> | string
    subplan_exclude?: StringWithAggregatesFilter<"subscription_plans"> | string
    createdAt?: DateTimeWithAggregatesFilter<"subscription_plans"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"subscription_plans"> | Date | string
  }

  export type vendorreportsWhereInput = {
    AND?: vendorreportsWhereInput | vendorreportsWhereInput[]
    OR?: vendorreportsWhereInput[]
    NOT?: vendorreportsWhereInput | vendorreportsWhereInput[]
    id?: IntFilter<"vendorreports"> | number
    customerid?: StringNullableFilter<"vendorreports"> | string | null
    customername?: StringFilter<"vendorreports"> | string
    vendorid?: StringFilter<"vendorreports"> | string
    plateno?: StringFilter<"vendorreports"> | string
    createdAt?: DateTimeFilter<"vendorreports"> | Date | string
    updatedAt?: DateTimeFilter<"vendorreports"> | Date | string
  }

  export type vendorreportsOrderByWithRelationInput = {
    id?: SortOrder
    customerid?: SortOrderInput | SortOrder
    customername?: SortOrder
    vendorid?: SortOrder
    plateno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: vendorreportsOrderByRelevanceInput
  }

  export type vendorreportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: vendorreportsWhereInput | vendorreportsWhereInput[]
    OR?: vendorreportsWhereInput[]
    NOT?: vendorreportsWhereInput | vendorreportsWhereInput[]
    customerid?: StringNullableFilter<"vendorreports"> | string | null
    customername?: StringFilter<"vendorreports"> | string
    vendorid?: StringFilter<"vendorreports"> | string
    plateno?: StringFilter<"vendorreports"> | string
    createdAt?: DateTimeFilter<"vendorreports"> | Date | string
    updatedAt?: DateTimeFilter<"vendorreports"> | Date | string
  }, "id">

  export type vendorreportsOrderByWithAggregationInput = {
    id?: SortOrder
    customerid?: SortOrderInput | SortOrder
    customername?: SortOrder
    vendorid?: SortOrder
    plateno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vendorreportsCountOrderByAggregateInput
    _avg?: vendorreportsAvgOrderByAggregateInput
    _max?: vendorreportsMaxOrderByAggregateInput
    _min?: vendorreportsMinOrderByAggregateInput
    _sum?: vendorreportsSumOrderByAggregateInput
  }

  export type vendorreportsScalarWhereWithAggregatesInput = {
    AND?: vendorreportsScalarWhereWithAggregatesInput | vendorreportsScalarWhereWithAggregatesInput[]
    OR?: vendorreportsScalarWhereWithAggregatesInput[]
    NOT?: vendorreportsScalarWhereWithAggregatesInput | vendorreportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"vendorreports"> | number
    customerid?: StringNullableWithAggregatesFilter<"vendorreports"> | string | null
    customername?: StringWithAggregatesFilter<"vendorreports"> | string
    vendorid?: StringWithAggregatesFilter<"vendorreports"> | string
    plateno?: StringWithAggregatesFilter<"vendorreports"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vendorreports"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vendorreports"> | Date | string
  }

  export type water_purchasesWhereInput = {
    AND?: water_purchasesWhereInput | water_purchasesWhereInput[]
    OR?: water_purchasesWhereInput[]
    NOT?: water_purchasesWhereInput | water_purchasesWhereInput[]
    wpid?: IntFilter<"water_purchases"> | number
    wp_orderref?: StringNullableFilter<"water_purchases"> | string | null
    wp_type?: StringFilter<"water_purchases"> | string
    wp_merchant_id?: StringFilter<"water_purchases"> | string
    wp_merchant_name?: StringFilter<"water_purchases"> | string
    wp_merchant_address?: StringFilter<"water_purchases"> | string
    wp_merchant_latitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFilter<"water_purchases"> | string
    wp_amount?: FloatFilter<"water_purchases"> | number
    wp_commission?: FloatFilter<"water_purchases"> | number
    wp_owner_amount?: FloatFilter<"water_purchases"> | number
    wp_driver_id?: StringFilter<"water_purchases"> | string
    wp_driver_name?: StringFilter<"water_purchases"> | string
    wp_driver_latitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFilter<"water_purchases"> | string
    wp_remark?: StringFilter<"water_purchases"> | string
    createdAt?: DateTimeFilter<"water_purchases"> | Date | string
    updatedAt?: DateTimeFilter<"water_purchases"> | Date | string
  }

  export type water_purchasesOrderByWithRelationInput = {
    wpid?: SortOrder
    wp_orderref?: SortOrderInput | SortOrder
    wp_type?: SortOrder
    wp_merchant_id?: SortOrder
    wp_merchant_name?: SortOrder
    wp_merchant_address?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_volume?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_id?: SortOrder
    wp_driver_name?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
    wp_fleetid?: SortOrder
    wp_remark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: water_purchasesOrderByRelevanceInput
  }

  export type water_purchasesWhereUniqueInput = Prisma.AtLeast<{
    wpid?: number
    AND?: water_purchasesWhereInput | water_purchasesWhereInput[]
    OR?: water_purchasesWhereInput[]
    NOT?: water_purchasesWhereInput | water_purchasesWhereInput[]
    wp_orderref?: StringNullableFilter<"water_purchases"> | string | null
    wp_type?: StringFilter<"water_purchases"> | string
    wp_merchant_id?: StringFilter<"water_purchases"> | string
    wp_merchant_name?: StringFilter<"water_purchases"> | string
    wp_merchant_address?: StringFilter<"water_purchases"> | string
    wp_merchant_latitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFilter<"water_purchases"> | string
    wp_amount?: FloatFilter<"water_purchases"> | number
    wp_commission?: FloatFilter<"water_purchases"> | number
    wp_owner_amount?: FloatFilter<"water_purchases"> | number
    wp_driver_id?: StringFilter<"water_purchases"> | string
    wp_driver_name?: StringFilter<"water_purchases"> | string
    wp_driver_latitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFilter<"water_purchases"> | string
    wp_remark?: StringFilter<"water_purchases"> | string
    createdAt?: DateTimeFilter<"water_purchases"> | Date | string
    updatedAt?: DateTimeFilter<"water_purchases"> | Date | string
  }, "wpid">

  export type water_purchasesOrderByWithAggregationInput = {
    wpid?: SortOrder
    wp_orderref?: SortOrderInput | SortOrder
    wp_type?: SortOrder
    wp_merchant_id?: SortOrder
    wp_merchant_name?: SortOrder
    wp_merchant_address?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_volume?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_id?: SortOrder
    wp_driver_name?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
    wp_fleetid?: SortOrder
    wp_remark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: water_purchasesCountOrderByAggregateInput
    _avg?: water_purchasesAvgOrderByAggregateInput
    _max?: water_purchasesMaxOrderByAggregateInput
    _min?: water_purchasesMinOrderByAggregateInput
    _sum?: water_purchasesSumOrderByAggregateInput
  }

  export type water_purchasesScalarWhereWithAggregatesInput = {
    AND?: water_purchasesScalarWhereWithAggregatesInput | water_purchasesScalarWhereWithAggregatesInput[]
    OR?: water_purchasesScalarWhereWithAggregatesInput[]
    NOT?: water_purchasesScalarWhereWithAggregatesInput | water_purchasesScalarWhereWithAggregatesInput[]
    wpid?: IntWithAggregatesFilter<"water_purchases"> | number
    wp_orderref?: StringNullableWithAggregatesFilter<"water_purchases"> | string | null
    wp_type?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_merchant_id?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_merchant_name?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_merchant_address?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_merchant_latitude?: DecimalWithAggregatesFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalWithAggregatesFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_volume?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_amount?: FloatWithAggregatesFilter<"water_purchases"> | number
    wp_commission?: FloatWithAggregatesFilter<"water_purchases"> | number
    wp_owner_amount?: FloatWithAggregatesFilter<"water_purchases"> | number
    wp_driver_id?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_driver_name?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_driver_latitude?: DecimalWithAggregatesFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalWithAggregatesFilter<"water_purchases"> | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringWithAggregatesFilter<"water_purchases"> | string
    wp_remark?: StringWithAggregatesFilter<"water_purchases"> | string
    createdAt?: DateTimeWithAggregatesFilter<"water_purchases"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"water_purchases"> | Date | string
  }

  export type MeterReadingsWhereInput = {
    AND?: MeterReadingsWhereInput | MeterReadingsWhereInput[]
    OR?: MeterReadingsWhereInput[]
    NOT?: MeterReadingsWhereInput | MeterReadingsWhereInput[]
    id?: IntFilter<"MeterReadings"> | number
    meterId?: IntFilter<"MeterReadings"> | number
    reading_date?: DateTimeFilter<"MeterReadings"> | Date | string
    first_reading?: StringNullableFilter<"MeterReadings"> | string | null
    first_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    first_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    afternoon_reading?: StringNullableFilter<"MeterReadings"> | string | null
    afternoon_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    afternoon_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    last_reading?: StringNullableFilter<"MeterReadings"> | string | null
    last_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    last_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    createdAt?: DateTimeFilter<"MeterReadings"> | Date | string
    updatedAt?: DateTimeFilter<"MeterReadings"> | Date | string
    meter?: XOR<MetersScalarRelationFilter, metersWhereInput>
    first_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    afternoon_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    last_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type MeterReadingsOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    reading_date?: SortOrder
    first_reading?: SortOrderInput | SortOrder
    first_reading_user_id?: SortOrderInput | SortOrder
    first_reading_at?: SortOrderInput | SortOrder
    afternoon_reading?: SortOrderInput | SortOrder
    afternoon_reading_user_id?: SortOrderInput | SortOrder
    afternoon_reading_at?: SortOrderInput | SortOrder
    last_reading?: SortOrderInput | SortOrder
    last_reading_user_id?: SortOrderInput | SortOrder
    last_reading_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meter?: metersOrderByWithRelationInput
    first_reading_user?: usersOrderByWithRelationInput
    afternoon_reading_user?: usersOrderByWithRelationInput
    last_reading_user?: usersOrderByWithRelationInput
    _relevance?: MeterReadingsOrderByRelevanceInput
  }

  export type MeterReadingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    meterId_reading_date?: MeterReadingsMeterIdReading_dateCompoundUniqueInput
    AND?: MeterReadingsWhereInput | MeterReadingsWhereInput[]
    OR?: MeterReadingsWhereInput[]
    NOT?: MeterReadingsWhereInput | MeterReadingsWhereInput[]
    meterId?: IntFilter<"MeterReadings"> | number
    reading_date?: DateTimeFilter<"MeterReadings"> | Date | string
    first_reading?: StringNullableFilter<"MeterReadings"> | string | null
    first_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    first_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    afternoon_reading?: StringNullableFilter<"MeterReadings"> | string | null
    afternoon_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    afternoon_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    last_reading?: StringNullableFilter<"MeterReadings"> | string | null
    last_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    last_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    createdAt?: DateTimeFilter<"MeterReadings"> | Date | string
    updatedAt?: DateTimeFilter<"MeterReadings"> | Date | string
    meter?: XOR<MetersScalarRelationFilter, metersWhereInput>
    first_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    afternoon_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    last_reading_user?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id" | "meterId_reading_date">

  export type MeterReadingsOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    reading_date?: SortOrder
    first_reading?: SortOrderInput | SortOrder
    first_reading_user_id?: SortOrderInput | SortOrder
    first_reading_at?: SortOrderInput | SortOrder
    afternoon_reading?: SortOrderInput | SortOrder
    afternoon_reading_user_id?: SortOrderInput | SortOrder
    afternoon_reading_at?: SortOrderInput | SortOrder
    last_reading?: SortOrderInput | SortOrder
    last_reading_user_id?: SortOrderInput | SortOrder
    last_reading_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeterReadingsCountOrderByAggregateInput
    _avg?: MeterReadingsAvgOrderByAggregateInput
    _max?: MeterReadingsMaxOrderByAggregateInput
    _min?: MeterReadingsMinOrderByAggregateInput
    _sum?: MeterReadingsSumOrderByAggregateInput
  }

  export type MeterReadingsScalarWhereWithAggregatesInput = {
    AND?: MeterReadingsScalarWhereWithAggregatesInput | MeterReadingsScalarWhereWithAggregatesInput[]
    OR?: MeterReadingsScalarWhereWithAggregatesInput[]
    NOT?: MeterReadingsScalarWhereWithAggregatesInput | MeterReadingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MeterReadings"> | number
    meterId?: IntWithAggregatesFilter<"MeterReadings"> | number
    reading_date?: DateTimeWithAggregatesFilter<"MeterReadings"> | Date | string
    first_reading?: StringNullableWithAggregatesFilter<"MeterReadings"> | string | null
    first_reading_user_id?: IntNullableWithAggregatesFilter<"MeterReadings"> | number | null
    first_reading_at?: DateTimeNullableWithAggregatesFilter<"MeterReadings"> | Date | string | null
    afternoon_reading?: StringNullableWithAggregatesFilter<"MeterReadings"> | string | null
    afternoon_reading_user_id?: IntNullableWithAggregatesFilter<"MeterReadings"> | number | null
    afternoon_reading_at?: DateTimeNullableWithAggregatesFilter<"MeterReadings"> | Date | string | null
    last_reading?: StringNullableWithAggregatesFilter<"MeterReadings"> | string | null
    last_reading_user_id?: IntNullableWithAggregatesFilter<"MeterReadings"> | number | null
    last_reading_at?: DateTimeNullableWithAggregatesFilter<"MeterReadings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MeterReadings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MeterReadings"> | Date | string
  }

  export type banneradsCreateInput = {
    title_ad?: string
    descr_ad: string
    adcode: string
    file_ad: string
    topfile_ad?: string | null
    url_ad?: string
    banner_rank: number
    addedon_ad?: Date | string
    startdate_ad?: Date | string
    enddate_ad?: Date | string
    daysno_ad?: string
    width_ad?: string | null
    height_ad?: string | null
    position_ad?: string
    banner_status: string
    visible_ad?: number
    userid_ad: string
    username_ad: string
    paid?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    datepaid?: Date | string | null
    remark?: string | null
    views_ad?: number
    clicks_ad?: number
  }

  export type banneradsUncheckedCreateInput = {
    id_ad?: number
    title_ad?: string
    descr_ad: string
    adcode: string
    file_ad: string
    topfile_ad?: string | null
    url_ad?: string
    banner_rank: number
    addedon_ad?: Date | string
    startdate_ad?: Date | string
    enddate_ad?: Date | string
    daysno_ad?: string
    width_ad?: string | null
    height_ad?: string | null
    position_ad?: string
    banner_status: string
    visible_ad?: number
    userid_ad: string
    username_ad: string
    paid?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    datepaid?: Date | string | null
    remark?: string | null
    views_ad?: number
    clicks_ad?: number
  }

  export type banneradsUpdateInput = {
    title_ad?: StringFieldUpdateOperationsInput | string
    descr_ad?: StringFieldUpdateOperationsInput | string
    adcode?: StringFieldUpdateOperationsInput | string
    file_ad?: StringFieldUpdateOperationsInput | string
    topfile_ad?: NullableStringFieldUpdateOperationsInput | string | null
    url_ad?: StringFieldUpdateOperationsInput | string
    banner_rank?: IntFieldUpdateOperationsInput | number
    addedon_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    startdate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    enddate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    daysno_ad?: StringFieldUpdateOperationsInput | string
    width_ad?: NullableStringFieldUpdateOperationsInput | string | null
    height_ad?: NullableStringFieldUpdateOperationsInput | string | null
    position_ad?: StringFieldUpdateOperationsInput | string
    banner_status?: StringFieldUpdateOperationsInput | string
    visible_ad?: IntFieldUpdateOperationsInput | number
    userid_ad?: StringFieldUpdateOperationsInput | string
    username_ad?: StringFieldUpdateOperationsInput | string
    paid?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    datepaid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    views_ad?: IntFieldUpdateOperationsInput | number
    clicks_ad?: IntFieldUpdateOperationsInput | number
  }

  export type banneradsUncheckedUpdateInput = {
    id_ad?: IntFieldUpdateOperationsInput | number
    title_ad?: StringFieldUpdateOperationsInput | string
    descr_ad?: StringFieldUpdateOperationsInput | string
    adcode?: StringFieldUpdateOperationsInput | string
    file_ad?: StringFieldUpdateOperationsInput | string
    topfile_ad?: NullableStringFieldUpdateOperationsInput | string | null
    url_ad?: StringFieldUpdateOperationsInput | string
    banner_rank?: IntFieldUpdateOperationsInput | number
    addedon_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    startdate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    enddate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    daysno_ad?: StringFieldUpdateOperationsInput | string
    width_ad?: NullableStringFieldUpdateOperationsInput | string | null
    height_ad?: NullableStringFieldUpdateOperationsInput | string | null
    position_ad?: StringFieldUpdateOperationsInput | string
    banner_status?: StringFieldUpdateOperationsInput | string
    visible_ad?: IntFieldUpdateOperationsInput | number
    userid_ad?: StringFieldUpdateOperationsInput | string
    username_ad?: StringFieldUpdateOperationsInput | string
    paid?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    datepaid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    views_ad?: IntFieldUpdateOperationsInput | number
    clicks_ad?: IntFieldUpdateOperationsInput | number
  }

  export type banneradsCreateManyInput = {
    id_ad?: number
    title_ad?: string
    descr_ad: string
    adcode: string
    file_ad: string
    topfile_ad?: string | null
    url_ad?: string
    banner_rank: number
    addedon_ad?: Date | string
    startdate_ad?: Date | string
    enddate_ad?: Date | string
    daysno_ad?: string
    width_ad?: string | null
    height_ad?: string | null
    position_ad?: string
    banner_status: string
    visible_ad?: number
    userid_ad: string
    username_ad: string
    paid?: number
    amount?: Decimal | DecimalJsLike | number | string | null
    datepaid?: Date | string | null
    remark?: string | null
    views_ad?: number
    clicks_ad?: number
  }

  export type banneradsUpdateManyMutationInput = {
    title_ad?: StringFieldUpdateOperationsInput | string
    descr_ad?: StringFieldUpdateOperationsInput | string
    adcode?: StringFieldUpdateOperationsInput | string
    file_ad?: StringFieldUpdateOperationsInput | string
    topfile_ad?: NullableStringFieldUpdateOperationsInput | string | null
    url_ad?: StringFieldUpdateOperationsInput | string
    banner_rank?: IntFieldUpdateOperationsInput | number
    addedon_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    startdate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    enddate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    daysno_ad?: StringFieldUpdateOperationsInput | string
    width_ad?: NullableStringFieldUpdateOperationsInput | string | null
    height_ad?: NullableStringFieldUpdateOperationsInput | string | null
    position_ad?: StringFieldUpdateOperationsInput | string
    banner_status?: StringFieldUpdateOperationsInput | string
    visible_ad?: IntFieldUpdateOperationsInput | number
    userid_ad?: StringFieldUpdateOperationsInput | string
    username_ad?: StringFieldUpdateOperationsInput | string
    paid?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    datepaid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    views_ad?: IntFieldUpdateOperationsInput | number
    clicks_ad?: IntFieldUpdateOperationsInput | number
  }

  export type banneradsUncheckedUpdateManyInput = {
    id_ad?: IntFieldUpdateOperationsInput | number
    title_ad?: StringFieldUpdateOperationsInput | string
    descr_ad?: StringFieldUpdateOperationsInput | string
    adcode?: StringFieldUpdateOperationsInput | string
    file_ad?: StringFieldUpdateOperationsInput | string
    topfile_ad?: NullableStringFieldUpdateOperationsInput | string | null
    url_ad?: StringFieldUpdateOperationsInput | string
    banner_rank?: IntFieldUpdateOperationsInput | number
    addedon_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    startdate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    enddate_ad?: DateTimeFieldUpdateOperationsInput | Date | string
    daysno_ad?: StringFieldUpdateOperationsInput | string
    width_ad?: NullableStringFieldUpdateOperationsInput | string | null
    height_ad?: NullableStringFieldUpdateOperationsInput | string | null
    position_ad?: StringFieldUpdateOperationsInput | string
    banner_status?: StringFieldUpdateOperationsInput | string
    visible_ad?: IntFieldUpdateOperationsInput | number
    userid_ad?: StringFieldUpdateOperationsInput | string
    username_ad?: StringFieldUpdateOperationsInput | string
    paid?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    datepaid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    views_ad?: IntFieldUpdateOperationsInput | number
    clicks_ad?: IntFieldUpdateOperationsInput | number
  }

  export type blogCreateInput = {
    artcategory: string
    title: string
    titleslug: string
    brief: string
    fullcontent: string
    artphoto?: string | null
    artphotocaption: string
    author?: string | null
    artsource?: string | null
    artsource_url?: string | null
    published_date: Date | string
    artstatus?: string
    nstatus: string
    views?: number
    artsubmit?: Date | string
    artusername: string
    youtube_embed?: string | null
    vidurl: string
    homepage?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type blogUncheckedCreateInput = {
    artid?: number
    artcategory: string
    title: string
    titleslug: string
    brief: string
    fullcontent: string
    artphoto?: string | null
    artphotocaption: string
    author?: string | null
    artsource?: string | null
    artsource_url?: string | null
    published_date: Date | string
    artstatus?: string
    nstatus: string
    views?: number
    artsubmit?: Date | string
    artusername: string
    youtube_embed?: string | null
    vidurl: string
    homepage?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type blogUpdateInput = {
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    artstatus?: StringFieldUpdateOperationsInput | string
    nstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    artsubmit?: DateTimeFieldUpdateOperationsInput | Date | string
    artusername?: StringFieldUpdateOperationsInput | string
    youtube_embed?: NullableStringFieldUpdateOperationsInput | string | null
    vidurl?: StringFieldUpdateOperationsInput | string
    homepage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogUncheckedUpdateInput = {
    artid?: IntFieldUpdateOperationsInput | number
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    artstatus?: StringFieldUpdateOperationsInput | string
    nstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    artsubmit?: DateTimeFieldUpdateOperationsInput | Date | string
    artusername?: StringFieldUpdateOperationsInput | string
    youtube_embed?: NullableStringFieldUpdateOperationsInput | string | null
    vidurl?: StringFieldUpdateOperationsInput | string
    homepage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogCreateManyInput = {
    artid?: number
    artcategory: string
    title: string
    titleslug: string
    brief: string
    fullcontent: string
    artphoto?: string | null
    artphotocaption: string
    author?: string | null
    artsource?: string | null
    artsource_url?: string | null
    published_date: Date | string
    artstatus?: string
    nstatus: string
    views?: number
    artsubmit?: Date | string
    artusername: string
    youtube_embed?: string | null
    vidurl: string
    homepage?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type blogUpdateManyMutationInput = {
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    artstatus?: StringFieldUpdateOperationsInput | string
    nstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    artsubmit?: DateTimeFieldUpdateOperationsInput | Date | string
    artusername?: StringFieldUpdateOperationsInput | string
    youtube_embed?: NullableStringFieldUpdateOperationsInput | string | null
    vidurl?: StringFieldUpdateOperationsInput | string
    homepage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogUncheckedUpdateManyInput = {
    artid?: IntFieldUpdateOperationsInput | number
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    brief?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    artstatus?: StringFieldUpdateOperationsInput | string
    nstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    artsubmit?: DateTimeFieldUpdateOperationsInput | Date | string
    artusername?: StringFieldUpdateOperationsInput | string
    youtube_embed?: NullableStringFieldUpdateOperationsInput | string | null
    vidurl?: StringFieldUpdateOperationsInput | string
    homepage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contentpagesCreateInput = {
    cpagename: string
    cpagecontent: string
    cpagephoto?: string | null
    cpagesbanner?: string | null
    cpagemenu?: string
    cpagelinkname: string
    cpage_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contentpagesUncheckedCreateInput = {
    cpageid?: number
    cpagename: string
    cpagecontent: string
    cpagephoto?: string | null
    cpagesbanner?: string | null
    cpagemenu?: string
    cpagelinkname: string
    cpage_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contentpagesUpdateInput = {
    cpagename?: StringFieldUpdateOperationsInput | string
    cpagecontent?: StringFieldUpdateOperationsInput | string
    cpagephoto?: NullableStringFieldUpdateOperationsInput | string | null
    cpagesbanner?: NullableStringFieldUpdateOperationsInput | string | null
    cpagemenu?: StringFieldUpdateOperationsInput | string
    cpagelinkname?: StringFieldUpdateOperationsInput | string
    cpage_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contentpagesUncheckedUpdateInput = {
    cpageid?: IntFieldUpdateOperationsInput | number
    cpagename?: StringFieldUpdateOperationsInput | string
    cpagecontent?: StringFieldUpdateOperationsInput | string
    cpagephoto?: NullableStringFieldUpdateOperationsInput | string | null
    cpagesbanner?: NullableStringFieldUpdateOperationsInput | string | null
    cpagemenu?: StringFieldUpdateOperationsInput | string
    cpagelinkname?: StringFieldUpdateOperationsInput | string
    cpage_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contentpagesCreateManyInput = {
    cpageid?: number
    cpagename: string
    cpagecontent: string
    cpagephoto?: string | null
    cpagesbanner?: string | null
    cpagemenu?: string
    cpagelinkname: string
    cpage_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contentpagesUpdateManyMutationInput = {
    cpagename?: StringFieldUpdateOperationsInput | string
    cpagecontent?: StringFieldUpdateOperationsInput | string
    cpagephoto?: NullableStringFieldUpdateOperationsInput | string | null
    cpagesbanner?: NullableStringFieldUpdateOperationsInput | string | null
    cpagemenu?: StringFieldUpdateOperationsInput | string
    cpagelinkname?: StringFieldUpdateOperationsInput | string
    cpage_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contentpagesUncheckedUpdateManyInput = {
    cpageid?: IntFieldUpdateOperationsInput | number
    cpagename?: StringFieldUpdateOperationsInput | string
    cpagecontent?: StringFieldUpdateOperationsInput | string
    cpagephoto?: NullableStringFieldUpdateOperationsInput | string | null
    cpagesbanner?: NullableStringFieldUpdateOperationsInput | string | null
    cpagemenu?: StringFieldUpdateOperationsInput | string
    cpagelinkname?: StringFieldUpdateOperationsInput | string
    cpage_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driver_paymentsCreateInput = {
    dpayref: string
    dpaydriver: number
    dpayoutstanding: number
    dpaypaystackref: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type driver_paymentsUncheckedCreateInput = {
    dpayid?: number
    dpayref: string
    dpaydriver: number
    dpayoutstanding: number
    dpaypaystackref: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type driver_paymentsUpdateInput = {
    dpayref?: StringFieldUpdateOperationsInput | string
    dpaydriver?: IntFieldUpdateOperationsInput | number
    dpayoutstanding?: FloatFieldUpdateOperationsInput | number
    dpaypaystackref?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driver_paymentsUncheckedUpdateInput = {
    dpayid?: IntFieldUpdateOperationsInput | number
    dpayref?: StringFieldUpdateOperationsInput | string
    dpaydriver?: IntFieldUpdateOperationsInput | number
    dpayoutstanding?: FloatFieldUpdateOperationsInput | number
    dpaypaystackref?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driver_paymentsCreateManyInput = {
    dpayid?: number
    dpayref: string
    dpaydriver: number
    dpayoutstanding: number
    dpaypaystackref: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type driver_paymentsUpdateManyMutationInput = {
    dpayref?: StringFieldUpdateOperationsInput | string
    dpaydriver?: IntFieldUpdateOperationsInput | number
    dpayoutstanding?: FloatFieldUpdateOperationsInput | number
    dpaypaystackref?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driver_paymentsUncheckedUpdateManyInput = {
    dpayid?: IntFieldUpdateOperationsInput | number
    dpayref?: StringFieldUpdateOperationsInput | string
    dpaydriver?: IntFieldUpdateOperationsInput | number
    dpayoutstanding?: FloatFieldUpdateOperationsInput | number
    dpaypaystackref?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsCreateInput = {
    faqcat: string
    faqquestion: string
    faqanswer: string
    faqslug: string
    faqpostedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type faqsUncheckedCreateInput = {
    faqid?: number
    faqcat: string
    faqquestion: string
    faqanswer: string
    faqslug: string
    faqpostedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type faqsUpdateInput = {
    faqcat?: StringFieldUpdateOperationsInput | string
    faqquestion?: StringFieldUpdateOperationsInput | string
    faqanswer?: StringFieldUpdateOperationsInput | string
    faqslug?: StringFieldUpdateOperationsInput | string
    faqpostedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateInput = {
    faqid?: IntFieldUpdateOperationsInput | number
    faqcat?: StringFieldUpdateOperationsInput | string
    faqquestion?: StringFieldUpdateOperationsInput | string
    faqanswer?: StringFieldUpdateOperationsInput | string
    faqslug?: StringFieldUpdateOperationsInput | string
    faqpostedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsCreateManyInput = {
    faqid?: number
    faqcat: string
    faqquestion: string
    faqanswer: string
    faqslug: string
    faqpostedby: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type faqsUpdateManyMutationInput = {
    faqcat?: StringFieldUpdateOperationsInput | string
    faqquestion?: StringFieldUpdateOperationsInput | string
    faqanswer?: StringFieldUpdateOperationsInput | string
    faqslug?: StringFieldUpdateOperationsInput | string
    faqpostedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateManyInput = {
    faqid?: IntFieldUpdateOperationsInput | number
    faqcat?: StringFieldUpdateOperationsInput | string
    faqquestion?: StringFieldUpdateOperationsInput | string
    faqanswer?: StringFieldUpdateOperationsInput | string
    faqslug?: StringFieldUpdateOperationsInput | string
    faqpostedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loc_statesCreateInput = {
    stateid: number
    state: string
  }

  export type loc_statesUncheckedCreateInput = {
    stateid: number
    state: string
  }

  export type loc_statesUpdateInput = {
    stateid?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type loc_statesUncheckedUpdateInput = {
    stateid?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type loc_statesCreateManyInput = {
    stateid: number
    state: string
  }

  export type loc_statesUpdateManyMutationInput = {
    stateid?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type loc_statesUncheckedUpdateManyInput = {
    stateid?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type media_assetsCreateInput = {
    massetid: number
    masset: string
    massetdate?: Date | string
  }

  export type media_assetsUncheckedCreateInput = {
    massetid: number
    masset: string
    massetdate?: Date | string
  }

  export type media_assetsUpdateInput = {
    massetid?: IntFieldUpdateOperationsInput | number
    masset?: StringFieldUpdateOperationsInput | string
    massetdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type media_assetsUncheckedUpdateInput = {
    massetid?: IntFieldUpdateOperationsInput | number
    masset?: StringFieldUpdateOperationsInput | string
    massetdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type media_assetsCreateManyInput = {
    massetid: number
    masset: string
    massetdate?: Date | string
  }

  export type media_assetsUpdateManyMutationInput = {
    massetid?: IntFieldUpdateOperationsInput | number
    masset?: StringFieldUpdateOperationsInput | string
    massetdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type media_assetsUncheckedUpdateManyInput = {
    massetid?: IntFieldUpdateOperationsInput | number
    masset?: StringFieldUpdateOperationsInput | string
    massetdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type newsletterCreateInput = {
    nlname: string
    nlemail: string
    nlstatus?: number
    nl_received?: number
    nl_id?: number
  }

  export type newsletterUncheckedCreateInput = {
    nlid?: number
    nlname: string
    nlemail: string
    nlstatus?: number
    nl_received?: number
    nl_id?: number
  }

  export type newsletterUpdateInput = {
    nlname?: StringFieldUpdateOperationsInput | string
    nlemail?: StringFieldUpdateOperationsInput | string
    nlstatus?: IntFieldUpdateOperationsInput | number
    nl_received?: IntFieldUpdateOperationsInput | number
    nl_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsletterUncheckedUpdateInput = {
    nlid?: IntFieldUpdateOperationsInput | number
    nlname?: StringFieldUpdateOperationsInput | string
    nlemail?: StringFieldUpdateOperationsInput | string
    nlstatus?: IntFieldUpdateOperationsInput | number
    nl_received?: IntFieldUpdateOperationsInput | number
    nl_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsletterCreateManyInput = {
    nlid?: number
    nlname: string
    nlemail: string
    nlstatus?: number
    nl_received?: number
    nl_id?: number
  }

  export type newsletterUpdateManyMutationInput = {
    nlname?: StringFieldUpdateOperationsInput | string
    nlemail?: StringFieldUpdateOperationsInput | string
    nlstatus?: IntFieldUpdateOperationsInput | number
    nl_received?: IntFieldUpdateOperationsInput | number
    nl_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsletterUncheckedUpdateManyInput = {
    nlid?: IntFieldUpdateOperationsInput | number
    nlname?: StringFieldUpdateOperationsInput | string
    nlemail?: StringFieldUpdateOperationsInput | string
    nlstatus?: IntFieldUpdateOperationsInput | number
    nl_received?: IntFieldUpdateOperationsInput | number
    nl_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsletter_bodyCreateInput = {
    nlb_title: string
    nlb_story: string
    nlb_finished?: string
    nlb_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type newsletter_bodyUncheckedCreateInput = {
    nlb_id?: number
    nlb_title: string
    nlb_story: string
    nlb_finished?: string
    nlb_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type newsletter_bodyUpdateInput = {
    nlb_title?: StringFieldUpdateOperationsInput | string
    nlb_story?: StringFieldUpdateOperationsInput | string
    nlb_finished?: StringFieldUpdateOperationsInput | string
    nlb_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_bodyUncheckedUpdateInput = {
    nlb_id?: IntFieldUpdateOperationsInput | number
    nlb_title?: StringFieldUpdateOperationsInput | string
    nlb_story?: StringFieldUpdateOperationsInput | string
    nlb_finished?: StringFieldUpdateOperationsInput | string
    nlb_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_bodyCreateManyInput = {
    nlb_id?: number
    nlb_title: string
    nlb_story: string
    nlb_finished?: string
    nlb_postedby: string
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type newsletter_bodyUpdateManyMutationInput = {
    nlb_title?: StringFieldUpdateOperationsInput | string
    nlb_story?: StringFieldUpdateOperationsInput | string
    nlb_finished?: StringFieldUpdateOperationsInput | string
    nlb_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_bodyUncheckedUpdateManyInput = {
    nlb_id?: IntFieldUpdateOperationsInput | number
    nlb_title?: StringFieldUpdateOperationsInput | string
    nlb_story?: StringFieldUpdateOperationsInput | string
    nlb_finished?: StringFieldUpdateOperationsInput | string
    nlb_postedby?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paystackresponseCreateInput = {
    prbody: string
    pracc_number?: string | null
    pracc_bank?: string | null
    createdAt: Date | string
  }

  export type paystackresponseUncheckedCreateInput = {
    prid?: number
    prbody: string
    pracc_number?: string | null
    pracc_bank?: string | null
    createdAt: Date | string
  }

  export type paystackresponseUpdateInput = {
    prbody?: StringFieldUpdateOperationsInput | string
    pracc_number?: NullableStringFieldUpdateOperationsInput | string | null
    pracc_bank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paystackresponseUncheckedUpdateInput = {
    prid?: IntFieldUpdateOperationsInput | number
    prbody?: StringFieldUpdateOperationsInput | string
    pracc_number?: NullableStringFieldUpdateOperationsInput | string | null
    pracc_bank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paystackresponseCreateManyInput = {
    prid?: number
    prbody: string
    pracc_number?: string | null
    pracc_bank?: string | null
    createdAt: Date | string
  }

  export type paystackresponseUpdateManyMutationInput = {
    prbody?: StringFieldUpdateOperationsInput | string
    pracc_number?: NullableStringFieldUpdateOperationsInput | string | null
    pracc_bank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paystackresponseUncheckedUpdateManyInput = {
    prid?: IntFieldUpdateOperationsInput | number
    prbody?: StringFieldUpdateOperationsInput | string
    pracc_number?: NullableStringFieldUpdateOperationsInput | string | null
    pracc_bank?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productcategoriesCreateInput = {
    pcatname: string
    pcatslug: string
    pcatpicture: string
    pcatdesc: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productcategoriesUncheckedCreateInput = {
    pcid?: number
    pcatname: string
    pcatslug: string
    pcatpicture: string
    pcatdesc: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productcategoriesUpdateInput = {
    pcatname?: StringFieldUpdateOperationsInput | string
    pcatslug?: StringFieldUpdateOperationsInput | string
    pcatpicture?: StringFieldUpdateOperationsInput | string
    pcatdesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productcategoriesUncheckedUpdateInput = {
    pcid?: IntFieldUpdateOperationsInput | number
    pcatname?: StringFieldUpdateOperationsInput | string
    pcatslug?: StringFieldUpdateOperationsInput | string
    pcatpicture?: StringFieldUpdateOperationsInput | string
    pcatdesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productcategoriesCreateManyInput = {
    pcid?: number
    pcatname: string
    pcatslug: string
    pcatpicture: string
    pcatdesc: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productcategoriesUpdateManyMutationInput = {
    pcatname?: StringFieldUpdateOperationsInput | string
    pcatslug?: StringFieldUpdateOperationsInput | string
    pcatpicture?: StringFieldUpdateOperationsInput | string
    pcatdesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productcategoriesUncheckedUpdateManyInput = {
    pcid?: IntFieldUpdateOperationsInput | number
    pcatname?: StringFieldUpdateOperationsInput | string
    pcatslug?: StringFieldUpdateOperationsInput | string
    pcatpicture?: StringFieldUpdateOperationsInput | string
    pcatdesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsCreateInput = {
    category: string
    catslug: string
    uuid?: string | null
    name: string
    nameslug: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    response_time?: string | null
    status?: boolean
    payment_account: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productsUncheckedCreateInput = {
    id?: number
    category: string
    catslug: string
    uuid?: string | null
    name: string
    nameslug: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    response_time?: string | null
    status?: boolean
    payment_account: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productsUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    catslug?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameslug?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    response_time?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    payment_account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    catslug?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameslug?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    response_time?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    payment_account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsCreateManyInput = {
    id?: number
    category: string
    catslug: string
    uuid?: string | null
    name: string
    nameslug: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    response_time?: string | null
    status?: boolean
    payment_account: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type productsUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    catslug?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameslug?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    response_time?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    payment_account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    catslug?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameslug?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    response_time?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    payment_account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestsCreateInput = {
    uuid?: string | null
    orderid: number
    orderref: string
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    productid: number
    productname: string
    prod_waittime?: number | null
    amount: number
    commission: number
    customerid: number
    customername: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    address?: string | null
    driverid?: number | null
    drivername?: string | null
    driverphone?: string | null
    driveremail?: string | null
    drivervehicleplateno?: string | null
    status?: string
    views: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type requestsUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    orderid: number
    orderref: string
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    productid: number
    productname: string
    prod_waittime?: number | null
    amount: number
    commission: number
    customerid: number
    customername: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    address?: string | null
    driverid?: number | null
    drivername?: string | null
    driverphone?: string | null
    driveremail?: string | null
    drivervehicleplateno?: string | null
    status?: string
    views: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type requestsUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    orderref?: StringFieldUpdateOperationsInput | string
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    customername?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    driverid?: NullableIntFieldUpdateOperationsInput | number | null
    drivername?: NullableStringFieldUpdateOperationsInput | string | null
    driverphone?: NullableStringFieldUpdateOperationsInput | string | null
    driveremail?: NullableStringFieldUpdateOperationsInput | string | null
    drivervehicleplateno?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    orderref?: StringFieldUpdateOperationsInput | string
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    customername?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    driverid?: NullableIntFieldUpdateOperationsInput | number | null
    drivername?: NullableStringFieldUpdateOperationsInput | string | null
    driverphone?: NullableStringFieldUpdateOperationsInput | string | null
    driveremail?: NullableStringFieldUpdateOperationsInput | string | null
    drivervehicleplateno?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestsCreateManyInput = {
    id?: number
    uuid?: string | null
    orderid: number
    orderref: string
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    productid: number
    productname: string
    prod_waittime?: number | null
    amount: number
    commission: number
    customerid: number
    customername: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    address?: string | null
    driverid?: number | null
    drivername?: string | null
    driverphone?: string | null
    driveremail?: string | null
    drivervehicleplateno?: string | null
    status?: string
    views: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type requestsUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    orderref?: StringFieldUpdateOperationsInput | string
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    customername?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    driverid?: NullableIntFieldUpdateOperationsInput | number | null
    drivername?: NullableStringFieldUpdateOperationsInput | string | null
    driverphone?: NullableStringFieldUpdateOperationsInput | string | null
    driveremail?: NullableStringFieldUpdateOperationsInput | string | null
    drivervehicleplateno?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    orderref?: StringFieldUpdateOperationsInput | string
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    customername?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    driverid?: NullableIntFieldUpdateOperationsInput | number | null
    drivername?: NullableStringFieldUpdateOperationsInput | string | null
    driverphone?: NullableStringFieldUpdateOperationsInput | string | null
    driveremail?: NullableStringFieldUpdateOperationsInput | string | null
    drivervehicleplateno?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopinfoCreateInput = {
    shopid: number
    shopname: string
    shopdescription: string
    driver_commission: number
    water_merchant_commission?: number
    shoplogo?: string | null
    shmetakey: string
    shmetadesc: string
    shopphone: string
    shopemailname: string
    shopemailaddress: string
    shoporderemail?: string | null
    shopaddress: string
    shopcity: string
    shopstate: string
    shopcountry: string
    latestonhome?: number
    offline?: number
    offlinemsg: string
    shopimage: string
    total_news: number
    slfacebook: string
    sltwitter: string
    slinstagram: string
    slyoutube: string
    postedby: string
    updatedAt?: Date | string
  }

  export type shopinfoUncheckedCreateInput = {
    shopid: number
    shopname: string
    shopdescription: string
    driver_commission: number
    water_merchant_commission?: number
    shoplogo?: string | null
    shmetakey: string
    shmetadesc: string
    shopphone: string
    shopemailname: string
    shopemailaddress: string
    shoporderemail?: string | null
    shopaddress: string
    shopcity: string
    shopstate: string
    shopcountry: string
    latestonhome?: number
    offline?: number
    offlinemsg: string
    shopimage: string
    total_news: number
    slfacebook: string
    sltwitter: string
    slinstagram: string
    slyoutube: string
    postedby: string
    updatedAt?: Date | string
  }

  export type shopinfoUpdateInput = {
    shopid?: IntFieldUpdateOperationsInput | number
    shopname?: StringFieldUpdateOperationsInput | string
    shopdescription?: StringFieldUpdateOperationsInput | string
    driver_commission?: FloatFieldUpdateOperationsInput | number
    water_merchant_commission?: FloatFieldUpdateOperationsInput | number
    shoplogo?: NullableStringFieldUpdateOperationsInput | string | null
    shmetakey?: StringFieldUpdateOperationsInput | string
    shmetadesc?: StringFieldUpdateOperationsInput | string
    shopphone?: StringFieldUpdateOperationsInput | string
    shopemailname?: StringFieldUpdateOperationsInput | string
    shopemailaddress?: StringFieldUpdateOperationsInput | string
    shoporderemail?: NullableStringFieldUpdateOperationsInput | string | null
    shopaddress?: StringFieldUpdateOperationsInput | string
    shopcity?: StringFieldUpdateOperationsInput | string
    shopstate?: StringFieldUpdateOperationsInput | string
    shopcountry?: StringFieldUpdateOperationsInput | string
    latestonhome?: IntFieldUpdateOperationsInput | number
    offline?: IntFieldUpdateOperationsInput | number
    offlinemsg?: StringFieldUpdateOperationsInput | string
    shopimage?: StringFieldUpdateOperationsInput | string
    total_news?: IntFieldUpdateOperationsInput | number
    slfacebook?: StringFieldUpdateOperationsInput | string
    sltwitter?: StringFieldUpdateOperationsInput | string
    slinstagram?: StringFieldUpdateOperationsInput | string
    slyoutube?: StringFieldUpdateOperationsInput | string
    postedby?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopinfoUncheckedUpdateInput = {
    shopid?: IntFieldUpdateOperationsInput | number
    shopname?: StringFieldUpdateOperationsInput | string
    shopdescription?: StringFieldUpdateOperationsInput | string
    driver_commission?: FloatFieldUpdateOperationsInput | number
    water_merchant_commission?: FloatFieldUpdateOperationsInput | number
    shoplogo?: NullableStringFieldUpdateOperationsInput | string | null
    shmetakey?: StringFieldUpdateOperationsInput | string
    shmetadesc?: StringFieldUpdateOperationsInput | string
    shopphone?: StringFieldUpdateOperationsInput | string
    shopemailname?: StringFieldUpdateOperationsInput | string
    shopemailaddress?: StringFieldUpdateOperationsInput | string
    shoporderemail?: NullableStringFieldUpdateOperationsInput | string | null
    shopaddress?: StringFieldUpdateOperationsInput | string
    shopcity?: StringFieldUpdateOperationsInput | string
    shopstate?: StringFieldUpdateOperationsInput | string
    shopcountry?: StringFieldUpdateOperationsInput | string
    latestonhome?: IntFieldUpdateOperationsInput | number
    offline?: IntFieldUpdateOperationsInput | number
    offlinemsg?: StringFieldUpdateOperationsInput | string
    shopimage?: StringFieldUpdateOperationsInput | string
    total_news?: IntFieldUpdateOperationsInput | number
    slfacebook?: StringFieldUpdateOperationsInput | string
    sltwitter?: StringFieldUpdateOperationsInput | string
    slinstagram?: StringFieldUpdateOperationsInput | string
    slyoutube?: StringFieldUpdateOperationsInput | string
    postedby?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopinfoCreateManyInput = {
    shopid: number
    shopname: string
    shopdescription: string
    driver_commission: number
    water_merchant_commission?: number
    shoplogo?: string | null
    shmetakey: string
    shmetadesc: string
    shopphone: string
    shopemailname: string
    shopemailaddress: string
    shoporderemail?: string | null
    shopaddress: string
    shopcity: string
    shopstate: string
    shopcountry: string
    latestonhome?: number
    offline?: number
    offlinemsg: string
    shopimage: string
    total_news: number
    slfacebook: string
    sltwitter: string
    slinstagram: string
    slyoutube: string
    postedby: string
    updatedAt?: Date | string
  }

  export type shopinfoUpdateManyMutationInput = {
    shopid?: IntFieldUpdateOperationsInput | number
    shopname?: StringFieldUpdateOperationsInput | string
    shopdescription?: StringFieldUpdateOperationsInput | string
    driver_commission?: FloatFieldUpdateOperationsInput | number
    water_merchant_commission?: FloatFieldUpdateOperationsInput | number
    shoplogo?: NullableStringFieldUpdateOperationsInput | string | null
    shmetakey?: StringFieldUpdateOperationsInput | string
    shmetadesc?: StringFieldUpdateOperationsInput | string
    shopphone?: StringFieldUpdateOperationsInput | string
    shopemailname?: StringFieldUpdateOperationsInput | string
    shopemailaddress?: StringFieldUpdateOperationsInput | string
    shoporderemail?: NullableStringFieldUpdateOperationsInput | string | null
    shopaddress?: StringFieldUpdateOperationsInput | string
    shopcity?: StringFieldUpdateOperationsInput | string
    shopstate?: StringFieldUpdateOperationsInput | string
    shopcountry?: StringFieldUpdateOperationsInput | string
    latestonhome?: IntFieldUpdateOperationsInput | number
    offline?: IntFieldUpdateOperationsInput | number
    offlinemsg?: StringFieldUpdateOperationsInput | string
    shopimage?: StringFieldUpdateOperationsInput | string
    total_news?: IntFieldUpdateOperationsInput | number
    slfacebook?: StringFieldUpdateOperationsInput | string
    sltwitter?: StringFieldUpdateOperationsInput | string
    slinstagram?: StringFieldUpdateOperationsInput | string
    slyoutube?: StringFieldUpdateOperationsInput | string
    postedby?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopinfoUncheckedUpdateManyInput = {
    shopid?: IntFieldUpdateOperationsInput | number
    shopname?: StringFieldUpdateOperationsInput | string
    shopdescription?: StringFieldUpdateOperationsInput | string
    driver_commission?: FloatFieldUpdateOperationsInput | number
    water_merchant_commission?: FloatFieldUpdateOperationsInput | number
    shoplogo?: NullableStringFieldUpdateOperationsInput | string | null
    shmetakey?: StringFieldUpdateOperationsInput | string
    shmetadesc?: StringFieldUpdateOperationsInput | string
    shopphone?: StringFieldUpdateOperationsInput | string
    shopemailname?: StringFieldUpdateOperationsInput | string
    shopemailaddress?: StringFieldUpdateOperationsInput | string
    shoporderemail?: NullableStringFieldUpdateOperationsInput | string | null
    shopaddress?: StringFieldUpdateOperationsInput | string
    shopcity?: StringFieldUpdateOperationsInput | string
    shopstate?: StringFieldUpdateOperationsInput | string
    shopcountry?: StringFieldUpdateOperationsInput | string
    latestonhome?: IntFieldUpdateOperationsInput | number
    offline?: IntFieldUpdateOperationsInput | number
    offlinemsg?: StringFieldUpdateOperationsInput | string
    shopimage?: StringFieldUpdateOperationsInput | string
    total_news?: IntFieldUpdateOperationsInput | number
    slfacebook?: StringFieldUpdateOperationsInput | string
    sltwitter?: StringFieldUpdateOperationsInput | string
    slinstagram?: StringFieldUpdateOperationsInput | string
    slyoutube?: StringFieldUpdateOperationsInput | string
    postedby?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sociallinksCreateInput = {
    slid: number
    slimage?: string | null
    sladdress: string
  }

  export type sociallinksUncheckedCreateInput = {
    slid: number
    slimage?: string | null
    sladdress: string
  }

  export type sociallinksUpdateInput = {
    slid?: IntFieldUpdateOperationsInput | number
    slimage?: NullableStringFieldUpdateOperationsInput | string | null
    sladdress?: StringFieldUpdateOperationsInput | string
  }

  export type sociallinksUncheckedUpdateInput = {
    slid?: IntFieldUpdateOperationsInput | number
    slimage?: NullableStringFieldUpdateOperationsInput | string | null
    sladdress?: StringFieldUpdateOperationsInput | string
  }

  export type sociallinksCreateManyInput = {
    slid: number
    slimage?: string | null
    sladdress: string
  }

  export type sociallinksUpdateManyMutationInput = {
    slid?: IntFieldUpdateOperationsInput | number
    slimage?: NullableStringFieldUpdateOperationsInput | string | null
    sladdress?: StringFieldUpdateOperationsInput | string
  }

  export type sociallinksUncheckedUpdateManyInput = {
    slid?: IntFieldUpdateOperationsInput | number
    slimage?: NullableStringFieldUpdateOperationsInput | string | null
    sladdress?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionCreateInput = {
    submagid: number
    sm_title?: string | null
    sm_initials: string
    sm_surname: string
    sm_business: string
    sm_address: string
    sm_postcode?: string | null
    sm_country: string
    sm_telephone: string
    sm_email: string
    sm_dateposted?: Date | string
    sm_amount: string
    sm_paid: string
    sm_datepaid: string
    sm_from: string
    sm_to: string
  }

  export type subscriptionUncheckedCreateInput = {
    submagid: number
    sm_title?: string | null
    sm_initials: string
    sm_surname: string
    sm_business: string
    sm_address: string
    sm_postcode?: string | null
    sm_country: string
    sm_telephone: string
    sm_email: string
    sm_dateposted?: Date | string
    sm_amount: string
    sm_paid: string
    sm_datepaid: string
    sm_from: string
    sm_to: string
  }

  export type subscriptionUpdateInput = {
    submagid?: IntFieldUpdateOperationsInput | number
    sm_title?: NullableStringFieldUpdateOperationsInput | string | null
    sm_initials?: StringFieldUpdateOperationsInput | string
    sm_surname?: StringFieldUpdateOperationsInput | string
    sm_business?: StringFieldUpdateOperationsInput | string
    sm_address?: StringFieldUpdateOperationsInput | string
    sm_postcode?: NullableStringFieldUpdateOperationsInput | string | null
    sm_country?: StringFieldUpdateOperationsInput | string
    sm_telephone?: StringFieldUpdateOperationsInput | string
    sm_email?: StringFieldUpdateOperationsInput | string
    sm_dateposted?: DateTimeFieldUpdateOperationsInput | Date | string
    sm_amount?: StringFieldUpdateOperationsInput | string
    sm_paid?: StringFieldUpdateOperationsInput | string
    sm_datepaid?: StringFieldUpdateOperationsInput | string
    sm_from?: StringFieldUpdateOperationsInput | string
    sm_to?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUncheckedUpdateInput = {
    submagid?: IntFieldUpdateOperationsInput | number
    sm_title?: NullableStringFieldUpdateOperationsInput | string | null
    sm_initials?: StringFieldUpdateOperationsInput | string
    sm_surname?: StringFieldUpdateOperationsInput | string
    sm_business?: StringFieldUpdateOperationsInput | string
    sm_address?: StringFieldUpdateOperationsInput | string
    sm_postcode?: NullableStringFieldUpdateOperationsInput | string | null
    sm_country?: StringFieldUpdateOperationsInput | string
    sm_telephone?: StringFieldUpdateOperationsInput | string
    sm_email?: StringFieldUpdateOperationsInput | string
    sm_dateposted?: DateTimeFieldUpdateOperationsInput | Date | string
    sm_amount?: StringFieldUpdateOperationsInput | string
    sm_paid?: StringFieldUpdateOperationsInput | string
    sm_datepaid?: StringFieldUpdateOperationsInput | string
    sm_from?: StringFieldUpdateOperationsInput | string
    sm_to?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionCreateManyInput = {
    submagid: number
    sm_title?: string | null
    sm_initials: string
    sm_surname: string
    sm_business: string
    sm_address: string
    sm_postcode?: string | null
    sm_country: string
    sm_telephone: string
    sm_email: string
    sm_dateposted?: Date | string
    sm_amount: string
    sm_paid: string
    sm_datepaid: string
    sm_from: string
    sm_to: string
  }

  export type subscriptionUpdateManyMutationInput = {
    submagid?: IntFieldUpdateOperationsInput | number
    sm_title?: NullableStringFieldUpdateOperationsInput | string | null
    sm_initials?: StringFieldUpdateOperationsInput | string
    sm_surname?: StringFieldUpdateOperationsInput | string
    sm_business?: StringFieldUpdateOperationsInput | string
    sm_address?: StringFieldUpdateOperationsInput | string
    sm_postcode?: NullableStringFieldUpdateOperationsInput | string | null
    sm_country?: StringFieldUpdateOperationsInput | string
    sm_telephone?: StringFieldUpdateOperationsInput | string
    sm_email?: StringFieldUpdateOperationsInput | string
    sm_dateposted?: DateTimeFieldUpdateOperationsInput | Date | string
    sm_amount?: StringFieldUpdateOperationsInput | string
    sm_paid?: StringFieldUpdateOperationsInput | string
    sm_datepaid?: StringFieldUpdateOperationsInput | string
    sm_from?: StringFieldUpdateOperationsInput | string
    sm_to?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUncheckedUpdateManyInput = {
    submagid?: IntFieldUpdateOperationsInput | number
    sm_title?: NullableStringFieldUpdateOperationsInput | string | null
    sm_initials?: StringFieldUpdateOperationsInput | string
    sm_surname?: StringFieldUpdateOperationsInput | string
    sm_business?: StringFieldUpdateOperationsInput | string
    sm_address?: StringFieldUpdateOperationsInput | string
    sm_postcode?: NullableStringFieldUpdateOperationsInput | string | null
    sm_country?: StringFieldUpdateOperationsInput | string
    sm_telephone?: StringFieldUpdateOperationsInput | string
    sm_email?: StringFieldUpdateOperationsInput | string
    sm_dateposted?: DateTimeFieldUpdateOperationsInput | Date | string
    sm_amount?: StringFieldUpdateOperationsInput | string
    sm_paid?: StringFieldUpdateOperationsInput | string
    sm_datepaid?: StringFieldUpdateOperationsInput | string
    sm_from?: StringFieldUpdateOperationsInput | string
    sm_to?: StringFieldUpdateOperationsInput | string
  }

  export type team_categoryCreateInput = {
    teamcategoryid: number
    teamcategory: string
    teamcat_slug: string
  }

  export type team_categoryUncheckedCreateInput = {
    teamcategoryid: number
    teamcategory: string
    teamcat_slug: string
  }

  export type team_categoryUpdateInput = {
    teamcategoryid?: IntFieldUpdateOperationsInput | number
    teamcategory?: StringFieldUpdateOperationsInput | string
    teamcat_slug?: StringFieldUpdateOperationsInput | string
  }

  export type team_categoryUncheckedUpdateInput = {
    teamcategoryid?: IntFieldUpdateOperationsInput | number
    teamcategory?: StringFieldUpdateOperationsInput | string
    teamcat_slug?: StringFieldUpdateOperationsInput | string
  }

  export type team_categoryCreateManyInput = {
    teamcategoryid: number
    teamcategory: string
    teamcat_slug: string
  }

  export type team_categoryUpdateManyMutationInput = {
    teamcategoryid?: IntFieldUpdateOperationsInput | number
    teamcategory?: StringFieldUpdateOperationsInput | string
    teamcat_slug?: StringFieldUpdateOperationsInput | string
  }

  export type team_categoryUncheckedUpdateManyInput = {
    teamcategoryid?: IntFieldUpdateOperationsInput | number
    teamcategory?: StringFieldUpdateOperationsInput | string
    teamcat_slug?: StringFieldUpdateOperationsInput | string
  }

  export type team_membersCreateInput = {
    tmcategory?: string | null
    tmember: string
    tmember_slug: string
    tmemberposition: string
    tmemberphoto: string
    tmemberprofile: string
    tmembersummary?: string | null
    tmemberdateadded: Date | string
    tmemberpostedby?: string | null
    tmemberrank?: number
    tmember_email?: string | null
    tmember_phone?: string | null
    tmember_facebook?: string | null
    tmember_twitter?: string | null
    tmember_linkedin?: string | null
    tmember_instagram?: string | null
  }

  export type team_membersUncheckedCreateInput = {
    tmemberid?: number
    tmcategory?: string | null
    tmember: string
    tmember_slug: string
    tmemberposition: string
    tmemberphoto: string
    tmemberprofile: string
    tmembersummary?: string | null
    tmemberdateadded: Date | string
    tmemberpostedby?: string | null
    tmemberrank?: number
    tmember_email?: string | null
    tmember_phone?: string | null
    tmember_facebook?: string | null
    tmember_twitter?: string | null
    tmember_linkedin?: string | null
    tmember_instagram?: string | null
  }

  export type team_membersUpdateInput = {
    tmcategory?: NullableStringFieldUpdateOperationsInput | string | null
    tmember?: StringFieldUpdateOperationsInput | string
    tmember_slug?: StringFieldUpdateOperationsInput | string
    tmemberposition?: StringFieldUpdateOperationsInput | string
    tmemberphoto?: StringFieldUpdateOperationsInput | string
    tmemberprofile?: StringFieldUpdateOperationsInput | string
    tmembersummary?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberdateadded?: DateTimeFieldUpdateOperationsInput | Date | string
    tmemberpostedby?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberrank?: IntFieldUpdateOperationsInput | number
    tmember_email?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_phone?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_twitter?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_membersUncheckedUpdateInput = {
    tmemberid?: IntFieldUpdateOperationsInput | number
    tmcategory?: NullableStringFieldUpdateOperationsInput | string | null
    tmember?: StringFieldUpdateOperationsInput | string
    tmember_slug?: StringFieldUpdateOperationsInput | string
    tmemberposition?: StringFieldUpdateOperationsInput | string
    tmemberphoto?: StringFieldUpdateOperationsInput | string
    tmemberprofile?: StringFieldUpdateOperationsInput | string
    tmembersummary?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberdateadded?: DateTimeFieldUpdateOperationsInput | Date | string
    tmemberpostedby?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberrank?: IntFieldUpdateOperationsInput | number
    tmember_email?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_phone?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_twitter?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_membersCreateManyInput = {
    tmemberid?: number
    tmcategory?: string | null
    tmember: string
    tmember_slug: string
    tmemberposition: string
    tmemberphoto: string
    tmemberprofile: string
    tmembersummary?: string | null
    tmemberdateadded: Date | string
    tmemberpostedby?: string | null
    tmemberrank?: number
    tmember_email?: string | null
    tmember_phone?: string | null
    tmember_facebook?: string | null
    tmember_twitter?: string | null
    tmember_linkedin?: string | null
    tmember_instagram?: string | null
  }

  export type team_membersUpdateManyMutationInput = {
    tmcategory?: NullableStringFieldUpdateOperationsInput | string | null
    tmember?: StringFieldUpdateOperationsInput | string
    tmember_slug?: StringFieldUpdateOperationsInput | string
    tmemberposition?: StringFieldUpdateOperationsInput | string
    tmemberphoto?: StringFieldUpdateOperationsInput | string
    tmemberprofile?: StringFieldUpdateOperationsInput | string
    tmembersummary?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberdateadded?: DateTimeFieldUpdateOperationsInput | Date | string
    tmemberpostedby?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberrank?: IntFieldUpdateOperationsInput | number
    tmember_email?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_phone?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_twitter?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type team_membersUncheckedUpdateManyInput = {
    tmemberid?: IntFieldUpdateOperationsInput | number
    tmcategory?: NullableStringFieldUpdateOperationsInput | string | null
    tmember?: StringFieldUpdateOperationsInput | string
    tmember_slug?: StringFieldUpdateOperationsInput | string
    tmemberposition?: StringFieldUpdateOperationsInput | string
    tmemberphoto?: StringFieldUpdateOperationsInput | string
    tmemberprofile?: StringFieldUpdateOperationsInput | string
    tmembersummary?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberdateadded?: DateTimeFieldUpdateOperationsInput | Date | string
    tmemberpostedby?: NullableStringFieldUpdateOperationsInput | string | null
    tmemberrank?: IntFieldUpdateOperationsInput | number
    tmember_email?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_phone?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_twitter?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    tmember_instagram?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialsCreateInput = {
    tcustomer: string
    trole: string
    tphoto: string
    tmessage: string
    tstars?: number
    tdate: Date | string
    tstatus?: number
  }

  export type testimonialsUncheckedCreateInput = {
    tid?: number
    tcustomer: string
    trole: string
    tphoto: string
    tmessage: string
    tstars?: number
    tdate: Date | string
    tstatus?: number
  }

  export type testimonialsUpdateInput = {
    tcustomer?: StringFieldUpdateOperationsInput | string
    trole?: StringFieldUpdateOperationsInput | string
    tphoto?: StringFieldUpdateOperationsInput | string
    tmessage?: StringFieldUpdateOperationsInput | string
    tstars?: IntFieldUpdateOperationsInput | number
    tdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tstatus?: IntFieldUpdateOperationsInput | number
  }

  export type testimonialsUncheckedUpdateInput = {
    tid?: IntFieldUpdateOperationsInput | number
    tcustomer?: StringFieldUpdateOperationsInput | string
    trole?: StringFieldUpdateOperationsInput | string
    tphoto?: StringFieldUpdateOperationsInput | string
    tmessage?: StringFieldUpdateOperationsInput | string
    tstars?: IntFieldUpdateOperationsInput | number
    tdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tstatus?: IntFieldUpdateOperationsInput | number
  }

  export type testimonialsCreateManyInput = {
    tid?: number
    tcustomer: string
    trole: string
    tphoto: string
    tmessage: string
    tstars?: number
    tdate: Date | string
    tstatus?: number
  }

  export type testimonialsUpdateManyMutationInput = {
    tcustomer?: StringFieldUpdateOperationsInput | string
    trole?: StringFieldUpdateOperationsInput | string
    tphoto?: StringFieldUpdateOperationsInput | string
    tmessage?: StringFieldUpdateOperationsInput | string
    tstars?: IntFieldUpdateOperationsInput | number
    tdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tstatus?: IntFieldUpdateOperationsInput | number
  }

  export type testimonialsUncheckedUpdateManyInput = {
    tid?: IntFieldUpdateOperationsInput | number
    tcustomer?: StringFieldUpdateOperationsInput | string
    trole?: StringFieldUpdateOperationsInput | string
    tphoto?: StringFieldUpdateOperationsInput | string
    tmessage?: StringFieldUpdateOperationsInput | string
    tstars?: IntFieldUpdateOperationsInput | number
    tdate?: DateTimeFieldUpdateOperationsInput | Date | string
    tstatus?: IntFieldUpdateOperationsInput | number
  }

  export type transactionsCreateInput = {
    uuid?: string | null
    orderref: string
    productid: number
    productname: string
    prod_waittime?: number | null
    product_subscription?: string
    qty?: number
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    amount: number
    commission: number
    driverfee: number
    driverid?: string | null
    drivername: string
    driverphone: string
    driveremail: string
    drivervehicleplateno: string
    driverphoto: string
    fleetid?: string | null
    driverlatitude: Decimal | DecimalJsLike | number | string
    driverlongitude: Decimal | DecimalJsLike | number | string
    driveraccept?: string | null
    customerid?: string | null
    customername: string
    customeremail: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    status?: string
    paymentstatus?: string
    paymentmode?: string
    paymenttime?: string | null
    driverdeliverystatus: string
    driverdeliverystatustime?: string | null
    driverdeliverytime?: number
    customerdeliverystatus?: string
    customerdeliverystatustime?: string | null
    customerwaittime?: number
    orderprocessed: boolean
    commission_paid?: number
    driverrating?: number | null
    driverfeedback?: string | null
    notes: string
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    orderref: string
    productid: number
    productname: string
    prod_waittime?: number | null
    product_subscription?: string
    qty?: number
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    amount: number
    commission: number
    driverfee: number
    driverid?: string | null
    drivername: string
    driverphone: string
    driveremail: string
    drivervehicleplateno: string
    driverphoto: string
    fleetid?: string | null
    driverlatitude: Decimal | DecimalJsLike | number | string
    driverlongitude: Decimal | DecimalJsLike | number | string
    driveraccept?: string | null
    customerid?: string | null
    customername: string
    customeremail: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    status?: string
    paymentstatus?: string
    paymentmode?: string
    paymenttime?: string | null
    driverdeliverystatus: string
    driverdeliverystatustime?: string | null
    driverdeliverytime?: number
    customerdeliverystatus?: string
    customerdeliverystatustime?: string | null
    customerwaittime?: number
    orderprocessed: boolean
    commission_paid?: number
    driverrating?: number | null
    driverfeedback?: string | null
    notes: string
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderref?: StringFieldUpdateOperationsInput | string
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    product_subscription?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    driverfee?: FloatFieldUpdateOperationsInput | number
    driverid?: NullableStringFieldUpdateOperationsInput | string | null
    drivername?: StringFieldUpdateOperationsInput | string
    driverphone?: StringFieldUpdateOperationsInput | string
    driveremail?: StringFieldUpdateOperationsInput | string
    drivervehicleplateno?: StringFieldUpdateOperationsInput | string
    driverphoto?: StringFieldUpdateOperationsInput | string
    fleetid?: NullableStringFieldUpdateOperationsInput | string | null
    driverlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driveraccept?: NullableStringFieldUpdateOperationsInput | string | null
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    customeremail?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentstatus?: StringFieldUpdateOperationsInput | string
    paymentmode?: StringFieldUpdateOperationsInput | string
    paymenttime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverystatus?: StringFieldUpdateOperationsInput | string
    driverdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverytime?: IntFieldUpdateOperationsInput | number
    customerdeliverystatus?: StringFieldUpdateOperationsInput | string
    customerdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    customerwaittime?: IntFieldUpdateOperationsInput | number
    orderprocessed?: BoolFieldUpdateOperationsInput | boolean
    commission_paid?: IntFieldUpdateOperationsInput | number
    driverrating?: NullableIntFieldUpdateOperationsInput | number | null
    driverfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderref?: StringFieldUpdateOperationsInput | string
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    product_subscription?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    driverfee?: FloatFieldUpdateOperationsInput | number
    driverid?: NullableStringFieldUpdateOperationsInput | string | null
    drivername?: StringFieldUpdateOperationsInput | string
    driverphone?: StringFieldUpdateOperationsInput | string
    driveremail?: StringFieldUpdateOperationsInput | string
    drivervehicleplateno?: StringFieldUpdateOperationsInput | string
    driverphoto?: StringFieldUpdateOperationsInput | string
    fleetid?: NullableStringFieldUpdateOperationsInput | string | null
    driverlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driveraccept?: NullableStringFieldUpdateOperationsInput | string | null
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    customeremail?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentstatus?: StringFieldUpdateOperationsInput | string
    paymentmode?: StringFieldUpdateOperationsInput | string
    paymenttime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverystatus?: StringFieldUpdateOperationsInput | string
    driverdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverytime?: IntFieldUpdateOperationsInput | number
    customerdeliverystatus?: StringFieldUpdateOperationsInput | string
    customerdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    customerwaittime?: IntFieldUpdateOperationsInput | number
    orderprocessed?: BoolFieldUpdateOperationsInput | boolean
    commission_paid?: IntFieldUpdateOperationsInput | number
    driverrating?: NullableIntFieldUpdateOperationsInput | number | null
    driverfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateManyInput = {
    id?: number
    uuid?: string | null
    orderref: string
    productid: number
    productname: string
    prod_waittime?: number | null
    product_subscription?: string
    qty?: number
    orderdetails: string
    req_type: string
    task?: string | null
    howmany?: number | null
    amount: number
    commission: number
    driverfee: number
    driverid?: string | null
    drivername: string
    driverphone: string
    driveremail: string
    drivervehicleplateno: string
    driverphoto: string
    fleetid?: string | null
    driverlatitude: Decimal | DecimalJsLike | number | string
    driverlongitude: Decimal | DecimalJsLike | number | string
    driveraccept?: string | null
    customerid?: string | null
    customername: string
    customeremail: string
    customerphone: string
    customeraddress: string
    customerarea: string
    customerareagroup?: string | null
    third_party_delivery: string
    third_party_name?: string | null
    third_party_phone?: string | null
    third_party_areagroup?: string | null
    third_party_address?: string | null
    customerlatitude: Decimal | DecimalJsLike | number | string
    customerlongitude: Decimal | DecimalJsLike | number | string
    status?: string
    paymentstatus?: string
    paymentmode?: string
    paymenttime?: string | null
    driverdeliverystatus: string
    driverdeliverystatustime?: string | null
    driverdeliverytime?: number
    customerdeliverystatus?: string
    customerdeliverystatustime?: string | null
    customerwaittime?: number
    orderprocessed: boolean
    commission_paid?: number
    driverrating?: number | null
    driverfeedback?: string | null
    notes: string
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderref?: StringFieldUpdateOperationsInput | string
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    product_subscription?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    driverfee?: FloatFieldUpdateOperationsInput | number
    driverid?: NullableStringFieldUpdateOperationsInput | string | null
    drivername?: StringFieldUpdateOperationsInput | string
    driverphone?: StringFieldUpdateOperationsInput | string
    driveremail?: StringFieldUpdateOperationsInput | string
    drivervehicleplateno?: StringFieldUpdateOperationsInput | string
    driverphoto?: StringFieldUpdateOperationsInput | string
    fleetid?: NullableStringFieldUpdateOperationsInput | string | null
    driverlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driveraccept?: NullableStringFieldUpdateOperationsInput | string | null
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    customeremail?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentstatus?: StringFieldUpdateOperationsInput | string
    paymentmode?: StringFieldUpdateOperationsInput | string
    paymenttime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverystatus?: StringFieldUpdateOperationsInput | string
    driverdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverytime?: IntFieldUpdateOperationsInput | number
    customerdeliverystatus?: StringFieldUpdateOperationsInput | string
    customerdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    customerwaittime?: IntFieldUpdateOperationsInput | number
    orderprocessed?: BoolFieldUpdateOperationsInput | boolean
    commission_paid?: IntFieldUpdateOperationsInput | number
    driverrating?: NullableIntFieldUpdateOperationsInput | number | null
    driverfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderref?: StringFieldUpdateOperationsInput | string
    productid?: IntFieldUpdateOperationsInput | number
    productname?: StringFieldUpdateOperationsInput | string
    prod_waittime?: NullableIntFieldUpdateOperationsInput | number | null
    product_subscription?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    orderdetails?: StringFieldUpdateOperationsInput | string
    req_type?: StringFieldUpdateOperationsInput | string
    task?: NullableStringFieldUpdateOperationsInput | string | null
    howmany?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    driverfee?: FloatFieldUpdateOperationsInput | number
    driverid?: NullableStringFieldUpdateOperationsInput | string | null
    drivername?: StringFieldUpdateOperationsInput | string
    driverphone?: StringFieldUpdateOperationsInput | string
    driveremail?: StringFieldUpdateOperationsInput | string
    drivervehicleplateno?: StringFieldUpdateOperationsInput | string
    driverphoto?: StringFieldUpdateOperationsInput | string
    fleetid?: NullableStringFieldUpdateOperationsInput | string | null
    driverlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driveraccept?: NullableStringFieldUpdateOperationsInput | string | null
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    customeremail?: StringFieldUpdateOperationsInput | string
    customerphone?: StringFieldUpdateOperationsInput | string
    customeraddress?: StringFieldUpdateOperationsInput | string
    customerarea?: StringFieldUpdateOperationsInput | string
    customerareagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_delivery?: StringFieldUpdateOperationsInput | string
    third_party_name?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_phone?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    third_party_address?: NullableStringFieldUpdateOperationsInput | string | null
    customerlatitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerlongitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    paymentstatus?: StringFieldUpdateOperationsInput | string
    paymentmode?: StringFieldUpdateOperationsInput | string
    paymenttime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverystatus?: StringFieldUpdateOperationsInput | string
    driverdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    driverdeliverytime?: IntFieldUpdateOperationsInput | number
    customerdeliverystatus?: StringFieldUpdateOperationsInput | string
    customerdeliverystatustime?: NullableStringFieldUpdateOperationsInput | string | null
    customerwaittime?: IntFieldUpdateOperationsInput | number
    orderprocessed?: BoolFieldUpdateOperationsInput | boolean
    commission_paid?: IntFieldUpdateOperationsInput | number
    driverrating?: NullableIntFieldUpdateOperationsInput | number | null
    driverfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usermessagesCreateInput = {
    umsg_user: string
    umsg_cat: string
    umsg_title: string
    umsg_body: string
    umsg_read?: number
    umsg_time: Date | string
    umsg_sender: string
  }

  export type usermessagesUncheckedCreateInput = {
    umsgid?: number
    umsg_user: string
    umsg_cat: string
    umsg_title: string
    umsg_body: string
    umsg_read?: number
    umsg_time: Date | string
    umsg_sender: string
  }

  export type usermessagesUpdateInput = {
    umsg_user?: StringFieldUpdateOperationsInput | string
    umsg_cat?: StringFieldUpdateOperationsInput | string
    umsg_title?: StringFieldUpdateOperationsInput | string
    umsg_body?: StringFieldUpdateOperationsInput | string
    umsg_read?: IntFieldUpdateOperationsInput | number
    umsg_time?: DateTimeFieldUpdateOperationsInput | Date | string
    umsg_sender?: StringFieldUpdateOperationsInput | string
  }

  export type usermessagesUncheckedUpdateInput = {
    umsgid?: IntFieldUpdateOperationsInput | number
    umsg_user?: StringFieldUpdateOperationsInput | string
    umsg_cat?: StringFieldUpdateOperationsInput | string
    umsg_title?: StringFieldUpdateOperationsInput | string
    umsg_body?: StringFieldUpdateOperationsInput | string
    umsg_read?: IntFieldUpdateOperationsInput | number
    umsg_time?: DateTimeFieldUpdateOperationsInput | Date | string
    umsg_sender?: StringFieldUpdateOperationsInput | string
  }

  export type usermessagesCreateManyInput = {
    umsgid?: number
    umsg_user: string
    umsg_cat: string
    umsg_title: string
    umsg_body: string
    umsg_read?: number
    umsg_time: Date | string
    umsg_sender: string
  }

  export type usermessagesUpdateManyMutationInput = {
    umsg_user?: StringFieldUpdateOperationsInput | string
    umsg_cat?: StringFieldUpdateOperationsInput | string
    umsg_title?: StringFieldUpdateOperationsInput | string
    umsg_body?: StringFieldUpdateOperationsInput | string
    umsg_read?: IntFieldUpdateOperationsInput | number
    umsg_time?: DateTimeFieldUpdateOperationsInput | Date | string
    umsg_sender?: StringFieldUpdateOperationsInput | string
  }

  export type usermessagesUncheckedUpdateManyInput = {
    umsgid?: IntFieldUpdateOperationsInput | number
    umsg_user?: StringFieldUpdateOperationsInput | string
    umsg_cat?: StringFieldUpdateOperationsInput | string
    umsg_title?: StringFieldUpdateOperationsInput | string
    umsg_body?: StringFieldUpdateOperationsInput | string
    umsg_read?: IntFieldUpdateOperationsInput | number
    umsg_time?: DateTimeFieldUpdateOperationsInput | Date | string
    umsg_sender?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsCreateNestedManyWithoutFirst_reading_userInput
    afternoon_meter_readings?: MeterReadingsCreateNestedManyWithoutAfternoon_reading_userInput
    last_meter_readings?: MeterReadingsCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutFirst_reading_userInput
    afternoon_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutAfternoon_reading_userInput
    last_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUpdateManyWithoutFirst_reading_userNestedInput
    afternoon_meter_readings?: MeterReadingsUpdateManyWithoutAfternoon_reading_userNestedInput
    last_meter_readings?: MeterReadingsUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userNestedInput
    afternoon_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userNestedInput
    last_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type videocatCreateInput = {
    vidcat: string
  }

  export type videocatUncheckedCreateInput = {
    vidcatid?: number
    vidcat: string
  }

  export type videocatUpdateInput = {
    vidcat?: StringFieldUpdateOperationsInput | string
  }

  export type videocatUncheckedUpdateInput = {
    vidcatid?: IntFieldUpdateOperationsInput | number
    vidcat?: StringFieldUpdateOperationsInput | string
  }

  export type videocatCreateManyInput = {
    vidcatid?: number
    vidcat: string
  }

  export type videocatUpdateManyMutationInput = {
    vidcat?: StringFieldUpdateOperationsInput | string
  }

  export type videocatUncheckedUpdateManyInput = {
    vidcatid?: IntFieldUpdateOperationsInput | number
    vidcat?: StringFieldUpdateOperationsInput | string
  }

  export type videosCreateInput = {
    vcatid: number
    vidcategory: string
    vidtitle: string
    viddesc: string
    vidurl: string
    vidembed: string
    vidpostedby: string
    vidtimeposted?: Date | string
    vidhits: number
    vidextra: string
  }

  export type videosUncheckedCreateInput = {
    videntryid?: number
    vcatid: number
    vidcategory: string
    vidtitle: string
    viddesc: string
    vidurl: string
    vidembed: string
    vidpostedby: string
    vidtimeposted?: Date | string
    vidhits: number
    vidextra: string
  }

  export type videosUpdateInput = {
    vcatid?: IntFieldUpdateOperationsInput | number
    vidcategory?: StringFieldUpdateOperationsInput | string
    vidtitle?: StringFieldUpdateOperationsInput | string
    viddesc?: StringFieldUpdateOperationsInput | string
    vidurl?: StringFieldUpdateOperationsInput | string
    vidembed?: StringFieldUpdateOperationsInput | string
    vidpostedby?: StringFieldUpdateOperationsInput | string
    vidtimeposted?: DateTimeFieldUpdateOperationsInput | Date | string
    vidhits?: IntFieldUpdateOperationsInput | number
    vidextra?: StringFieldUpdateOperationsInput | string
  }

  export type videosUncheckedUpdateInput = {
    videntryid?: IntFieldUpdateOperationsInput | number
    vcatid?: IntFieldUpdateOperationsInput | number
    vidcategory?: StringFieldUpdateOperationsInput | string
    vidtitle?: StringFieldUpdateOperationsInput | string
    viddesc?: StringFieldUpdateOperationsInput | string
    vidurl?: StringFieldUpdateOperationsInput | string
    vidembed?: StringFieldUpdateOperationsInput | string
    vidpostedby?: StringFieldUpdateOperationsInput | string
    vidtimeposted?: DateTimeFieldUpdateOperationsInput | Date | string
    vidhits?: IntFieldUpdateOperationsInput | number
    vidextra?: StringFieldUpdateOperationsInput | string
  }

  export type videosCreateManyInput = {
    videntryid?: number
    vcatid: number
    vidcategory: string
    vidtitle: string
    viddesc: string
    vidurl: string
    vidembed: string
    vidpostedby: string
    vidtimeposted?: Date | string
    vidhits: number
    vidextra: string
  }

  export type videosUpdateManyMutationInput = {
    vcatid?: IntFieldUpdateOperationsInput | number
    vidcategory?: StringFieldUpdateOperationsInput | string
    vidtitle?: StringFieldUpdateOperationsInput | string
    viddesc?: StringFieldUpdateOperationsInput | string
    vidurl?: StringFieldUpdateOperationsInput | string
    vidembed?: StringFieldUpdateOperationsInput | string
    vidpostedby?: StringFieldUpdateOperationsInput | string
    vidtimeposted?: DateTimeFieldUpdateOperationsInput | Date | string
    vidhits?: IntFieldUpdateOperationsInput | number
    vidextra?: StringFieldUpdateOperationsInput | string
  }

  export type videosUncheckedUpdateManyInput = {
    videntryid?: IntFieldUpdateOperationsInput | number
    vcatid?: IntFieldUpdateOperationsInput | number
    vidcategory?: StringFieldUpdateOperationsInput | string
    vidtitle?: StringFieldUpdateOperationsInput | string
    viddesc?: StringFieldUpdateOperationsInput | string
    vidurl?: StringFieldUpdateOperationsInput | string
    vidembed?: StringFieldUpdateOperationsInput | string
    vidpostedby?: StringFieldUpdateOperationsInput | string
    vidtimeposted?: DateTimeFieldUpdateOperationsInput | Date | string
    vidhits?: IntFieldUpdateOperationsInput | number
    vidextra?: StringFieldUpdateOperationsInput | string
  }

  export type meter_domestic_entriesCreateInput = {
    md_unique_id: string
    md_userid?: string | null
    md_area?: string | null
    md_consumption_rate: string
    md_volume_received: number
    md_valve_state: string
    createdAt: Date | string
  }

  export type meter_domestic_entriesUncheckedCreateInput = {
    mdid?: number
    md_unique_id: string
    md_userid?: string | null
    md_area?: string | null
    md_consumption_rate: string
    md_volume_received: number
    md_valve_state: string
    createdAt: Date | string
  }

  export type meter_domestic_entriesUpdateInput = {
    md_unique_id?: StringFieldUpdateOperationsInput | string
    md_userid?: NullableStringFieldUpdateOperationsInput | string | null
    md_area?: NullableStringFieldUpdateOperationsInput | string | null
    md_consumption_rate?: StringFieldUpdateOperationsInput | string
    md_volume_received?: IntFieldUpdateOperationsInput | number
    md_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_domestic_entriesUncheckedUpdateInput = {
    mdid?: IntFieldUpdateOperationsInput | number
    md_unique_id?: StringFieldUpdateOperationsInput | string
    md_userid?: NullableStringFieldUpdateOperationsInput | string | null
    md_area?: NullableStringFieldUpdateOperationsInput | string | null
    md_consumption_rate?: StringFieldUpdateOperationsInput | string
    md_volume_received?: IntFieldUpdateOperationsInput | number
    md_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_domestic_entriesCreateManyInput = {
    mdid?: number
    md_unique_id: string
    md_userid?: string | null
    md_area?: string | null
    md_consumption_rate: string
    md_volume_received: number
    md_valve_state: string
    createdAt: Date | string
  }

  export type meter_domestic_entriesUpdateManyMutationInput = {
    md_unique_id?: StringFieldUpdateOperationsInput | string
    md_userid?: NullableStringFieldUpdateOperationsInput | string | null
    md_area?: NullableStringFieldUpdateOperationsInput | string | null
    md_consumption_rate?: StringFieldUpdateOperationsInput | string
    md_volume_received?: IntFieldUpdateOperationsInput | number
    md_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_domestic_entriesUncheckedUpdateManyInput = {
    mdid?: IntFieldUpdateOperationsInput | number
    md_unique_id?: StringFieldUpdateOperationsInput | string
    md_userid?: NullableStringFieldUpdateOperationsInput | string | null
    md_area?: NullableStringFieldUpdateOperationsInput | string | null
    md_consumption_rate?: StringFieldUpdateOperationsInput | string
    md_volume_received?: IntFieldUpdateOperationsInput | number
    md_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_supply_entriesCreateInput = {
    ms_unique_id: string
    ms_userid?: string | null
    ms_supply_rate: string
    ms_volume_supplied: number
    ms_temperature_c: string
    ms_temperature_f: string
    ms_turbidity_level: string
    ms_ph_level: string
    ms_valve_state: string
    createdAt: Date | string
  }

  export type meter_supply_entriesUncheckedCreateInput = {
    msid?: number
    ms_unique_id: string
    ms_userid?: string | null
    ms_supply_rate: string
    ms_volume_supplied: number
    ms_temperature_c: string
    ms_temperature_f: string
    ms_turbidity_level: string
    ms_ph_level: string
    ms_valve_state: string
    createdAt: Date | string
  }

  export type meter_supply_entriesUpdateInput = {
    ms_unique_id?: StringFieldUpdateOperationsInput | string
    ms_userid?: NullableStringFieldUpdateOperationsInput | string | null
    ms_supply_rate?: StringFieldUpdateOperationsInput | string
    ms_volume_supplied?: IntFieldUpdateOperationsInput | number
    ms_temperature_c?: StringFieldUpdateOperationsInput | string
    ms_temperature_f?: StringFieldUpdateOperationsInput | string
    ms_turbidity_level?: StringFieldUpdateOperationsInput | string
    ms_ph_level?: StringFieldUpdateOperationsInput | string
    ms_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_supply_entriesUncheckedUpdateInput = {
    msid?: IntFieldUpdateOperationsInput | number
    ms_unique_id?: StringFieldUpdateOperationsInput | string
    ms_userid?: NullableStringFieldUpdateOperationsInput | string | null
    ms_supply_rate?: StringFieldUpdateOperationsInput | string
    ms_volume_supplied?: IntFieldUpdateOperationsInput | number
    ms_temperature_c?: StringFieldUpdateOperationsInput | string
    ms_temperature_f?: StringFieldUpdateOperationsInput | string
    ms_turbidity_level?: StringFieldUpdateOperationsInput | string
    ms_ph_level?: StringFieldUpdateOperationsInput | string
    ms_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_supply_entriesCreateManyInput = {
    msid?: number
    ms_unique_id: string
    ms_userid?: string | null
    ms_supply_rate: string
    ms_volume_supplied: number
    ms_temperature_c: string
    ms_temperature_f: string
    ms_turbidity_level: string
    ms_ph_level: string
    ms_valve_state: string
    createdAt: Date | string
  }

  export type meter_supply_entriesUpdateManyMutationInput = {
    ms_unique_id?: StringFieldUpdateOperationsInput | string
    ms_userid?: NullableStringFieldUpdateOperationsInput | string | null
    ms_supply_rate?: StringFieldUpdateOperationsInput | string
    ms_volume_supplied?: IntFieldUpdateOperationsInput | number
    ms_temperature_c?: StringFieldUpdateOperationsInput | string
    ms_temperature_f?: StringFieldUpdateOperationsInput | string
    ms_turbidity_level?: StringFieldUpdateOperationsInput | string
    ms_ph_level?: StringFieldUpdateOperationsInput | string
    ms_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_supply_entriesUncheckedUpdateManyInput = {
    msid?: IntFieldUpdateOperationsInput | number
    ms_unique_id?: StringFieldUpdateOperationsInput | string
    ms_userid?: NullableStringFieldUpdateOperationsInput | string | null
    ms_supply_rate?: StringFieldUpdateOperationsInput | string
    ms_volume_supplied?: IntFieldUpdateOperationsInput | number
    ms_temperature_c?: StringFieldUpdateOperationsInput | string
    ms_temperature_f?: StringFieldUpdateOperationsInput | string
    ms_turbidity_level?: StringFieldUpdateOperationsInput | string
    ms_ph_level?: StringFieldUpdateOperationsInput | string
    ms_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_tanker_entriesCreateInput = {
    mt_unique_id: string
    mt_tankerid?: string | null
    mt_delivery_rate: string
    mt_volume_delivered: number
    mt_valve_state: string
    createdAt: Date | string
  }

  export type meter_tanker_entriesUncheckedCreateInput = {
    mtid?: number
    mt_unique_id: string
    mt_tankerid?: string | null
    mt_delivery_rate: string
    mt_volume_delivered: number
    mt_valve_state: string
    createdAt: Date | string
  }

  export type meter_tanker_entriesUpdateInput = {
    mt_unique_id?: StringFieldUpdateOperationsInput | string
    mt_tankerid?: NullableStringFieldUpdateOperationsInput | string | null
    mt_delivery_rate?: StringFieldUpdateOperationsInput | string
    mt_volume_delivered?: IntFieldUpdateOperationsInput | number
    mt_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_tanker_entriesUncheckedUpdateInput = {
    mtid?: IntFieldUpdateOperationsInput | number
    mt_unique_id?: StringFieldUpdateOperationsInput | string
    mt_tankerid?: NullableStringFieldUpdateOperationsInput | string | null
    mt_delivery_rate?: StringFieldUpdateOperationsInput | string
    mt_volume_delivered?: IntFieldUpdateOperationsInput | number
    mt_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_tanker_entriesCreateManyInput = {
    mtid?: number
    mt_unique_id: string
    mt_tankerid?: string | null
    mt_delivery_rate: string
    mt_volume_delivered: number
    mt_valve_state: string
    createdAt: Date | string
  }

  export type meter_tanker_entriesUpdateManyMutationInput = {
    mt_unique_id?: StringFieldUpdateOperationsInput | string
    mt_tankerid?: NullableStringFieldUpdateOperationsInput | string | null
    mt_delivery_rate?: StringFieldUpdateOperationsInput | string
    mt_volume_delivered?: IntFieldUpdateOperationsInput | number
    mt_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_tanker_entriesUncheckedUpdateManyInput = {
    mtid?: IntFieldUpdateOperationsInput | number
    mt_unique_id?: StringFieldUpdateOperationsInput | string
    mt_tankerid?: NullableStringFieldUpdateOperationsInput | string | null
    mt_delivery_rate?: StringFieldUpdateOperationsInput | string
    mt_volume_delivered?: IntFieldUpdateOperationsInput | number
    mt_valve_state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersCreateInput = {
    m_account_number?: string | null
    m_unique_id: string
    m_for?: string
    m_assigned?: string
    m_assigned_to?: string | null
    m_assigned_name?: string | null
    m_assigned_phone?: string | null
    m_assigned_address?: string | null
    m_area?: string | null
    m_status?: string
    m_valve_state?: string
    m_water_unit_price?: number
    createdAt: Date | string
    updatedAt?: Date | string
    meter_readings?: MeterReadingsCreateNestedManyWithoutMeterInput
  }

  export type metersUncheckedCreateInput = {
    meterid?: number
    m_account_number?: string | null
    m_unique_id: string
    m_for?: string
    m_assigned?: string
    m_assigned_to?: string | null
    m_assigned_name?: string | null
    m_assigned_phone?: string | null
    m_assigned_address?: string | null
    m_area?: string | null
    m_status?: string
    m_valve_state?: string
    m_water_unit_price?: number
    createdAt: Date | string
    updatedAt?: Date | string
    meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutMeterInput
  }

  export type metersUpdateInput = {
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: MeterReadingsUpdateManyWithoutMeterNestedInput
  }

  export type metersUncheckedUpdateInput = {
    meterid?: IntFieldUpdateOperationsInput | number
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: MeterReadingsUncheckedUpdateManyWithoutMeterNestedInput
  }

  export type metersCreateManyInput = {
    meterid?: number
    m_account_number?: string | null
    m_unique_id: string
    m_for?: string
    m_assigned?: string
    m_assigned_to?: string | null
    m_assigned_name?: string | null
    m_assigned_phone?: string | null
    m_assigned_address?: string | null
    m_area?: string | null
    m_status?: string
    m_valve_state?: string
    m_water_unit_price?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type metersUpdateManyMutationInput = {
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersUncheckedUpdateManyInput = {
    meterid?: IntFieldUpdateOperationsInput | number
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesCreateInput = {
    cname: string
    cphone: string
    cemail: string
    csubject: string
    cmessage: string
    cstatus?: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contact_messagesUncheckedCreateInput = {
    cid?: number
    cname: string
    cphone: string
    cemail: string
    csubject: string
    cmessage: string
    cstatus?: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contact_messagesUpdateInput = {
    cname?: StringFieldUpdateOperationsInput | string
    cphone?: StringFieldUpdateOperationsInput | string
    cemail?: StringFieldUpdateOperationsInput | string
    csubject?: StringFieldUpdateOperationsInput | string
    cmessage?: StringFieldUpdateOperationsInput | string
    cstatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesUncheckedUpdateInput = {
    cid?: IntFieldUpdateOperationsInput | number
    cname?: StringFieldUpdateOperationsInput | string
    cphone?: StringFieldUpdateOperationsInput | string
    cemail?: StringFieldUpdateOperationsInput | string
    csubject?: StringFieldUpdateOperationsInput | string
    cmessage?: StringFieldUpdateOperationsInput | string
    cstatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesCreateManyInput = {
    cid?: number
    cname: string
    cphone: string
    cemail: string
    csubject: string
    cmessage: string
    cstatus?: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type contact_messagesUpdateManyMutationInput = {
    cname?: StringFieldUpdateOperationsInput | string
    cphone?: StringFieldUpdateOperationsInput | string
    cemail?: StringFieldUpdateOperationsInput | string
    csubject?: StringFieldUpdateOperationsInput | string
    cmessage?: StringFieldUpdateOperationsInput | string
    cstatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesUncheckedUpdateManyInput = {
    cid?: IntFieldUpdateOperationsInput | number
    cname?: StringFieldUpdateOperationsInput | string
    cphone?: StringFieldUpdateOperationsInput | string
    cemail?: StringFieldUpdateOperationsInput | string
    csubject?: StringFieldUpdateOperationsInput | string
    cmessage?: StringFieldUpdateOperationsInput | string
    cstatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_numbersCreateInput = {
    meter_type: string
    meter_uuid: string
    meter_uuid_used?: string
    meter_assigned?: string
    createdAt: Date | string
  }

  export type meter_numbersUncheckedCreateInput = {
    meter_uuid_id?: number
    meter_type: string
    meter_uuid: string
    meter_uuid_used?: string
    meter_assigned?: string
    createdAt: Date | string
  }

  export type meter_numbersUpdateInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_uuid?: StringFieldUpdateOperationsInput | string
    meter_uuid_used?: StringFieldUpdateOperationsInput | string
    meter_assigned?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_numbersUncheckedUpdateInput = {
    meter_uuid_id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_uuid?: StringFieldUpdateOperationsInput | string
    meter_uuid_used?: StringFieldUpdateOperationsInput | string
    meter_assigned?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_numbersCreateManyInput = {
    meter_uuid_id?: number
    meter_type: string
    meter_uuid: string
    meter_uuid_used?: string
    meter_assigned?: string
    createdAt: Date | string
  }

  export type meter_numbersUpdateManyMutationInput = {
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_uuid?: StringFieldUpdateOperationsInput | string
    meter_uuid_used?: StringFieldUpdateOperationsInput | string
    meter_assigned?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_numbersUncheckedUpdateManyInput = {
    meter_uuid_id?: IntFieldUpdateOperationsInput | number
    meter_type?: StringFieldUpdateOperationsInput | string
    meter_uuid?: StringFieldUpdateOperationsInput | string
    meter_uuid_used?: StringFieldUpdateOperationsInput | string
    meter_assigned?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driverequestsCreateInput = {
    id: number
    uuid?: string | null
    orderid: number
    customerid: number
    address: string
    driverid: number
    status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type driverequestsUncheckedCreateInput = {
    id: number
    uuid?: string | null
    orderid: number
    customerid: number
    address: string
    driverid: number
    status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type driverequestsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driverequestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driverequestsCreateManyInput = {
    id: number
    uuid?: string | null
    orderid: number
    customerid: number
    address: string
    driverid: number
    status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type driverequestsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type driverequestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: IntFieldUpdateOperationsInput | number
    customerid?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_tableCreateInput = {
    order_id: number
    order_trans_id: string
    username?: string | null
    order_date?: Date | string | null
    order_time?: Date | string
    status?: string
    customercomment?: string | null
    notes?: string
    shipping_first_name?: string
    shipping_last_name?: string
    shipping_address1?: string
    shipping_address2?: string
    shipping_phone?: string
    shipping_email?: string | null
    shipping_city?: string
    shipping_state?: string
    shipping_country: string
    order_total?: Decimal | DecimalJsLike | number | string
    delivery_type?: string
    shipping_cost?: Decimal | DecimalJsLike | number | string
    grandtotal?: Decimal | DecimalJsLike | number | string
    gatewayid: number
    gwtranxid?: number | null
    gwcustid?: string | null
    gwtranxamt?: Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: number | null
    gwstatusmsg?: string | null
    o_sesid: string
    last_update_by: $Enums.order_table_last_update_by
    order_stage?: number
    shipping_option: string
    payment_option: string
    payment_status?: string
  }

  export type order_tableUncheckedCreateInput = {
    order_id: number
    order_trans_id: string
    username?: string | null
    order_date?: Date | string | null
    order_time?: Date | string
    status?: string
    customercomment?: string | null
    notes?: string
    shipping_first_name?: string
    shipping_last_name?: string
    shipping_address1?: string
    shipping_address2?: string
    shipping_phone?: string
    shipping_email?: string | null
    shipping_city?: string
    shipping_state?: string
    shipping_country: string
    order_total?: Decimal | DecimalJsLike | number | string
    delivery_type?: string
    shipping_cost?: Decimal | DecimalJsLike | number | string
    grandtotal?: Decimal | DecimalJsLike | number | string
    gatewayid: number
    gwtranxid?: number | null
    gwcustid?: string | null
    gwtranxamt?: Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: number | null
    gwstatusmsg?: string | null
    o_sesid: string
    last_update_by: $Enums.order_table_last_update_by
    order_stage?: number
    shipping_option: string
    payment_option: string
    payment_status?: string
  }

  export type order_tableUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_trans_id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customercomment?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    shipping_first_name?: StringFieldUpdateOperationsInput | string
    shipping_last_name?: StringFieldUpdateOperationsInput | string
    shipping_address1?: StringFieldUpdateOperationsInput | string
    shipping_address2?: StringFieldUpdateOperationsInput | string
    shipping_phone?: StringFieldUpdateOperationsInput | string
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    order_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFieldUpdateOperationsInput | string
    shipping_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFieldUpdateOperationsInput | number
    gwtranxid?: NullableIntFieldUpdateOperationsInput | number | null
    gwcustid?: NullableStringFieldUpdateOperationsInput | string | null
    gwtranxamt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: NullableIntFieldUpdateOperationsInput | number | null
    gwstatusmsg?: NullableStringFieldUpdateOperationsInput | string | null
    o_sesid?: StringFieldUpdateOperationsInput | string
    last_update_by?: Enumorder_table_last_update_byFieldUpdateOperationsInput | $Enums.order_table_last_update_by
    order_stage?: IntFieldUpdateOperationsInput | number
    shipping_option?: StringFieldUpdateOperationsInput | string
    payment_option?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
  }

  export type order_tableUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_trans_id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customercomment?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    shipping_first_name?: StringFieldUpdateOperationsInput | string
    shipping_last_name?: StringFieldUpdateOperationsInput | string
    shipping_address1?: StringFieldUpdateOperationsInput | string
    shipping_address2?: StringFieldUpdateOperationsInput | string
    shipping_phone?: StringFieldUpdateOperationsInput | string
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    order_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFieldUpdateOperationsInput | string
    shipping_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFieldUpdateOperationsInput | number
    gwtranxid?: NullableIntFieldUpdateOperationsInput | number | null
    gwcustid?: NullableStringFieldUpdateOperationsInput | string | null
    gwtranxamt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: NullableIntFieldUpdateOperationsInput | number | null
    gwstatusmsg?: NullableStringFieldUpdateOperationsInput | string | null
    o_sesid?: StringFieldUpdateOperationsInput | string
    last_update_by?: Enumorder_table_last_update_byFieldUpdateOperationsInput | $Enums.order_table_last_update_by
    order_stage?: IntFieldUpdateOperationsInput | number
    shipping_option?: StringFieldUpdateOperationsInput | string
    payment_option?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
  }

  export type order_tableCreateManyInput = {
    order_id: number
    order_trans_id: string
    username?: string | null
    order_date?: Date | string | null
    order_time?: Date | string
    status?: string
    customercomment?: string | null
    notes?: string
    shipping_first_name?: string
    shipping_last_name?: string
    shipping_address1?: string
    shipping_address2?: string
    shipping_phone?: string
    shipping_email?: string | null
    shipping_city?: string
    shipping_state?: string
    shipping_country: string
    order_total?: Decimal | DecimalJsLike | number | string
    delivery_type?: string
    shipping_cost?: Decimal | DecimalJsLike | number | string
    grandtotal?: Decimal | DecimalJsLike | number | string
    gatewayid: number
    gwtranxid?: number | null
    gwcustid?: string | null
    gwtranxamt?: Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: number | null
    gwstatusmsg?: string | null
    o_sesid: string
    last_update_by: $Enums.order_table_last_update_by
    order_stage?: number
    shipping_option: string
    payment_option: string
    payment_status?: string
  }

  export type order_tableUpdateManyMutationInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_trans_id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customercomment?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    shipping_first_name?: StringFieldUpdateOperationsInput | string
    shipping_last_name?: StringFieldUpdateOperationsInput | string
    shipping_address1?: StringFieldUpdateOperationsInput | string
    shipping_address2?: StringFieldUpdateOperationsInput | string
    shipping_phone?: StringFieldUpdateOperationsInput | string
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    order_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFieldUpdateOperationsInput | string
    shipping_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFieldUpdateOperationsInput | number
    gwtranxid?: NullableIntFieldUpdateOperationsInput | number | null
    gwcustid?: NullableStringFieldUpdateOperationsInput | string | null
    gwtranxamt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: NullableIntFieldUpdateOperationsInput | number | null
    gwstatusmsg?: NullableStringFieldUpdateOperationsInput | string | null
    o_sesid?: StringFieldUpdateOperationsInput | string
    last_update_by?: Enumorder_table_last_update_byFieldUpdateOperationsInput | $Enums.order_table_last_update_by
    order_stage?: IntFieldUpdateOperationsInput | number
    shipping_option?: StringFieldUpdateOperationsInput | string
    payment_option?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
  }

  export type order_tableUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_trans_id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customercomment?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    shipping_first_name?: StringFieldUpdateOperationsInput | string
    shipping_last_name?: StringFieldUpdateOperationsInput | string
    shipping_address1?: StringFieldUpdateOperationsInput | string
    shipping_address2?: StringFieldUpdateOperationsInput | string
    shipping_phone?: StringFieldUpdateOperationsInput | string
    shipping_email?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_city?: StringFieldUpdateOperationsInput | string
    shipping_state?: StringFieldUpdateOperationsInput | string
    shipping_country?: StringFieldUpdateOperationsInput | string
    order_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    delivery_type?: StringFieldUpdateOperationsInput | string
    shipping_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gatewayid?: IntFieldUpdateOperationsInput | number
    gwtranxid?: NullableIntFieldUpdateOperationsInput | number | null
    gwcustid?: NullableStringFieldUpdateOperationsInput | string | null
    gwtranxamt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gwstatuscode?: NullableIntFieldUpdateOperationsInput | number | null
    gwstatusmsg?: NullableStringFieldUpdateOperationsInput | string | null
    o_sesid?: StringFieldUpdateOperationsInput | string
    last_update_by?: Enumorder_table_last_update_byFieldUpdateOperationsInput | $Enums.order_table_last_update_by
    order_stage?: IntFieldUpdateOperationsInput | number
    shipping_option?: StringFieldUpdateOperationsInput | string
    payment_option?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
  }

  export type packagesCreateInput = {
    id: number
    uuid?: string | null
    name: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    status?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type packagesUncheckedCreateInput = {
    id: number
    uuid?: string | null
    name: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    status?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type packagesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesCreateManyInput = {
    id: number
    uuid?: string | null
    name: string
    sku: string
    description: string
    picture: string
    price: number
    size: string
    status?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type packagesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsCreateInput = {
    id: number
    uuid?: string | null
    orderid: string
    driverid: number
    stars: number
    comment: string
    customerid: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ratingsUncheckedCreateInput = {
    id: number
    uuid?: string | null
    orderid: string
    driverid: number
    stars: number
    comment: string
    customerid: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ratingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerid?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerid?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsCreateManyInput = {
    id: number
    uuid?: string | null
    orderid: string
    driverid: number
    stars: number
    comment: string
    customerid: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ratingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerid?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    orderid?: StringFieldUpdateOperationsInput | string
    driverid?: IntFieldUpdateOperationsInput | number
    stars?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerid?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usercatCreateInput = {
    usercatid: number
    usercategory: string
    usercatdesc: string
  }

  export type usercatUncheckedCreateInput = {
    usercatid: number
    usercategory: string
    usercatdesc: string
  }

  export type usercatUpdateInput = {
    usercatid?: IntFieldUpdateOperationsInput | number
    usercategory?: StringFieldUpdateOperationsInput | string
    usercatdesc?: StringFieldUpdateOperationsInput | string
  }

  export type usercatUncheckedUpdateInput = {
    usercatid?: IntFieldUpdateOperationsInput | number
    usercategory?: StringFieldUpdateOperationsInput | string
    usercatdesc?: StringFieldUpdateOperationsInput | string
  }

  export type usercatCreateManyInput = {
    usercatid: number
    usercategory: string
    usercatdesc: string
  }

  export type usercatUpdateManyMutationInput = {
    usercatid?: IntFieldUpdateOperationsInput | number
    usercategory?: StringFieldUpdateOperationsInput | string
    usercatdesc?: StringFieldUpdateOperationsInput | string
  }

  export type usercatUncheckedUpdateManyInput = {
    usercatid?: IntFieldUpdateOperationsInput | number
    usercategory?: StringFieldUpdateOperationsInput | string
    usercatdesc?: StringFieldUpdateOperationsInput | string
  }

  export type complaints_repliesCreateInput = {
    complaintid: number
    creplysubject: string
    creplyname: string
    creplyphone: string
    creplymessage: string
    createdAt: Date | string
  }

  export type complaints_repliesUncheckedCreateInput = {
    creplyid?: number
    complaintid: number
    creplysubject: string
    creplyname: string
    creplyphone: string
    creplymessage: string
    createdAt: Date | string
  }

  export type complaints_repliesUpdateInput = {
    complaintid?: IntFieldUpdateOperationsInput | number
    creplysubject?: StringFieldUpdateOperationsInput | string
    creplyname?: StringFieldUpdateOperationsInput | string
    creplyphone?: StringFieldUpdateOperationsInput | string
    creplymessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaints_repliesUncheckedUpdateInput = {
    creplyid?: IntFieldUpdateOperationsInput | number
    complaintid?: IntFieldUpdateOperationsInput | number
    creplysubject?: StringFieldUpdateOperationsInput | string
    creplyname?: StringFieldUpdateOperationsInput | string
    creplyphone?: StringFieldUpdateOperationsInput | string
    creplymessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaints_repliesCreateManyInput = {
    creplyid?: number
    complaintid: number
    creplysubject: string
    creplyname: string
    creplyphone: string
    creplymessage: string
    createdAt: Date | string
  }

  export type complaints_repliesUpdateManyMutationInput = {
    complaintid?: IntFieldUpdateOperationsInput | number
    creplysubject?: StringFieldUpdateOperationsInput | string
    creplyname?: StringFieldUpdateOperationsInput | string
    creplyphone?: StringFieldUpdateOperationsInput | string
    creplymessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaints_repliesUncheckedUpdateManyInput = {
    creplyid?: IntFieldUpdateOperationsInput | number
    complaintid?: IntFieldUpdateOperationsInput | number
    creplysubject?: StringFieldUpdateOperationsInput | string
    creplyname?: StringFieldUpdateOperationsInput | string
    creplyphone?: StringFieldUpdateOperationsInput | string
    creplymessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateInput = {
    subplantype?: string
    subplanusername: string
    subplanamt?: number
    subplan_from: Date | string
    subplan_to: Date | string
    subplan_status?: string
    subplan_pay_status?: string
    subplan_area: string
    subplan_admin: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUncheckedCreateInput = {
    subplanid?: number
    subplantype?: string
    subplanusername: string
    subplanamt?: number
    subplan_from: Date | string
    subplan_to: Date | string
    subplan_status?: string
    subplan_pay_status?: string
    subplan_area: string
    subplan_admin: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateInput = {
    subplantype?: StringFieldUpdateOperationsInput | string
    subplanusername?: StringFieldUpdateOperationsInput | string
    subplanamt?: IntFieldUpdateOperationsInput | number
    subplan_from?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_to?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_status?: StringFieldUpdateOperationsInput | string
    subplan_pay_status?: StringFieldUpdateOperationsInput | string
    subplan_area?: StringFieldUpdateOperationsInput | string
    subplan_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateInput = {
    subplanid?: IntFieldUpdateOperationsInput | number
    subplantype?: StringFieldUpdateOperationsInput | string
    subplanusername?: StringFieldUpdateOperationsInput | string
    subplanamt?: IntFieldUpdateOperationsInput | number
    subplan_from?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_to?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_status?: StringFieldUpdateOperationsInput | string
    subplan_pay_status?: StringFieldUpdateOperationsInput | string
    subplan_area?: StringFieldUpdateOperationsInput | string
    subplan_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateManyInput = {
    subplanid?: number
    subplantype?: string
    subplanusername: string
    subplanamt?: number
    subplan_from: Date | string
    subplan_to: Date | string
    subplan_status?: string
    subplan_pay_status?: string
    subplan_area: string
    subplan_admin: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscriptionsUpdateManyMutationInput = {
    subplantype?: StringFieldUpdateOperationsInput | string
    subplanusername?: StringFieldUpdateOperationsInput | string
    subplanamt?: IntFieldUpdateOperationsInput | number
    subplan_from?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_to?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_status?: StringFieldUpdateOperationsInput | string
    subplan_pay_status?: StringFieldUpdateOperationsInput | string
    subplan_area?: StringFieldUpdateOperationsInput | string
    subplan_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    subplanid?: IntFieldUpdateOperationsInput | number
    subplantype?: StringFieldUpdateOperationsInput | string
    subplanusername?: StringFieldUpdateOperationsInput | string
    subplanamt?: IntFieldUpdateOperationsInput | number
    subplan_from?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_to?: DateTimeFieldUpdateOperationsInput | Date | string
    subplan_status?: StringFieldUpdateOperationsInput | string
    subplan_pay_status?: StringFieldUpdateOperationsInput | string
    subplan_area?: StringFieldUpdateOperationsInput | string
    subplan_admin?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trucksCreateInput = {
    truck_make: string
    truck_plateno: string
    truck_fleetowner?: number | null
    truck_meterid?: string | null
    truck_driver?: string | null
    truck_status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trucksUncheckedCreateInput = {
    truckid?: number
    truck_make: string
    truck_plateno: string
    truck_fleetowner?: number | null
    truck_meterid?: string | null
    truck_driver?: string | null
    truck_status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trucksUpdateInput = {
    truck_make?: StringFieldUpdateOperationsInput | string
    truck_plateno?: StringFieldUpdateOperationsInput | string
    truck_fleetowner?: NullableIntFieldUpdateOperationsInput | number | null
    truck_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    truck_driver?: NullableStringFieldUpdateOperationsInput | string | null
    truck_status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trucksUncheckedUpdateInput = {
    truckid?: IntFieldUpdateOperationsInput | number
    truck_make?: StringFieldUpdateOperationsInput | string
    truck_plateno?: StringFieldUpdateOperationsInput | string
    truck_fleetowner?: NullableIntFieldUpdateOperationsInput | number | null
    truck_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    truck_driver?: NullableStringFieldUpdateOperationsInput | string | null
    truck_status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trucksCreateManyInput = {
    truckid?: number
    truck_make: string
    truck_plateno: string
    truck_fleetowner?: number | null
    truck_meterid?: string | null
    truck_driver?: string | null
    truck_status?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type trucksUpdateManyMutationInput = {
    truck_make?: StringFieldUpdateOperationsInput | string
    truck_plateno?: StringFieldUpdateOperationsInput | string
    truck_fleetowner?: NullableIntFieldUpdateOperationsInput | number | null
    truck_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    truck_driver?: NullableStringFieldUpdateOperationsInput | string | null
    truck_status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trucksUncheckedUpdateManyInput = {
    truckid?: IntFieldUpdateOperationsInput | number
    truck_make?: StringFieldUpdateOperationsInput | string
    truck_plateno?: StringFieldUpdateOperationsInput | string
    truck_fleetowner?: NullableIntFieldUpdateOperationsInput | number | null
    truck_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    truck_driver?: NullableStringFieldUpdateOperationsInput | string | null
    truck_status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type area_groupsCreateInput = {
    agname: string
    agareas: string
  }

  export type area_groupsUncheckedCreateInput = {
    agid?: number
    agname: string
    agareas: string
  }

  export type area_groupsUpdateInput = {
    agname?: StringFieldUpdateOperationsInput | string
    agareas?: StringFieldUpdateOperationsInput | string
  }

  export type area_groupsUncheckedUpdateInput = {
    agid?: IntFieldUpdateOperationsInput | number
    agname?: StringFieldUpdateOperationsInput | string
    agareas?: StringFieldUpdateOperationsInput | string
  }

  export type area_groupsCreateManyInput = {
    agid?: number
    agname: string
    agareas: string
  }

  export type area_groupsUpdateManyMutationInput = {
    agname?: StringFieldUpdateOperationsInput | string
    agareas?: StringFieldUpdateOperationsInput | string
  }

  export type area_groupsUncheckedUpdateManyInput = {
    agid?: IntFieldUpdateOperationsInput | number
    agname?: StringFieldUpdateOperationsInput | string
    agareas?: StringFieldUpdateOperationsInput | string
  }

  export type product_prices_areasCreateInput = {
    ppa_pid: number
    pparea: string
    pp_subscription?: string
    pp_rate?: number
  }

  export type product_prices_areasUncheckedCreateInput = {
    ppid?: number
    ppa_pid: number
    pparea: string
    pp_subscription?: string
    pp_rate?: number
  }

  export type product_prices_areasUpdateInput = {
    ppa_pid?: IntFieldUpdateOperationsInput | number
    pparea?: StringFieldUpdateOperationsInput | string
    pp_subscription?: StringFieldUpdateOperationsInput | string
    pp_rate?: IntFieldUpdateOperationsInput | number
  }

  export type product_prices_areasUncheckedUpdateInput = {
    ppid?: IntFieldUpdateOperationsInput | number
    ppa_pid?: IntFieldUpdateOperationsInput | number
    pparea?: StringFieldUpdateOperationsInput | string
    pp_subscription?: StringFieldUpdateOperationsInput | string
    pp_rate?: IntFieldUpdateOperationsInput | number
  }

  export type product_prices_areasCreateManyInput = {
    ppid?: number
    ppa_pid: number
    pparea: string
    pp_subscription?: string
    pp_rate?: number
  }

  export type product_prices_areasUpdateManyMutationInput = {
    ppa_pid?: IntFieldUpdateOperationsInput | number
    pparea?: StringFieldUpdateOperationsInput | string
    pp_subscription?: StringFieldUpdateOperationsInput | string
    pp_rate?: IntFieldUpdateOperationsInput | number
  }

  export type product_prices_areasUncheckedUpdateManyInput = {
    ppid?: IntFieldUpdateOperationsInput | number
    ppa_pid?: IntFieldUpdateOperationsInput | number
    pparea?: StringFieldUpdateOperationsInput | string
    pp_subscription?: StringFieldUpdateOperationsInput | string
    pp_rate?: IntFieldUpdateOperationsInput | number
  }

  export type articlesCreateInput = {
    artcategory: string
    title: string
    titleslug: string
    fullcontent: string
    mkeys: string
    mdesc: string
    artsource?: string | null
    artsource_url?: string | null
    artphoto?: string | null
    artphotocaption: string
    artphotourl?: string | null
    author?: string | null
    artstatus?: string
    views?: number
    published_date: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type articlesUncheckedCreateInput = {
    artid?: number
    artcategory: string
    title: string
    titleslug: string
    fullcontent: string
    mkeys: string
    mdesc: string
    artsource?: string | null
    artsource_url?: string | null
    artphoto?: string | null
    artphotocaption: string
    artphotourl?: string | null
    author?: string | null
    artstatus?: string
    views?: number
    published_date: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type articlesUpdateInput = {
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    mkeys?: StringFieldUpdateOperationsInput | string
    mdesc?: StringFieldUpdateOperationsInput | string
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    artphotourl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    published_date?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlesUncheckedUpdateInput = {
    artid?: IntFieldUpdateOperationsInput | number
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    mkeys?: StringFieldUpdateOperationsInput | string
    mdesc?: StringFieldUpdateOperationsInput | string
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    artphotourl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    published_date?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlesCreateManyInput = {
    artid?: number
    artcategory: string
    title: string
    titleslug: string
    fullcontent: string
    mkeys: string
    mdesc: string
    artsource?: string | null
    artsource_url?: string | null
    artphoto?: string | null
    artphotocaption: string
    artphotourl?: string | null
    author?: string | null
    artstatus?: string
    views?: number
    published_date: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type articlesUpdateManyMutationInput = {
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    mkeys?: StringFieldUpdateOperationsInput | string
    mdesc?: StringFieldUpdateOperationsInput | string
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    artphotourl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    published_date?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlesUncheckedUpdateManyInput = {
    artid?: IntFieldUpdateOperationsInput | number
    artcategory?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleslug?: StringFieldUpdateOperationsInput | string
    fullcontent?: StringFieldUpdateOperationsInput | string
    mkeys?: StringFieldUpdateOperationsInput | string
    mdesc?: StringFieldUpdateOperationsInput | string
    artsource?: NullableStringFieldUpdateOperationsInput | string | null
    artsource_url?: NullableStringFieldUpdateOperationsInput | string | null
    artphoto?: NullableStringFieldUpdateOperationsInput | string | null
    artphotocaption?: StringFieldUpdateOperationsInput | string
    artphotourl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    artstatus?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    published_date?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscription_plansCreateInput = {
    subplan_cat?: string
    subplan: string
    subplan_amount?: number
    subplan_months: string
    subplan_include: string
    subplan_exclude: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscription_plansUncheckedCreateInput = {
    subplanid?: number
    subplan_cat?: string
    subplan: string
    subplan_amount?: number
    subplan_months: string
    subplan_include: string
    subplan_exclude: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscription_plansUpdateInput = {
    subplan_cat?: StringFieldUpdateOperationsInput | string
    subplan?: StringFieldUpdateOperationsInput | string
    subplan_amount?: FloatFieldUpdateOperationsInput | number
    subplan_months?: StringFieldUpdateOperationsInput | string
    subplan_include?: StringFieldUpdateOperationsInput | string
    subplan_exclude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscription_plansUncheckedUpdateInput = {
    subplanid?: IntFieldUpdateOperationsInput | number
    subplan_cat?: StringFieldUpdateOperationsInput | string
    subplan?: StringFieldUpdateOperationsInput | string
    subplan_amount?: FloatFieldUpdateOperationsInput | number
    subplan_months?: StringFieldUpdateOperationsInput | string
    subplan_include?: StringFieldUpdateOperationsInput | string
    subplan_exclude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscription_plansCreateManyInput = {
    subplanid?: number
    subplan_cat?: string
    subplan: string
    subplan_amount?: number
    subplan_months: string
    subplan_include: string
    subplan_exclude: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type subscription_plansUpdateManyMutationInput = {
    subplan_cat?: StringFieldUpdateOperationsInput | string
    subplan?: StringFieldUpdateOperationsInput | string
    subplan_amount?: FloatFieldUpdateOperationsInput | number
    subplan_months?: StringFieldUpdateOperationsInput | string
    subplan_include?: StringFieldUpdateOperationsInput | string
    subplan_exclude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscription_plansUncheckedUpdateManyInput = {
    subplanid?: IntFieldUpdateOperationsInput | number
    subplan_cat?: StringFieldUpdateOperationsInput | string
    subplan?: StringFieldUpdateOperationsInput | string
    subplan_amount?: FloatFieldUpdateOperationsInput | number
    subplan_months?: StringFieldUpdateOperationsInput | string
    subplan_include?: StringFieldUpdateOperationsInput | string
    subplan_exclude?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorreportsCreateInput = {
    customerid?: string | null
    customername: string
    vendorid: string
    plateno: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type vendorreportsUncheckedCreateInput = {
    id?: number
    customerid?: string | null
    customername: string
    vendorid: string
    plateno: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type vendorreportsUpdateInput = {
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    vendorid?: StringFieldUpdateOperationsInput | string
    plateno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorreportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    vendorid?: StringFieldUpdateOperationsInput | string
    plateno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorreportsCreateManyInput = {
    id?: number
    customerid?: string | null
    customername: string
    vendorid: string
    plateno: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type vendorreportsUpdateManyMutationInput = {
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    vendorid?: StringFieldUpdateOperationsInput | string
    plateno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorreportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    customername?: StringFieldUpdateOperationsInput | string
    vendorid?: StringFieldUpdateOperationsInput | string
    plateno?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type water_purchasesCreateInput = {
    wp_orderref?: string | null
    wp_type: string
    wp_merchant_id: string
    wp_merchant_name: string
    wp_merchant_address: string
    wp_merchant_latitude: Decimal | DecimalJsLike | number | string
    wp_merchant_longitude: Decimal | DecimalJsLike | number | string
    wp_volume: string
    wp_amount: number
    wp_commission: number
    wp_owner_amount: number
    wp_driver_id: string
    wp_driver_name: string
    wp_driver_latitude: Decimal | DecimalJsLike | number | string
    wp_driver_longitude: Decimal | DecimalJsLike | number | string
    wp_fleetid: string
    wp_remark: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type water_purchasesUncheckedCreateInput = {
    wpid?: number
    wp_orderref?: string | null
    wp_type: string
    wp_merchant_id: string
    wp_merchant_name: string
    wp_merchant_address: string
    wp_merchant_latitude: Decimal | DecimalJsLike | number | string
    wp_merchant_longitude: Decimal | DecimalJsLike | number | string
    wp_volume: string
    wp_amount: number
    wp_commission: number
    wp_owner_amount: number
    wp_driver_id: string
    wp_driver_name: string
    wp_driver_latitude: Decimal | DecimalJsLike | number | string
    wp_driver_longitude: Decimal | DecimalJsLike | number | string
    wp_fleetid: string
    wp_remark: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type water_purchasesUpdateInput = {
    wp_orderref?: NullableStringFieldUpdateOperationsInput | string | null
    wp_type?: StringFieldUpdateOperationsInput | string
    wp_merchant_id?: StringFieldUpdateOperationsInput | string
    wp_merchant_name?: StringFieldUpdateOperationsInput | string
    wp_merchant_address?: StringFieldUpdateOperationsInput | string
    wp_merchant_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFieldUpdateOperationsInput | string
    wp_amount?: FloatFieldUpdateOperationsInput | number
    wp_commission?: FloatFieldUpdateOperationsInput | number
    wp_owner_amount?: FloatFieldUpdateOperationsInput | number
    wp_driver_id?: StringFieldUpdateOperationsInput | string
    wp_driver_name?: StringFieldUpdateOperationsInput | string
    wp_driver_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFieldUpdateOperationsInput | string
    wp_remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type water_purchasesUncheckedUpdateInput = {
    wpid?: IntFieldUpdateOperationsInput | number
    wp_orderref?: NullableStringFieldUpdateOperationsInput | string | null
    wp_type?: StringFieldUpdateOperationsInput | string
    wp_merchant_id?: StringFieldUpdateOperationsInput | string
    wp_merchant_name?: StringFieldUpdateOperationsInput | string
    wp_merchant_address?: StringFieldUpdateOperationsInput | string
    wp_merchant_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFieldUpdateOperationsInput | string
    wp_amount?: FloatFieldUpdateOperationsInput | number
    wp_commission?: FloatFieldUpdateOperationsInput | number
    wp_owner_amount?: FloatFieldUpdateOperationsInput | number
    wp_driver_id?: StringFieldUpdateOperationsInput | string
    wp_driver_name?: StringFieldUpdateOperationsInput | string
    wp_driver_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFieldUpdateOperationsInput | string
    wp_remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type water_purchasesCreateManyInput = {
    wpid?: number
    wp_orderref?: string | null
    wp_type: string
    wp_merchant_id: string
    wp_merchant_name: string
    wp_merchant_address: string
    wp_merchant_latitude: Decimal | DecimalJsLike | number | string
    wp_merchant_longitude: Decimal | DecimalJsLike | number | string
    wp_volume: string
    wp_amount: number
    wp_commission: number
    wp_owner_amount: number
    wp_driver_id: string
    wp_driver_name: string
    wp_driver_latitude: Decimal | DecimalJsLike | number | string
    wp_driver_longitude: Decimal | DecimalJsLike | number | string
    wp_fleetid: string
    wp_remark: string
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type water_purchasesUpdateManyMutationInput = {
    wp_orderref?: NullableStringFieldUpdateOperationsInput | string | null
    wp_type?: StringFieldUpdateOperationsInput | string
    wp_merchant_id?: StringFieldUpdateOperationsInput | string
    wp_merchant_name?: StringFieldUpdateOperationsInput | string
    wp_merchant_address?: StringFieldUpdateOperationsInput | string
    wp_merchant_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFieldUpdateOperationsInput | string
    wp_amount?: FloatFieldUpdateOperationsInput | number
    wp_commission?: FloatFieldUpdateOperationsInput | number
    wp_owner_amount?: FloatFieldUpdateOperationsInput | number
    wp_driver_id?: StringFieldUpdateOperationsInput | string
    wp_driver_name?: StringFieldUpdateOperationsInput | string
    wp_driver_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFieldUpdateOperationsInput | string
    wp_remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type water_purchasesUncheckedUpdateManyInput = {
    wpid?: IntFieldUpdateOperationsInput | number
    wp_orderref?: NullableStringFieldUpdateOperationsInput | string | null
    wp_type?: StringFieldUpdateOperationsInput | string
    wp_merchant_id?: StringFieldUpdateOperationsInput | string
    wp_merchant_name?: StringFieldUpdateOperationsInput | string
    wp_merchant_address?: StringFieldUpdateOperationsInput | string
    wp_merchant_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_merchant_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_volume?: StringFieldUpdateOperationsInput | string
    wp_amount?: FloatFieldUpdateOperationsInput | number
    wp_commission?: FloatFieldUpdateOperationsInput | number
    wp_owner_amount?: FloatFieldUpdateOperationsInput | number
    wp_driver_id?: StringFieldUpdateOperationsInput | string
    wp_driver_name?: StringFieldUpdateOperationsInput | string
    wp_driver_latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_driver_longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wp_fleetid?: StringFieldUpdateOperationsInput | string
    wp_remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsCreateInput = {
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meter: metersCreateNestedOneWithoutMeter_readingsInput
    first_reading_user?: usersCreateNestedOneWithoutFirst_meter_readingsInput
    afternoon_reading_user?: usersCreateNestedOneWithoutAfternoon_meter_readingsInput
    last_reading_user?: usersCreateNestedOneWithoutLast_meter_readingsInput
  }

  export type MeterReadingsUncheckedCreateInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsUpdateInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    first_reading_user?: usersUpdateOneWithoutFirst_meter_readingsNestedInput
    afternoon_reading_user?: usersUpdateOneWithoutAfternoon_meter_readingsNestedInput
    last_reading_user?: usersUpdateOneWithoutLast_meter_readingsNestedInput
  }

  export type MeterReadingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsCreateManyInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsUpdateManyMutationInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type banneradsOrderByRelevanceInput = {
    fields: banneradsOrderByRelevanceFieldEnum | banneradsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type banneradsCountOrderByAggregateInput = {
    id_ad?: SortOrder
    title_ad?: SortOrder
    descr_ad?: SortOrder
    adcode?: SortOrder
    file_ad?: SortOrder
    topfile_ad?: SortOrder
    url_ad?: SortOrder
    banner_rank?: SortOrder
    addedon_ad?: SortOrder
    startdate_ad?: SortOrder
    enddate_ad?: SortOrder
    daysno_ad?: SortOrder
    width_ad?: SortOrder
    height_ad?: SortOrder
    position_ad?: SortOrder
    banner_status?: SortOrder
    visible_ad?: SortOrder
    userid_ad?: SortOrder
    username_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrder
    datepaid?: SortOrder
    remark?: SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
  }

  export type banneradsAvgOrderByAggregateInput = {
    id_ad?: SortOrder
    banner_rank?: SortOrder
    visible_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
  }

  export type banneradsMaxOrderByAggregateInput = {
    id_ad?: SortOrder
    title_ad?: SortOrder
    descr_ad?: SortOrder
    adcode?: SortOrder
    file_ad?: SortOrder
    topfile_ad?: SortOrder
    url_ad?: SortOrder
    banner_rank?: SortOrder
    addedon_ad?: SortOrder
    startdate_ad?: SortOrder
    enddate_ad?: SortOrder
    daysno_ad?: SortOrder
    width_ad?: SortOrder
    height_ad?: SortOrder
    position_ad?: SortOrder
    banner_status?: SortOrder
    visible_ad?: SortOrder
    userid_ad?: SortOrder
    username_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrder
    datepaid?: SortOrder
    remark?: SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
  }

  export type banneradsMinOrderByAggregateInput = {
    id_ad?: SortOrder
    title_ad?: SortOrder
    descr_ad?: SortOrder
    adcode?: SortOrder
    file_ad?: SortOrder
    topfile_ad?: SortOrder
    url_ad?: SortOrder
    banner_rank?: SortOrder
    addedon_ad?: SortOrder
    startdate_ad?: SortOrder
    enddate_ad?: SortOrder
    daysno_ad?: SortOrder
    width_ad?: SortOrder
    height_ad?: SortOrder
    position_ad?: SortOrder
    banner_status?: SortOrder
    visible_ad?: SortOrder
    userid_ad?: SortOrder
    username_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrder
    datepaid?: SortOrder
    remark?: SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
  }

  export type banneradsSumOrderByAggregateInput = {
    id_ad?: SortOrder
    banner_rank?: SortOrder
    visible_ad?: SortOrder
    paid?: SortOrder
    amount?: SortOrder
    views_ad?: SortOrder
    clicks_ad?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type blogOrderByRelevanceInput = {
    fields: blogOrderByRelevanceFieldEnum | blogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type blogCountOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    brief?: SortOrder
    fullcontent?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    author?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    published_date?: SortOrder
    artstatus?: SortOrder
    nstatus?: SortOrder
    views?: SortOrder
    artsubmit?: SortOrder
    artusername?: SortOrder
    youtube_embed?: SortOrder
    vidurl?: SortOrder
    homepage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type blogAvgOrderByAggregateInput = {
    artid?: SortOrder
    views?: SortOrder
    homepage?: SortOrder
  }

  export type blogMaxOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    brief?: SortOrder
    fullcontent?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    author?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    published_date?: SortOrder
    artstatus?: SortOrder
    nstatus?: SortOrder
    views?: SortOrder
    artsubmit?: SortOrder
    artusername?: SortOrder
    youtube_embed?: SortOrder
    vidurl?: SortOrder
    homepage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type blogMinOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    brief?: SortOrder
    fullcontent?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    author?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    published_date?: SortOrder
    artstatus?: SortOrder
    nstatus?: SortOrder
    views?: SortOrder
    artsubmit?: SortOrder
    artusername?: SortOrder
    youtube_embed?: SortOrder
    vidurl?: SortOrder
    homepage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type blogSumOrderByAggregateInput = {
    artid?: SortOrder
    views?: SortOrder
    homepage?: SortOrder
  }

  export type contentpagesOrderByRelevanceInput = {
    fields: contentpagesOrderByRelevanceFieldEnum | contentpagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contentpagesCountOrderByAggregateInput = {
    cpageid?: SortOrder
    cpagename?: SortOrder
    cpagecontent?: SortOrder
    cpagephoto?: SortOrder
    cpagesbanner?: SortOrder
    cpagemenu?: SortOrder
    cpagelinkname?: SortOrder
    cpage_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contentpagesAvgOrderByAggregateInput = {
    cpageid?: SortOrder
  }

  export type contentpagesMaxOrderByAggregateInput = {
    cpageid?: SortOrder
    cpagename?: SortOrder
    cpagecontent?: SortOrder
    cpagephoto?: SortOrder
    cpagesbanner?: SortOrder
    cpagemenu?: SortOrder
    cpagelinkname?: SortOrder
    cpage_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contentpagesMinOrderByAggregateInput = {
    cpageid?: SortOrder
    cpagename?: SortOrder
    cpagecontent?: SortOrder
    cpagephoto?: SortOrder
    cpagesbanner?: SortOrder
    cpagemenu?: SortOrder
    cpagelinkname?: SortOrder
    cpage_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contentpagesSumOrderByAggregateInput = {
    cpageid?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type driver_paymentsOrderByRelevanceInput = {
    fields: driver_paymentsOrderByRelevanceFieldEnum | driver_paymentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type driver_paymentsCountOrderByAggregateInput = {
    dpayid?: SortOrder
    dpayref?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
    dpaypaystackref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driver_paymentsAvgOrderByAggregateInput = {
    dpayid?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
  }

  export type driver_paymentsMaxOrderByAggregateInput = {
    dpayid?: SortOrder
    dpayref?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
    dpaypaystackref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driver_paymentsMinOrderByAggregateInput = {
    dpayid?: SortOrder
    dpayref?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
    dpaypaystackref?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driver_paymentsSumOrderByAggregateInput = {
    dpayid?: SortOrder
    dpaydriver?: SortOrder
    dpayoutstanding?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type faqsOrderByRelevanceInput = {
    fields: faqsOrderByRelevanceFieldEnum | faqsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type faqsCountOrderByAggregateInput = {
    faqid?: SortOrder
    faqcat?: SortOrder
    faqquestion?: SortOrder
    faqanswer?: SortOrder
    faqslug?: SortOrder
    faqpostedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsAvgOrderByAggregateInput = {
    faqid?: SortOrder
  }

  export type faqsMaxOrderByAggregateInput = {
    faqid?: SortOrder
    faqcat?: SortOrder
    faqquestion?: SortOrder
    faqanswer?: SortOrder
    faqslug?: SortOrder
    faqpostedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsMinOrderByAggregateInput = {
    faqid?: SortOrder
    faqcat?: SortOrder
    faqquestion?: SortOrder
    faqanswer?: SortOrder
    faqslug?: SortOrder
    faqpostedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsSumOrderByAggregateInput = {
    faqid?: SortOrder
  }

  export type loc_statesOrderByRelevanceInput = {
    fields: loc_statesOrderByRelevanceFieldEnum | loc_statesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type loc_statesCountOrderByAggregateInput = {
    stateid?: SortOrder
    state?: SortOrder
  }

  export type loc_statesAvgOrderByAggregateInput = {
    stateid?: SortOrder
  }

  export type loc_statesMaxOrderByAggregateInput = {
    stateid?: SortOrder
    state?: SortOrder
  }

  export type loc_statesMinOrderByAggregateInput = {
    stateid?: SortOrder
    state?: SortOrder
  }

  export type loc_statesSumOrderByAggregateInput = {
    stateid?: SortOrder
  }

  export type media_assetsOrderByRelevanceInput = {
    fields: media_assetsOrderByRelevanceFieldEnum | media_assetsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type media_assetsCountOrderByAggregateInput = {
    massetid?: SortOrder
    masset?: SortOrder
    massetdate?: SortOrder
  }

  export type media_assetsAvgOrderByAggregateInput = {
    massetid?: SortOrder
  }

  export type media_assetsMaxOrderByAggregateInput = {
    massetid?: SortOrder
    masset?: SortOrder
    massetdate?: SortOrder
  }

  export type media_assetsMinOrderByAggregateInput = {
    massetid?: SortOrder
    masset?: SortOrder
    massetdate?: SortOrder
  }

  export type media_assetsSumOrderByAggregateInput = {
    massetid?: SortOrder
  }

  export type newsletterOrderByRelevanceInput = {
    fields: newsletterOrderByRelevanceFieldEnum | newsletterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type newsletterCountOrderByAggregateInput = {
    nlid?: SortOrder
    nlname?: SortOrder
    nlemail?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
  }

  export type newsletterAvgOrderByAggregateInput = {
    nlid?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
  }

  export type newsletterMaxOrderByAggregateInput = {
    nlid?: SortOrder
    nlname?: SortOrder
    nlemail?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
  }

  export type newsletterMinOrderByAggregateInput = {
    nlid?: SortOrder
    nlname?: SortOrder
    nlemail?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
  }

  export type newsletterSumOrderByAggregateInput = {
    nlid?: SortOrder
    nlstatus?: SortOrder
    nl_received?: SortOrder
    nl_id?: SortOrder
  }

  export type newsletter_bodyOrderByRelevanceInput = {
    fields: newsletter_bodyOrderByRelevanceFieldEnum | newsletter_bodyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type newsletter_bodyCountOrderByAggregateInput = {
    nlb_id?: SortOrder
    nlb_title?: SortOrder
    nlb_story?: SortOrder
    nlb_finished?: SortOrder
    nlb_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type newsletter_bodyAvgOrderByAggregateInput = {
    nlb_id?: SortOrder
  }

  export type newsletter_bodyMaxOrderByAggregateInput = {
    nlb_id?: SortOrder
    nlb_title?: SortOrder
    nlb_story?: SortOrder
    nlb_finished?: SortOrder
    nlb_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type newsletter_bodyMinOrderByAggregateInput = {
    nlb_id?: SortOrder
    nlb_title?: SortOrder
    nlb_story?: SortOrder
    nlb_finished?: SortOrder
    nlb_postedby?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type newsletter_bodySumOrderByAggregateInput = {
    nlb_id?: SortOrder
  }

  export type paystackresponseOrderByRelevanceInput = {
    fields: paystackresponseOrderByRelevanceFieldEnum | paystackresponseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paystackresponseCountOrderByAggregateInput = {
    prid?: SortOrder
    prbody?: SortOrder
    pracc_number?: SortOrder
    pracc_bank?: SortOrder
    createdAt?: SortOrder
  }

  export type paystackresponseAvgOrderByAggregateInput = {
    prid?: SortOrder
  }

  export type paystackresponseMaxOrderByAggregateInput = {
    prid?: SortOrder
    prbody?: SortOrder
    pracc_number?: SortOrder
    pracc_bank?: SortOrder
    createdAt?: SortOrder
  }

  export type paystackresponseMinOrderByAggregateInput = {
    prid?: SortOrder
    prbody?: SortOrder
    pracc_number?: SortOrder
    pracc_bank?: SortOrder
    createdAt?: SortOrder
  }

  export type paystackresponseSumOrderByAggregateInput = {
    prid?: SortOrder
  }

  export type productcategoriesOrderByRelevanceInput = {
    fields: productcategoriesOrderByRelevanceFieldEnum | productcategoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type productcategoriesCountOrderByAggregateInput = {
    pcid?: SortOrder
    pcatname?: SortOrder
    pcatslug?: SortOrder
    pcatpicture?: SortOrder
    pcatdesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productcategoriesAvgOrderByAggregateInput = {
    pcid?: SortOrder
  }

  export type productcategoriesMaxOrderByAggregateInput = {
    pcid?: SortOrder
    pcatname?: SortOrder
    pcatslug?: SortOrder
    pcatpicture?: SortOrder
    pcatdesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productcategoriesMinOrderByAggregateInput = {
    pcid?: SortOrder
    pcatname?: SortOrder
    pcatslug?: SortOrder
    pcatpicture?: SortOrder
    pcatdesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productcategoriesSumOrderByAggregateInput = {
    pcid?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type productsOrderByRelevanceInput = {
    fields: productsOrderByRelevanceFieldEnum | productsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    catslug?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    nameslug?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    response_time?: SortOrder
    status?: SortOrder
    payment_account?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    catslug?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    nameslug?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    response_time?: SortOrder
    status?: SortOrder
    payment_account?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    catslug?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    nameslug?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    response_time?: SortOrder
    status?: SortOrder
    payment_account?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type requestsOrderByRelevanceInput = {
    fields: requestsOrderByRelevanceFieldEnum | requestsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type requestsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    orderref?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderid?: SortOrder
    howmany?: SortOrder
    productid?: SortOrder
    prod_waittime?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    driverid?: SortOrder
    views?: SortOrder
  }

  export type requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    orderref?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type requestsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    orderref?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    status?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type requestsSumOrderByAggregateInput = {
    id?: SortOrder
    orderid?: SortOrder
    howmany?: SortOrder
    productid?: SortOrder
    prod_waittime?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    customerid?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    driverid?: SortOrder
    views?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type shopinfoOrderByRelevanceInput = {
    fields: shopinfoOrderByRelevanceFieldEnum | shopinfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type shopinfoCountOrderByAggregateInput = {
    shopid?: SortOrder
    shopname?: SortOrder
    shopdescription?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    shoplogo?: SortOrder
    shmetakey?: SortOrder
    shmetadesc?: SortOrder
    shopphone?: SortOrder
    shopemailname?: SortOrder
    shopemailaddress?: SortOrder
    shoporderemail?: SortOrder
    shopaddress?: SortOrder
    shopcity?: SortOrder
    shopstate?: SortOrder
    shopcountry?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    offlinemsg?: SortOrder
    shopimage?: SortOrder
    total_news?: SortOrder
    slfacebook?: SortOrder
    sltwitter?: SortOrder
    slinstagram?: SortOrder
    slyoutube?: SortOrder
    postedby?: SortOrder
    updatedAt?: SortOrder
  }

  export type shopinfoAvgOrderByAggregateInput = {
    shopid?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    total_news?: SortOrder
  }

  export type shopinfoMaxOrderByAggregateInput = {
    shopid?: SortOrder
    shopname?: SortOrder
    shopdescription?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    shoplogo?: SortOrder
    shmetakey?: SortOrder
    shmetadesc?: SortOrder
    shopphone?: SortOrder
    shopemailname?: SortOrder
    shopemailaddress?: SortOrder
    shoporderemail?: SortOrder
    shopaddress?: SortOrder
    shopcity?: SortOrder
    shopstate?: SortOrder
    shopcountry?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    offlinemsg?: SortOrder
    shopimage?: SortOrder
    total_news?: SortOrder
    slfacebook?: SortOrder
    sltwitter?: SortOrder
    slinstagram?: SortOrder
    slyoutube?: SortOrder
    postedby?: SortOrder
    updatedAt?: SortOrder
  }

  export type shopinfoMinOrderByAggregateInput = {
    shopid?: SortOrder
    shopname?: SortOrder
    shopdescription?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    shoplogo?: SortOrder
    shmetakey?: SortOrder
    shmetadesc?: SortOrder
    shopphone?: SortOrder
    shopemailname?: SortOrder
    shopemailaddress?: SortOrder
    shoporderemail?: SortOrder
    shopaddress?: SortOrder
    shopcity?: SortOrder
    shopstate?: SortOrder
    shopcountry?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    offlinemsg?: SortOrder
    shopimage?: SortOrder
    total_news?: SortOrder
    slfacebook?: SortOrder
    sltwitter?: SortOrder
    slinstagram?: SortOrder
    slyoutube?: SortOrder
    postedby?: SortOrder
    updatedAt?: SortOrder
  }

  export type shopinfoSumOrderByAggregateInput = {
    shopid?: SortOrder
    driver_commission?: SortOrder
    water_merchant_commission?: SortOrder
    latestonhome?: SortOrder
    offline?: SortOrder
    total_news?: SortOrder
  }

  export type sociallinksOrderByRelevanceInput = {
    fields: sociallinksOrderByRelevanceFieldEnum | sociallinksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sociallinksCountOrderByAggregateInput = {
    slid?: SortOrder
    slimage?: SortOrder
    sladdress?: SortOrder
  }

  export type sociallinksAvgOrderByAggregateInput = {
    slid?: SortOrder
  }

  export type sociallinksMaxOrderByAggregateInput = {
    slid?: SortOrder
    slimage?: SortOrder
    sladdress?: SortOrder
  }

  export type sociallinksMinOrderByAggregateInput = {
    slid?: SortOrder
    slimage?: SortOrder
    sladdress?: SortOrder
  }

  export type sociallinksSumOrderByAggregateInput = {
    slid?: SortOrder
  }

  export type subscriptionOrderByRelevanceInput = {
    fields: subscriptionOrderByRelevanceFieldEnum | subscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscriptionCountOrderByAggregateInput = {
    submagid?: SortOrder
    sm_title?: SortOrder
    sm_initials?: SortOrder
    sm_surname?: SortOrder
    sm_business?: SortOrder
    sm_address?: SortOrder
    sm_postcode?: SortOrder
    sm_country?: SortOrder
    sm_telephone?: SortOrder
    sm_email?: SortOrder
    sm_dateposted?: SortOrder
    sm_amount?: SortOrder
    sm_paid?: SortOrder
    sm_datepaid?: SortOrder
    sm_from?: SortOrder
    sm_to?: SortOrder
  }

  export type subscriptionAvgOrderByAggregateInput = {
    submagid?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    submagid?: SortOrder
    sm_title?: SortOrder
    sm_initials?: SortOrder
    sm_surname?: SortOrder
    sm_business?: SortOrder
    sm_address?: SortOrder
    sm_postcode?: SortOrder
    sm_country?: SortOrder
    sm_telephone?: SortOrder
    sm_email?: SortOrder
    sm_dateposted?: SortOrder
    sm_amount?: SortOrder
    sm_paid?: SortOrder
    sm_datepaid?: SortOrder
    sm_from?: SortOrder
    sm_to?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    submagid?: SortOrder
    sm_title?: SortOrder
    sm_initials?: SortOrder
    sm_surname?: SortOrder
    sm_business?: SortOrder
    sm_address?: SortOrder
    sm_postcode?: SortOrder
    sm_country?: SortOrder
    sm_telephone?: SortOrder
    sm_email?: SortOrder
    sm_dateposted?: SortOrder
    sm_amount?: SortOrder
    sm_paid?: SortOrder
    sm_datepaid?: SortOrder
    sm_from?: SortOrder
    sm_to?: SortOrder
  }

  export type subscriptionSumOrderByAggregateInput = {
    submagid?: SortOrder
  }

  export type team_categoryOrderByRelevanceInput = {
    fields: team_categoryOrderByRelevanceFieldEnum | team_categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type team_categoryCountOrderByAggregateInput = {
    teamcategoryid?: SortOrder
    teamcategory?: SortOrder
    teamcat_slug?: SortOrder
  }

  export type team_categoryAvgOrderByAggregateInput = {
    teamcategoryid?: SortOrder
  }

  export type team_categoryMaxOrderByAggregateInput = {
    teamcategoryid?: SortOrder
    teamcategory?: SortOrder
    teamcat_slug?: SortOrder
  }

  export type team_categoryMinOrderByAggregateInput = {
    teamcategoryid?: SortOrder
    teamcategory?: SortOrder
    teamcat_slug?: SortOrder
  }

  export type team_categorySumOrderByAggregateInput = {
    teamcategoryid?: SortOrder
  }

  export type team_membersOrderByRelevanceInput = {
    fields: team_membersOrderByRelevanceFieldEnum | team_membersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type team_membersCountOrderByAggregateInput = {
    tmemberid?: SortOrder
    tmcategory?: SortOrder
    tmember?: SortOrder
    tmember_slug?: SortOrder
    tmemberposition?: SortOrder
    tmemberphoto?: SortOrder
    tmemberprofile?: SortOrder
    tmembersummary?: SortOrder
    tmemberdateadded?: SortOrder
    tmemberpostedby?: SortOrder
    tmemberrank?: SortOrder
    tmember_email?: SortOrder
    tmember_phone?: SortOrder
    tmember_facebook?: SortOrder
    tmember_twitter?: SortOrder
    tmember_linkedin?: SortOrder
    tmember_instagram?: SortOrder
  }

  export type team_membersAvgOrderByAggregateInput = {
    tmemberid?: SortOrder
    tmemberrank?: SortOrder
  }

  export type team_membersMaxOrderByAggregateInput = {
    tmemberid?: SortOrder
    tmcategory?: SortOrder
    tmember?: SortOrder
    tmember_slug?: SortOrder
    tmemberposition?: SortOrder
    tmemberphoto?: SortOrder
    tmemberprofile?: SortOrder
    tmembersummary?: SortOrder
    tmemberdateadded?: SortOrder
    tmemberpostedby?: SortOrder
    tmemberrank?: SortOrder
    tmember_email?: SortOrder
    tmember_phone?: SortOrder
    tmember_facebook?: SortOrder
    tmember_twitter?: SortOrder
    tmember_linkedin?: SortOrder
    tmember_instagram?: SortOrder
  }

  export type team_membersMinOrderByAggregateInput = {
    tmemberid?: SortOrder
    tmcategory?: SortOrder
    tmember?: SortOrder
    tmember_slug?: SortOrder
    tmemberposition?: SortOrder
    tmemberphoto?: SortOrder
    tmemberprofile?: SortOrder
    tmembersummary?: SortOrder
    tmemberdateadded?: SortOrder
    tmemberpostedby?: SortOrder
    tmemberrank?: SortOrder
    tmember_email?: SortOrder
    tmember_phone?: SortOrder
    tmember_facebook?: SortOrder
    tmember_twitter?: SortOrder
    tmember_linkedin?: SortOrder
    tmember_instagram?: SortOrder
  }

  export type team_membersSumOrderByAggregateInput = {
    tmemberid?: SortOrder
    tmemberrank?: SortOrder
  }

  export type testimonialsOrderByRelevanceInput = {
    fields: testimonialsOrderByRelevanceFieldEnum | testimonialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testimonialsCountOrderByAggregateInput = {
    tid?: SortOrder
    tcustomer?: SortOrder
    trole?: SortOrder
    tphoto?: SortOrder
    tmessage?: SortOrder
    tstars?: SortOrder
    tdate?: SortOrder
    tstatus?: SortOrder
  }

  export type testimonialsAvgOrderByAggregateInput = {
    tid?: SortOrder
    tstars?: SortOrder
    tstatus?: SortOrder
  }

  export type testimonialsMaxOrderByAggregateInput = {
    tid?: SortOrder
    tcustomer?: SortOrder
    trole?: SortOrder
    tphoto?: SortOrder
    tmessage?: SortOrder
    tstars?: SortOrder
    tdate?: SortOrder
    tstatus?: SortOrder
  }

  export type testimonialsMinOrderByAggregateInput = {
    tid?: SortOrder
    tcustomer?: SortOrder
    trole?: SortOrder
    tphoto?: SortOrder
    tmessage?: SortOrder
    tstars?: SortOrder
    tdate?: SortOrder
    tstatus?: SortOrder
  }

  export type testimonialsSumOrderByAggregateInput = {
    tid?: SortOrder
    tstars?: SortOrder
    tstatus?: SortOrder
  }

  export type transactionsOrderByRelevanceInput = {
    fields: transactionsOrderByRelevanceFieldEnum | transactionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderref?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    product_subscription?: SortOrder
    qty?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    driverphoto?: SortOrder
    fleetid?: SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    driveraccept?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customeremail?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    status?: SortOrder
    paymentstatus?: SortOrder
    paymentmode?: SortOrder
    paymenttime?: SortOrder
    driverdeliverystatus?: SortOrder
    driverdeliverystatustime?: SortOrder
    driverdeliverytime?: SortOrder
    customerdeliverystatus?: SortOrder
    customerdeliverystatustime?: SortOrder
    customerwaittime?: SortOrder
    orderprocessed?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrder
    driverfeedback?: SortOrder
    notes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    prod_waittime?: SortOrder
    qty?: SortOrder
    howmany?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    driverdeliverytime?: SortOrder
    customerwaittime?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrder
    views?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderref?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    product_subscription?: SortOrder
    qty?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    driverphoto?: SortOrder
    fleetid?: SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    driveraccept?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customeremail?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    status?: SortOrder
    paymentstatus?: SortOrder
    paymentmode?: SortOrder
    paymenttime?: SortOrder
    driverdeliverystatus?: SortOrder
    driverdeliverystatustime?: SortOrder
    driverdeliverytime?: SortOrder
    customerdeliverystatus?: SortOrder
    customerdeliverystatustime?: SortOrder
    customerwaittime?: SortOrder
    orderprocessed?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrder
    driverfeedback?: SortOrder
    notes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderref?: SortOrder
    productid?: SortOrder
    productname?: SortOrder
    prod_waittime?: SortOrder
    product_subscription?: SortOrder
    qty?: SortOrder
    orderdetails?: SortOrder
    req_type?: SortOrder
    task?: SortOrder
    howmany?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverid?: SortOrder
    drivername?: SortOrder
    driverphone?: SortOrder
    driveremail?: SortOrder
    drivervehicleplateno?: SortOrder
    driverphoto?: SortOrder
    fleetid?: SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    driveraccept?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    customeremail?: SortOrder
    customerphone?: SortOrder
    customeraddress?: SortOrder
    customerarea?: SortOrder
    customerareagroup?: SortOrder
    third_party_delivery?: SortOrder
    third_party_name?: SortOrder
    third_party_phone?: SortOrder
    third_party_areagroup?: SortOrder
    third_party_address?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    status?: SortOrder
    paymentstatus?: SortOrder
    paymentmode?: SortOrder
    paymenttime?: SortOrder
    driverdeliverystatus?: SortOrder
    driverdeliverystatustime?: SortOrder
    driverdeliverytime?: SortOrder
    customerdeliverystatus?: SortOrder
    customerdeliverystatustime?: SortOrder
    customerwaittime?: SortOrder
    orderprocessed?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrder
    driverfeedback?: SortOrder
    notes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    productid?: SortOrder
    prod_waittime?: SortOrder
    qty?: SortOrder
    howmany?: SortOrder
    amount?: SortOrder
    commission?: SortOrder
    driverfee?: SortOrder
    driverlatitude?: SortOrder
    driverlongitude?: SortOrder
    customerlatitude?: SortOrder
    customerlongitude?: SortOrder
    driverdeliverytime?: SortOrder
    customerwaittime?: SortOrder
    commission_paid?: SortOrder
    driverrating?: SortOrder
    views?: SortOrder
  }

  export type usermessagesOrderByRelevanceInput = {
    fields: usermessagesOrderByRelevanceFieldEnum | usermessagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usermessagesCountOrderByAggregateInput = {
    umsgid?: SortOrder
    umsg_user?: SortOrder
    umsg_cat?: SortOrder
    umsg_title?: SortOrder
    umsg_body?: SortOrder
    umsg_read?: SortOrder
    umsg_time?: SortOrder
    umsg_sender?: SortOrder
  }

  export type usermessagesAvgOrderByAggregateInput = {
    umsgid?: SortOrder
    umsg_read?: SortOrder
  }

  export type usermessagesMaxOrderByAggregateInput = {
    umsgid?: SortOrder
    umsg_user?: SortOrder
    umsg_cat?: SortOrder
    umsg_title?: SortOrder
    umsg_body?: SortOrder
    umsg_read?: SortOrder
    umsg_time?: SortOrder
    umsg_sender?: SortOrder
  }

  export type usermessagesMinOrderByAggregateInput = {
    umsgid?: SortOrder
    umsg_user?: SortOrder
    umsg_cat?: SortOrder
    umsg_title?: SortOrder
    umsg_body?: SortOrder
    umsg_read?: SortOrder
    umsg_time?: SortOrder
    umsg_sender?: SortOrder
  }

  export type usermessagesSumOrderByAggregateInput = {
    umsgid?: SortOrder
    umsg_read?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MeterReadingsListRelationFilter = {
    every?: MeterReadingsWhereInput
    some?: MeterReadingsWhereInput
    none?: MeterReadingsWhereInput
  }

  export type MeterReadingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fleetid?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    subscription_plan?: SortOrder
    subscription_end?: SortOrder
    address?: SortOrder
    area?: SortOrder
    areagroup?: SortOrder
    residencestate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    role?: SortOrder
    user_type?: SortOrder
    expotoken?: SortOrder
    photo?: SortOrder
    identification?: SortOrder
    identification_back?: SortOrder
    drv_license?: SortOrder
    drv_license_back?: SortOrder
    drv_vehicle_license_plate_no?: SortOrder
    drv_vehicle_capacity?: SortOrder
    drv_vehicle_make?: SortOrder
    drv_vehicle_meterid?: SortOrder
    drv_account_name?: SortOrder
    drv_account_no?: SortOrder
    drv_bank?: SortOrder
    psv_customer_name?: SortOrder
    psv_account_name?: SortOrder
    psv_account_number?: SortOrder
    psv_bank?: SortOrder
    isverified?: SortOrder
    verifiedby?: SortOrder
    isavailable?: SortOrder
    isavailable_by?: SortOrder
    isavailable_reason?: SortOrder
    commissions_outstanding?: SortOrder
    commission_payment_ref?: SortOrder
    isactive?: SortOrder
    isadmin?: SortOrder
    terms?: SortOrder
    enable2fa?: SortOrder
    code2fa?: SortOrder
    expiry2fa?: SortOrder
    signupotp?: SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    fleetid?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    commissions_outstanding?: SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fleetid?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    subscription_plan?: SortOrder
    subscription_end?: SortOrder
    address?: SortOrder
    area?: SortOrder
    areagroup?: SortOrder
    residencestate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    role?: SortOrder
    user_type?: SortOrder
    expotoken?: SortOrder
    photo?: SortOrder
    identification?: SortOrder
    identification_back?: SortOrder
    drv_license?: SortOrder
    drv_license_back?: SortOrder
    drv_vehicle_license_plate_no?: SortOrder
    drv_vehicle_capacity?: SortOrder
    drv_vehicle_make?: SortOrder
    drv_vehicle_meterid?: SortOrder
    drv_account_name?: SortOrder
    drv_account_no?: SortOrder
    drv_bank?: SortOrder
    psv_customer_name?: SortOrder
    psv_account_name?: SortOrder
    psv_account_number?: SortOrder
    psv_bank?: SortOrder
    isverified?: SortOrder
    verifiedby?: SortOrder
    isavailable?: SortOrder
    isavailable_by?: SortOrder
    isavailable_reason?: SortOrder
    commissions_outstanding?: SortOrder
    commission_payment_ref?: SortOrder
    isactive?: SortOrder
    isadmin?: SortOrder
    terms?: SortOrder
    enable2fa?: SortOrder
    code2fa?: SortOrder
    expiry2fa?: SortOrder
    signupotp?: SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    fleetid?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    subscription_plan?: SortOrder
    subscription_end?: SortOrder
    address?: SortOrder
    area?: SortOrder
    areagroup?: SortOrder
    residencestate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    role?: SortOrder
    user_type?: SortOrder
    expotoken?: SortOrder
    photo?: SortOrder
    identification?: SortOrder
    identification_back?: SortOrder
    drv_license?: SortOrder
    drv_license_back?: SortOrder
    drv_vehicle_license_plate_no?: SortOrder
    drv_vehicle_capacity?: SortOrder
    drv_vehicle_make?: SortOrder
    drv_vehicle_meterid?: SortOrder
    drv_account_name?: SortOrder
    drv_account_no?: SortOrder
    drv_bank?: SortOrder
    psv_customer_name?: SortOrder
    psv_account_name?: SortOrder
    psv_account_number?: SortOrder
    psv_bank?: SortOrder
    isverified?: SortOrder
    verifiedby?: SortOrder
    isavailable?: SortOrder
    isavailable_by?: SortOrder
    isavailable_reason?: SortOrder
    commissions_outstanding?: SortOrder
    commission_payment_ref?: SortOrder
    isactive?: SortOrder
    isadmin?: SortOrder
    terms?: SortOrder
    enable2fa?: SortOrder
    code2fa?: SortOrder
    expiry2fa?: SortOrder
    signupotp?: SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    fleetid?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    commissions_outstanding?: SortOrder
    wm_wait_list?: SortOrder
    views?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type videocatOrderByRelevanceInput = {
    fields: videocatOrderByRelevanceFieldEnum | videocatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videocatCountOrderByAggregateInput = {
    vidcatid?: SortOrder
    vidcat?: SortOrder
  }

  export type videocatAvgOrderByAggregateInput = {
    vidcatid?: SortOrder
  }

  export type videocatMaxOrderByAggregateInput = {
    vidcatid?: SortOrder
    vidcat?: SortOrder
  }

  export type videocatMinOrderByAggregateInput = {
    vidcatid?: SortOrder
    vidcat?: SortOrder
  }

  export type videocatSumOrderByAggregateInput = {
    vidcatid?: SortOrder
  }

  export type videosOrderByRelevanceInput = {
    fields: videosOrderByRelevanceFieldEnum | videosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type videosCountOrderByAggregateInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidcategory?: SortOrder
    vidtitle?: SortOrder
    viddesc?: SortOrder
    vidurl?: SortOrder
    vidembed?: SortOrder
    vidpostedby?: SortOrder
    vidtimeposted?: SortOrder
    vidhits?: SortOrder
    vidextra?: SortOrder
  }

  export type videosAvgOrderByAggregateInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidhits?: SortOrder
  }

  export type videosMaxOrderByAggregateInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidcategory?: SortOrder
    vidtitle?: SortOrder
    viddesc?: SortOrder
    vidurl?: SortOrder
    vidembed?: SortOrder
    vidpostedby?: SortOrder
    vidtimeposted?: SortOrder
    vidhits?: SortOrder
    vidextra?: SortOrder
  }

  export type videosMinOrderByAggregateInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidcategory?: SortOrder
    vidtitle?: SortOrder
    viddesc?: SortOrder
    vidurl?: SortOrder
    vidembed?: SortOrder
    vidpostedby?: SortOrder
    vidtimeposted?: SortOrder
    vidhits?: SortOrder
    vidextra?: SortOrder
  }

  export type videosSumOrderByAggregateInput = {
    videntryid?: SortOrder
    vcatid?: SortOrder
    vidhits?: SortOrder
  }

  export type meter_domestic_entriesOrderByRelevanceInput = {
    fields: meter_domestic_entriesOrderByRelevanceFieldEnum | meter_domestic_entriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meter_domestic_entriesCountOrderByAggregateInput = {
    mdid?: SortOrder
    md_unique_id?: SortOrder
    md_userid?: SortOrder
    md_area?: SortOrder
    md_consumption_rate?: SortOrder
    md_volume_received?: SortOrder
    md_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_domestic_entriesAvgOrderByAggregateInput = {
    mdid?: SortOrder
    md_volume_received?: SortOrder
  }

  export type meter_domestic_entriesMaxOrderByAggregateInput = {
    mdid?: SortOrder
    md_unique_id?: SortOrder
    md_userid?: SortOrder
    md_area?: SortOrder
    md_consumption_rate?: SortOrder
    md_volume_received?: SortOrder
    md_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_domestic_entriesMinOrderByAggregateInput = {
    mdid?: SortOrder
    md_unique_id?: SortOrder
    md_userid?: SortOrder
    md_area?: SortOrder
    md_consumption_rate?: SortOrder
    md_volume_received?: SortOrder
    md_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_domestic_entriesSumOrderByAggregateInput = {
    mdid?: SortOrder
    md_volume_received?: SortOrder
  }

  export type meter_supply_entriesOrderByRelevanceInput = {
    fields: meter_supply_entriesOrderByRelevanceFieldEnum | meter_supply_entriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meter_supply_entriesCountOrderByAggregateInput = {
    msid?: SortOrder
    ms_unique_id?: SortOrder
    ms_userid?: SortOrder
    ms_supply_rate?: SortOrder
    ms_volume_supplied?: SortOrder
    ms_temperature_c?: SortOrder
    ms_temperature_f?: SortOrder
    ms_turbidity_level?: SortOrder
    ms_ph_level?: SortOrder
    ms_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_supply_entriesAvgOrderByAggregateInput = {
    msid?: SortOrder
    ms_volume_supplied?: SortOrder
  }

  export type meter_supply_entriesMaxOrderByAggregateInput = {
    msid?: SortOrder
    ms_unique_id?: SortOrder
    ms_userid?: SortOrder
    ms_supply_rate?: SortOrder
    ms_volume_supplied?: SortOrder
    ms_temperature_c?: SortOrder
    ms_temperature_f?: SortOrder
    ms_turbidity_level?: SortOrder
    ms_ph_level?: SortOrder
    ms_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_supply_entriesMinOrderByAggregateInput = {
    msid?: SortOrder
    ms_unique_id?: SortOrder
    ms_userid?: SortOrder
    ms_supply_rate?: SortOrder
    ms_volume_supplied?: SortOrder
    ms_temperature_c?: SortOrder
    ms_temperature_f?: SortOrder
    ms_turbidity_level?: SortOrder
    ms_ph_level?: SortOrder
    ms_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_supply_entriesSumOrderByAggregateInput = {
    msid?: SortOrder
    ms_volume_supplied?: SortOrder
  }

  export type meter_tanker_entriesOrderByRelevanceInput = {
    fields: meter_tanker_entriesOrderByRelevanceFieldEnum | meter_tanker_entriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meter_tanker_entriesCountOrderByAggregateInput = {
    mtid?: SortOrder
    mt_unique_id?: SortOrder
    mt_tankerid?: SortOrder
    mt_delivery_rate?: SortOrder
    mt_volume_delivered?: SortOrder
    mt_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_tanker_entriesAvgOrderByAggregateInput = {
    mtid?: SortOrder
    mt_volume_delivered?: SortOrder
  }

  export type meter_tanker_entriesMaxOrderByAggregateInput = {
    mtid?: SortOrder
    mt_unique_id?: SortOrder
    mt_tankerid?: SortOrder
    mt_delivery_rate?: SortOrder
    mt_volume_delivered?: SortOrder
    mt_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_tanker_entriesMinOrderByAggregateInput = {
    mtid?: SortOrder
    mt_unique_id?: SortOrder
    mt_tankerid?: SortOrder
    mt_delivery_rate?: SortOrder
    mt_volume_delivered?: SortOrder
    mt_valve_state?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_tanker_entriesSumOrderByAggregateInput = {
    mtid?: SortOrder
    mt_volume_delivered?: SortOrder
  }

  export type metersOrderByRelevanceInput = {
    fields: metersOrderByRelevanceFieldEnum | metersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type metersCountOrderByAggregateInput = {
    meterid?: SortOrder
    m_account_number?: SortOrder
    m_unique_id?: SortOrder
    m_for?: SortOrder
    m_assigned?: SortOrder
    m_assigned_to?: SortOrder
    m_assigned_name?: SortOrder
    m_assigned_phone?: SortOrder
    m_assigned_address?: SortOrder
    m_area?: SortOrder
    m_status?: SortOrder
    m_valve_state?: SortOrder
    m_water_unit_price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersAvgOrderByAggregateInput = {
    meterid?: SortOrder
    m_water_unit_price?: SortOrder
  }

  export type metersMaxOrderByAggregateInput = {
    meterid?: SortOrder
    m_account_number?: SortOrder
    m_unique_id?: SortOrder
    m_for?: SortOrder
    m_assigned?: SortOrder
    m_assigned_to?: SortOrder
    m_assigned_name?: SortOrder
    m_assigned_phone?: SortOrder
    m_assigned_address?: SortOrder
    m_area?: SortOrder
    m_status?: SortOrder
    m_valve_state?: SortOrder
    m_water_unit_price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersMinOrderByAggregateInput = {
    meterid?: SortOrder
    m_account_number?: SortOrder
    m_unique_id?: SortOrder
    m_for?: SortOrder
    m_assigned?: SortOrder
    m_assigned_to?: SortOrder
    m_assigned_name?: SortOrder
    m_assigned_phone?: SortOrder
    m_assigned_address?: SortOrder
    m_area?: SortOrder
    m_status?: SortOrder
    m_valve_state?: SortOrder
    m_water_unit_price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersSumOrderByAggregateInput = {
    meterid?: SortOrder
    m_water_unit_price?: SortOrder
  }

  export type contact_messagesOrderByRelevanceInput = {
    fields: contact_messagesOrderByRelevanceFieldEnum | contact_messagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contact_messagesCountOrderByAggregateInput = {
    cid?: SortOrder
    cname?: SortOrder
    cphone?: SortOrder
    cemail?: SortOrder
    csubject?: SortOrder
    cmessage?: SortOrder
    cstatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesAvgOrderByAggregateInput = {
    cid?: SortOrder
  }

  export type contact_messagesMaxOrderByAggregateInput = {
    cid?: SortOrder
    cname?: SortOrder
    cphone?: SortOrder
    cemail?: SortOrder
    csubject?: SortOrder
    cmessage?: SortOrder
    cstatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesMinOrderByAggregateInput = {
    cid?: SortOrder
    cname?: SortOrder
    cphone?: SortOrder
    cemail?: SortOrder
    csubject?: SortOrder
    cmessage?: SortOrder
    cstatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesSumOrderByAggregateInput = {
    cid?: SortOrder
  }

  export type meter_numbersOrderByRelevanceInput = {
    fields: meter_numbersOrderByRelevanceFieldEnum | meter_numbersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meter_numbersCountOrderByAggregateInput = {
    meter_uuid_id?: SortOrder
    meter_type?: SortOrder
    meter_uuid?: SortOrder
    meter_uuid_used?: SortOrder
    meter_assigned?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_numbersAvgOrderByAggregateInput = {
    meter_uuid_id?: SortOrder
  }

  export type meter_numbersMaxOrderByAggregateInput = {
    meter_uuid_id?: SortOrder
    meter_type?: SortOrder
    meter_uuid?: SortOrder
    meter_uuid_used?: SortOrder
    meter_assigned?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_numbersMinOrderByAggregateInput = {
    meter_uuid_id?: SortOrder
    meter_type?: SortOrder
    meter_uuid?: SortOrder
    meter_uuid_used?: SortOrder
    meter_assigned?: SortOrder
    createdAt?: SortOrder
  }

  export type meter_numbersSumOrderByAggregateInput = {
    meter_uuid_id?: SortOrder
  }

  export type driverequestsOrderByRelevanceInput = {
    fields: driverequestsOrderByRelevanceFieldEnum | driverequestsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type driverequestsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driverequestsAvgOrderByAggregateInput = {
    id?: SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    driverid?: SortOrder
  }

  export type driverequestsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driverequestsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    address?: SortOrder
    driverid?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type driverequestsSumOrderByAggregateInput = {
    id?: SortOrder
    orderid?: SortOrder
    customerid?: SortOrder
    driverid?: SortOrder
  }

  export type Enumorder_table_last_update_byFilter<$PrismaModel = never> = {
    equals?: $Enums.order_table_last_update_by | Enumorder_table_last_update_byFieldRefInput<$PrismaModel>
    in?: $Enums.order_table_last_update_by[]
    notIn?: $Enums.order_table_last_update_by[]
    not?: NestedEnumorder_table_last_update_byFilter<$PrismaModel> | $Enums.order_table_last_update_by
  }

  export type order_tableOrderByRelevanceInput = {
    fields: order_tableOrderByRelevanceFieldEnum | order_tableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type order_tableCountOrderByAggregateInput = {
    order_id?: SortOrder
    order_trans_id?: SortOrder
    username?: SortOrder
    order_date?: SortOrder
    order_time?: SortOrder
    status?: SortOrder
    customercomment?: SortOrder
    notes?: SortOrder
    shipping_first_name?: SortOrder
    shipping_last_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    order_total?: SortOrder
    delivery_type?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrder
    gwcustid?: SortOrder
    gwtranxamt?: SortOrder
    gwstatuscode?: SortOrder
    gwstatusmsg?: SortOrder
    o_sesid?: SortOrder
    last_update_by?: SortOrder
    order_stage?: SortOrder
    shipping_option?: SortOrder
    payment_option?: SortOrder
    payment_status?: SortOrder
  }

  export type order_tableAvgOrderByAggregateInput = {
    order_id?: SortOrder
    order_total?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrder
    gwtranxamt?: SortOrder
    gwstatuscode?: SortOrder
    order_stage?: SortOrder
  }

  export type order_tableMaxOrderByAggregateInput = {
    order_id?: SortOrder
    order_trans_id?: SortOrder
    username?: SortOrder
    order_date?: SortOrder
    order_time?: SortOrder
    status?: SortOrder
    customercomment?: SortOrder
    notes?: SortOrder
    shipping_first_name?: SortOrder
    shipping_last_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    order_total?: SortOrder
    delivery_type?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrder
    gwcustid?: SortOrder
    gwtranxamt?: SortOrder
    gwstatuscode?: SortOrder
    gwstatusmsg?: SortOrder
    o_sesid?: SortOrder
    last_update_by?: SortOrder
    order_stage?: SortOrder
    shipping_option?: SortOrder
    payment_option?: SortOrder
    payment_status?: SortOrder
  }

  export type order_tableMinOrderByAggregateInput = {
    order_id?: SortOrder
    order_trans_id?: SortOrder
    username?: SortOrder
    order_date?: SortOrder
    order_time?: SortOrder
    status?: SortOrder
    customercomment?: SortOrder
    notes?: SortOrder
    shipping_first_name?: SortOrder
    shipping_last_name?: SortOrder
    shipping_address1?: SortOrder
    shipping_address2?: SortOrder
    shipping_phone?: SortOrder
    shipping_email?: SortOrder
    shipping_city?: SortOrder
    shipping_state?: SortOrder
    shipping_country?: SortOrder
    order_total?: SortOrder
    delivery_type?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrder
    gwcustid?: SortOrder
    gwtranxamt?: SortOrder
    gwstatuscode?: SortOrder
    gwstatusmsg?: SortOrder
    o_sesid?: SortOrder
    last_update_by?: SortOrder
    order_stage?: SortOrder
    shipping_option?: SortOrder
    payment_option?: SortOrder
    payment_status?: SortOrder
  }

  export type order_tableSumOrderByAggregateInput = {
    order_id?: SortOrder
    order_total?: SortOrder
    shipping_cost?: SortOrder
    grandtotal?: SortOrder
    gatewayid?: SortOrder
    gwtranxid?: SortOrder
    gwtranxamt?: SortOrder
    gwstatuscode?: SortOrder
    order_stage?: SortOrder
  }

  export type Enumorder_table_last_update_byWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.order_table_last_update_by | Enumorder_table_last_update_byFieldRefInput<$PrismaModel>
    in?: $Enums.order_table_last_update_by[]
    notIn?: $Enums.order_table_last_update_by[]
    not?: NestedEnumorder_table_last_update_byWithAggregatesFilter<$PrismaModel> | $Enums.order_table_last_update_by
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumorder_table_last_update_byFilter<$PrismaModel>
    _max?: NestedEnumorder_table_last_update_byFilter<$PrismaModel>
  }

  export type packagesOrderByRelevanceInput = {
    fields: packagesOrderByRelevanceFieldEnum | packagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type packagesCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type packagesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type packagesMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type packagesMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    description?: SortOrder
    picture?: SortOrder
    price?: SortOrder
    size?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type packagesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ratingsOrderByRelevanceInput = {
    fields: ratingsOrderByRelevanceFieldEnum | ratingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ratingsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    customerid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsAvgOrderByAggregateInput = {
    id?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    customerid?: SortOrder
  }

  export type ratingsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    customerid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    orderid?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    comment?: SortOrder
    customerid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsSumOrderByAggregateInput = {
    id?: SortOrder
    driverid?: SortOrder
    stars?: SortOrder
    customerid?: SortOrder
  }

  export type usercatOrderByRelevanceInput = {
    fields: usercatOrderByRelevanceFieldEnum | usercatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usercatCountOrderByAggregateInput = {
    usercatid?: SortOrder
    usercategory?: SortOrder
    usercatdesc?: SortOrder
  }

  export type usercatAvgOrderByAggregateInput = {
    usercatid?: SortOrder
  }

  export type usercatMaxOrderByAggregateInput = {
    usercatid?: SortOrder
    usercategory?: SortOrder
    usercatdesc?: SortOrder
  }

  export type usercatMinOrderByAggregateInput = {
    usercatid?: SortOrder
    usercategory?: SortOrder
    usercatdesc?: SortOrder
  }

  export type usercatSumOrderByAggregateInput = {
    usercatid?: SortOrder
  }

  export type complaints_repliesOrderByRelevanceInput = {
    fields: complaints_repliesOrderByRelevanceFieldEnum | complaints_repliesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type complaints_repliesCountOrderByAggregateInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
    creplysubject?: SortOrder
    creplyname?: SortOrder
    creplyphone?: SortOrder
    creplymessage?: SortOrder
    createdAt?: SortOrder
  }

  export type complaints_repliesAvgOrderByAggregateInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
  }

  export type complaints_repliesMaxOrderByAggregateInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
    creplysubject?: SortOrder
    creplyname?: SortOrder
    creplyphone?: SortOrder
    creplymessage?: SortOrder
    createdAt?: SortOrder
  }

  export type complaints_repliesMinOrderByAggregateInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
    creplysubject?: SortOrder
    creplyname?: SortOrder
    creplyphone?: SortOrder
    creplymessage?: SortOrder
    createdAt?: SortOrder
  }

  export type complaints_repliesSumOrderByAggregateInput = {
    creplyid?: SortOrder
    complaintid?: SortOrder
  }

  export type subscriptionsOrderByRelevanceInput = {
    fields: subscriptionsOrderByRelevanceFieldEnum | subscriptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscriptionsCountOrderByAggregateInput = {
    subplanid?: SortOrder
    subplantype?: SortOrder
    subplanusername?: SortOrder
    subplanamt?: SortOrder
    subplan_from?: SortOrder
    subplan_to?: SortOrder
    subplan_status?: SortOrder
    subplan_pay_status?: SortOrder
    subplan_area?: SortOrder
    subplan_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsAvgOrderByAggregateInput = {
    subplanid?: SortOrder
    subplanamt?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    subplanid?: SortOrder
    subplantype?: SortOrder
    subplanusername?: SortOrder
    subplanamt?: SortOrder
    subplan_from?: SortOrder
    subplan_to?: SortOrder
    subplan_status?: SortOrder
    subplan_pay_status?: SortOrder
    subplan_area?: SortOrder
    subplan_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    subplanid?: SortOrder
    subplantype?: SortOrder
    subplanusername?: SortOrder
    subplanamt?: SortOrder
    subplan_from?: SortOrder
    subplan_to?: SortOrder
    subplan_status?: SortOrder
    subplan_pay_status?: SortOrder
    subplan_area?: SortOrder
    subplan_admin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscriptionsSumOrderByAggregateInput = {
    subplanid?: SortOrder
    subplanamt?: SortOrder
  }

  export type trucksOrderByRelevanceInput = {
    fields: trucksOrderByRelevanceFieldEnum | trucksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type trucksCountOrderByAggregateInput = {
    truckid?: SortOrder
    truck_make?: SortOrder
    truck_plateno?: SortOrder
    truck_fleetowner?: SortOrder
    truck_meterid?: SortOrder
    truck_driver?: SortOrder
    truck_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trucksAvgOrderByAggregateInput = {
    truckid?: SortOrder
    truck_fleetowner?: SortOrder
  }

  export type trucksMaxOrderByAggregateInput = {
    truckid?: SortOrder
    truck_make?: SortOrder
    truck_plateno?: SortOrder
    truck_fleetowner?: SortOrder
    truck_meterid?: SortOrder
    truck_driver?: SortOrder
    truck_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trucksMinOrderByAggregateInput = {
    truckid?: SortOrder
    truck_make?: SortOrder
    truck_plateno?: SortOrder
    truck_fleetowner?: SortOrder
    truck_meterid?: SortOrder
    truck_driver?: SortOrder
    truck_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type trucksSumOrderByAggregateInput = {
    truckid?: SortOrder
    truck_fleetowner?: SortOrder
  }

  export type area_groupsOrderByRelevanceInput = {
    fields: area_groupsOrderByRelevanceFieldEnum | area_groupsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type area_groupsCountOrderByAggregateInput = {
    agid?: SortOrder
    agname?: SortOrder
    agareas?: SortOrder
  }

  export type area_groupsAvgOrderByAggregateInput = {
    agid?: SortOrder
  }

  export type area_groupsMaxOrderByAggregateInput = {
    agid?: SortOrder
    agname?: SortOrder
    agareas?: SortOrder
  }

  export type area_groupsMinOrderByAggregateInput = {
    agid?: SortOrder
    agname?: SortOrder
    agareas?: SortOrder
  }

  export type area_groupsSumOrderByAggregateInput = {
    agid?: SortOrder
  }

  export type product_prices_areasOrderByRelevanceInput = {
    fields: product_prices_areasOrderByRelevanceFieldEnum | product_prices_areasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type product_prices_areasCountOrderByAggregateInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pparea?: SortOrder
    pp_subscription?: SortOrder
    pp_rate?: SortOrder
  }

  export type product_prices_areasAvgOrderByAggregateInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pp_rate?: SortOrder
  }

  export type product_prices_areasMaxOrderByAggregateInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pparea?: SortOrder
    pp_subscription?: SortOrder
    pp_rate?: SortOrder
  }

  export type product_prices_areasMinOrderByAggregateInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pparea?: SortOrder
    pp_subscription?: SortOrder
    pp_rate?: SortOrder
  }

  export type product_prices_areasSumOrderByAggregateInput = {
    ppid?: SortOrder
    ppa_pid?: SortOrder
    pp_rate?: SortOrder
  }

  export type articlesOrderByRelevanceInput = {
    fields: articlesOrderByRelevanceFieldEnum | articlesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type articlesCountOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    fullcontent?: SortOrder
    mkeys?: SortOrder
    mdesc?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    artphotourl?: SortOrder
    author?: SortOrder
    artstatus?: SortOrder
    views?: SortOrder
    published_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type articlesAvgOrderByAggregateInput = {
    artid?: SortOrder
    views?: SortOrder
  }

  export type articlesMaxOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    fullcontent?: SortOrder
    mkeys?: SortOrder
    mdesc?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    artphotourl?: SortOrder
    author?: SortOrder
    artstatus?: SortOrder
    views?: SortOrder
    published_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type articlesMinOrderByAggregateInput = {
    artid?: SortOrder
    artcategory?: SortOrder
    title?: SortOrder
    titleslug?: SortOrder
    fullcontent?: SortOrder
    mkeys?: SortOrder
    mdesc?: SortOrder
    artsource?: SortOrder
    artsource_url?: SortOrder
    artphoto?: SortOrder
    artphotocaption?: SortOrder
    artphotourl?: SortOrder
    author?: SortOrder
    artstatus?: SortOrder
    views?: SortOrder
    published_date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type articlesSumOrderByAggregateInput = {
    artid?: SortOrder
    views?: SortOrder
  }

  export type subscription_plansOrderByRelevanceInput = {
    fields: subscription_plansOrderByRelevanceFieldEnum | subscription_plansOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscription_plansCountOrderByAggregateInput = {
    subplanid?: SortOrder
    subplan_cat?: SortOrder
    subplan?: SortOrder
    subplan_amount?: SortOrder
    subplan_months?: SortOrder
    subplan_include?: SortOrder
    subplan_exclude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscription_plansAvgOrderByAggregateInput = {
    subplanid?: SortOrder
    subplan_amount?: SortOrder
  }

  export type subscription_plansMaxOrderByAggregateInput = {
    subplanid?: SortOrder
    subplan_cat?: SortOrder
    subplan?: SortOrder
    subplan_amount?: SortOrder
    subplan_months?: SortOrder
    subplan_include?: SortOrder
    subplan_exclude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscription_plansMinOrderByAggregateInput = {
    subplanid?: SortOrder
    subplan_cat?: SortOrder
    subplan?: SortOrder
    subplan_amount?: SortOrder
    subplan_months?: SortOrder
    subplan_include?: SortOrder
    subplan_exclude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subscription_plansSumOrderByAggregateInput = {
    subplanid?: SortOrder
    subplan_amount?: SortOrder
  }

  export type vendorreportsOrderByRelevanceInput = {
    fields: vendorreportsOrderByRelevanceFieldEnum | vendorreportsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type vendorreportsCountOrderByAggregateInput = {
    id?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    vendorid?: SortOrder
    plateno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorreportsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type vendorreportsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    vendorid?: SortOrder
    plateno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorreportsMinOrderByAggregateInput = {
    id?: SortOrder
    customerid?: SortOrder
    customername?: SortOrder
    vendorid?: SortOrder
    plateno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorreportsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type water_purchasesOrderByRelevanceInput = {
    fields: water_purchasesOrderByRelevanceFieldEnum | water_purchasesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type water_purchasesCountOrderByAggregateInput = {
    wpid?: SortOrder
    wp_orderref?: SortOrder
    wp_type?: SortOrder
    wp_merchant_id?: SortOrder
    wp_merchant_name?: SortOrder
    wp_merchant_address?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_volume?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_id?: SortOrder
    wp_driver_name?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
    wp_fleetid?: SortOrder
    wp_remark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type water_purchasesAvgOrderByAggregateInput = {
    wpid?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
  }

  export type water_purchasesMaxOrderByAggregateInput = {
    wpid?: SortOrder
    wp_orderref?: SortOrder
    wp_type?: SortOrder
    wp_merchant_id?: SortOrder
    wp_merchant_name?: SortOrder
    wp_merchant_address?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_volume?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_id?: SortOrder
    wp_driver_name?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
    wp_fleetid?: SortOrder
    wp_remark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type water_purchasesMinOrderByAggregateInput = {
    wpid?: SortOrder
    wp_orderref?: SortOrder
    wp_type?: SortOrder
    wp_merchant_id?: SortOrder
    wp_merchant_name?: SortOrder
    wp_merchant_address?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_volume?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_id?: SortOrder
    wp_driver_name?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
    wp_fleetid?: SortOrder
    wp_remark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type water_purchasesSumOrderByAggregateInput = {
    wpid?: SortOrder
    wp_merchant_latitude?: SortOrder
    wp_merchant_longitude?: SortOrder
    wp_amount?: SortOrder
    wp_commission?: SortOrder
    wp_owner_amount?: SortOrder
    wp_driver_latitude?: SortOrder
    wp_driver_longitude?: SortOrder
  }

  export type MetersScalarRelationFilter = {
    is?: metersWhereInput
    isNot?: metersWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type MeterReadingsOrderByRelevanceInput = {
    fields: MeterReadingsOrderByRelevanceFieldEnum | MeterReadingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MeterReadingsMeterIdReading_dateCompoundUniqueInput = {
    meterId: number
    reading_date: Date | string
  }

  export type MeterReadingsCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    reading_date?: SortOrder
    first_reading?: SortOrder
    first_reading_user_id?: SortOrder
    first_reading_at?: SortOrder
    afternoon_reading?: SortOrder
    afternoon_reading_user_id?: SortOrder
    afternoon_reading_at?: SortOrder
    last_reading?: SortOrder
    last_reading_user_id?: SortOrder
    last_reading_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeterReadingsAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    first_reading_user_id?: SortOrder
    afternoon_reading_user_id?: SortOrder
    last_reading_user_id?: SortOrder
  }

  export type MeterReadingsMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    reading_date?: SortOrder
    first_reading?: SortOrder
    first_reading_user_id?: SortOrder
    first_reading_at?: SortOrder
    afternoon_reading?: SortOrder
    afternoon_reading_user_id?: SortOrder
    afternoon_reading_at?: SortOrder
    last_reading?: SortOrder
    last_reading_user_id?: SortOrder
    last_reading_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeterReadingsMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    reading_date?: SortOrder
    first_reading?: SortOrder
    first_reading_user_id?: SortOrder
    first_reading_at?: SortOrder
    afternoon_reading?: SortOrder
    afternoon_reading_user_id?: SortOrder
    afternoon_reading_at?: SortOrder
    last_reading?: SortOrder
    last_reading_user_id?: SortOrder
    last_reading_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeterReadingsSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    first_reading_user_id?: SortOrder
    afternoon_reading_user_id?: SortOrder
    last_reading_user_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MeterReadingsCreateNestedManyWithoutFirst_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput> | MeterReadingsCreateWithoutFirst_reading_userInput[] | MeterReadingsUncheckedCreateWithoutFirst_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutFirst_reading_userInput | MeterReadingsCreateOrConnectWithoutFirst_reading_userInput[]
    createMany?: MeterReadingsCreateManyFirst_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsCreateNestedManyWithoutAfternoon_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput> | MeterReadingsCreateWithoutAfternoon_reading_userInput[] | MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput | MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput[]
    createMany?: MeterReadingsCreateManyAfternoon_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsCreateNestedManyWithoutLast_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput> | MeterReadingsCreateWithoutLast_reading_userInput[] | MeterReadingsUncheckedCreateWithoutLast_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutLast_reading_userInput | MeterReadingsCreateOrConnectWithoutLast_reading_userInput[]
    createMany?: MeterReadingsCreateManyLast_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsUncheckedCreateNestedManyWithoutFirst_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput> | MeterReadingsCreateWithoutFirst_reading_userInput[] | MeterReadingsUncheckedCreateWithoutFirst_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutFirst_reading_userInput | MeterReadingsCreateOrConnectWithoutFirst_reading_userInput[]
    createMany?: MeterReadingsCreateManyFirst_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsUncheckedCreateNestedManyWithoutAfternoon_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput> | MeterReadingsCreateWithoutAfternoon_reading_userInput[] | MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput | MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput[]
    createMany?: MeterReadingsCreateManyAfternoon_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsUncheckedCreateNestedManyWithoutLast_reading_userInput = {
    create?: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput> | MeterReadingsCreateWithoutLast_reading_userInput[] | MeterReadingsUncheckedCreateWithoutLast_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutLast_reading_userInput | MeterReadingsCreateOrConnectWithoutLast_reading_userInput[]
    createMany?: MeterReadingsCreateManyLast_reading_userInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MeterReadingsUpdateManyWithoutFirst_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput> | MeterReadingsCreateWithoutFirst_reading_userInput[] | MeterReadingsUncheckedCreateWithoutFirst_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutFirst_reading_userInput | MeterReadingsCreateOrConnectWithoutFirst_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutFirst_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutFirst_reading_userInput[]
    createMany?: MeterReadingsCreateManyFirst_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutFirst_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutFirst_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutFirst_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutFirst_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUpdateManyWithoutAfternoon_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput> | MeterReadingsCreateWithoutAfternoon_reading_userInput[] | MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput | MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutAfternoon_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutAfternoon_reading_userInput[]
    createMany?: MeterReadingsCreateManyAfternoon_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutAfternoon_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutAfternoon_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutAfternoon_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutAfternoon_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUpdateManyWithoutLast_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput> | MeterReadingsCreateWithoutLast_reading_userInput[] | MeterReadingsUncheckedCreateWithoutLast_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutLast_reading_userInput | MeterReadingsCreateOrConnectWithoutLast_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutLast_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutLast_reading_userInput[]
    createMany?: MeterReadingsCreateManyLast_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutLast_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutLast_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutLast_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutLast_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput> | MeterReadingsCreateWithoutFirst_reading_userInput[] | MeterReadingsUncheckedCreateWithoutFirst_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutFirst_reading_userInput | MeterReadingsCreateOrConnectWithoutFirst_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutFirst_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutFirst_reading_userInput[]
    createMany?: MeterReadingsCreateManyFirst_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutFirst_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutFirst_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutFirst_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutFirst_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput> | MeterReadingsCreateWithoutAfternoon_reading_userInput[] | MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput | MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutAfternoon_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutAfternoon_reading_userInput[]
    createMany?: MeterReadingsCreateManyAfternoon_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutAfternoon_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutAfternoon_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutAfternoon_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutAfternoon_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUncheckedUpdateManyWithoutLast_reading_userNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput> | MeterReadingsCreateWithoutLast_reading_userInput[] | MeterReadingsUncheckedCreateWithoutLast_reading_userInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutLast_reading_userInput | MeterReadingsCreateOrConnectWithoutLast_reading_userInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutLast_reading_userInput | MeterReadingsUpsertWithWhereUniqueWithoutLast_reading_userInput[]
    createMany?: MeterReadingsCreateManyLast_reading_userInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutLast_reading_userInput | MeterReadingsUpdateWithWhereUniqueWithoutLast_reading_userInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutLast_reading_userInput | MeterReadingsUpdateManyWithWhereWithoutLast_reading_userInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsCreateNestedManyWithoutMeterInput = {
    create?: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput> | MeterReadingsCreateWithoutMeterInput[] | MeterReadingsUncheckedCreateWithoutMeterInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutMeterInput | MeterReadingsCreateOrConnectWithoutMeterInput[]
    createMany?: MeterReadingsCreateManyMeterInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsUncheckedCreateNestedManyWithoutMeterInput = {
    create?: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput> | MeterReadingsCreateWithoutMeterInput[] | MeterReadingsUncheckedCreateWithoutMeterInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutMeterInput | MeterReadingsCreateOrConnectWithoutMeterInput[]
    createMany?: MeterReadingsCreateManyMeterInputEnvelope
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
  }

  export type MeterReadingsUpdateManyWithoutMeterNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput> | MeterReadingsCreateWithoutMeterInput[] | MeterReadingsUncheckedCreateWithoutMeterInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutMeterInput | MeterReadingsCreateOrConnectWithoutMeterInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutMeterInput | MeterReadingsUpsertWithWhereUniqueWithoutMeterInput[]
    createMany?: MeterReadingsCreateManyMeterInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutMeterInput | MeterReadingsUpdateWithWhereUniqueWithoutMeterInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutMeterInput | MeterReadingsUpdateManyWithWhereWithoutMeterInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type MeterReadingsUncheckedUpdateManyWithoutMeterNestedInput = {
    create?: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput> | MeterReadingsCreateWithoutMeterInput[] | MeterReadingsUncheckedCreateWithoutMeterInput[]
    connectOrCreate?: MeterReadingsCreateOrConnectWithoutMeterInput | MeterReadingsCreateOrConnectWithoutMeterInput[]
    upsert?: MeterReadingsUpsertWithWhereUniqueWithoutMeterInput | MeterReadingsUpsertWithWhereUniqueWithoutMeterInput[]
    createMany?: MeterReadingsCreateManyMeterInputEnvelope
    set?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    disconnect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    delete?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    connect?: MeterReadingsWhereUniqueInput | MeterReadingsWhereUniqueInput[]
    update?: MeterReadingsUpdateWithWhereUniqueWithoutMeterInput | MeterReadingsUpdateWithWhereUniqueWithoutMeterInput[]
    updateMany?: MeterReadingsUpdateManyWithWhereWithoutMeterInput | MeterReadingsUpdateManyWithWhereWithoutMeterInput[]
    deleteMany?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
  }

  export type Enumorder_table_last_update_byFieldUpdateOperationsInput = {
    set?: $Enums.order_table_last_update_by
  }

  export type metersCreateNestedOneWithoutMeter_readingsInput = {
    create?: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_readingsInput
    connect?: metersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFirst_meter_readingsInput = {
    create?: XOR<usersCreateWithoutFirst_meter_readingsInput, usersUncheckedCreateWithoutFirst_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFirst_meter_readingsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAfternoon_meter_readingsInput = {
    create?: XOR<usersCreateWithoutAfternoon_meter_readingsInput, usersUncheckedCreateWithoutAfternoon_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAfternoon_meter_readingsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutLast_meter_readingsInput = {
    create?: XOR<usersCreateWithoutLast_meter_readingsInput, usersUncheckedCreateWithoutLast_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLast_meter_readingsInput
    connect?: usersWhereUniqueInput
  }

  export type metersUpdateOneRequiredWithoutMeter_readingsNestedInput = {
    create?: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_readingsInput
    upsert?: metersUpsertWithoutMeter_readingsInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutMeter_readingsInput, metersUpdateWithoutMeter_readingsInput>, metersUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type usersUpdateOneWithoutFirst_meter_readingsNestedInput = {
    create?: XOR<usersCreateWithoutFirst_meter_readingsInput, usersUncheckedCreateWithoutFirst_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFirst_meter_readingsInput
    upsert?: usersUpsertWithoutFirst_meter_readingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFirst_meter_readingsInput, usersUpdateWithoutFirst_meter_readingsInput>, usersUncheckedUpdateWithoutFirst_meter_readingsInput>
  }

  export type usersUpdateOneWithoutAfternoon_meter_readingsNestedInput = {
    create?: XOR<usersCreateWithoutAfternoon_meter_readingsInput, usersUncheckedCreateWithoutAfternoon_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAfternoon_meter_readingsInput
    upsert?: usersUpsertWithoutAfternoon_meter_readingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAfternoon_meter_readingsInput, usersUpdateWithoutAfternoon_meter_readingsInput>, usersUncheckedUpdateWithoutAfternoon_meter_readingsInput>
  }

  export type usersUpdateOneWithoutLast_meter_readingsNestedInput = {
    create?: XOR<usersCreateWithoutLast_meter_readingsInput, usersUncheckedCreateWithoutLast_meter_readingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLast_meter_readingsInput
    upsert?: usersUpsertWithoutLast_meter_readingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLast_meter_readingsInput, usersUpdateWithoutLast_meter_readingsInput>, usersUncheckedUpdateWithoutLast_meter_readingsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumorder_table_last_update_byFilter<$PrismaModel = never> = {
    equals?: $Enums.order_table_last_update_by | Enumorder_table_last_update_byFieldRefInput<$PrismaModel>
    in?: $Enums.order_table_last_update_by[]
    notIn?: $Enums.order_table_last_update_by[]
    not?: NestedEnumorder_table_last_update_byFilter<$PrismaModel> | $Enums.order_table_last_update_by
  }

  export type NestedEnumorder_table_last_update_byWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.order_table_last_update_by | Enumorder_table_last_update_byFieldRefInput<$PrismaModel>
    in?: $Enums.order_table_last_update_by[]
    notIn?: $Enums.order_table_last_update_by[]
    not?: NestedEnumorder_table_last_update_byWithAggregatesFilter<$PrismaModel> | $Enums.order_table_last_update_by
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumorder_table_last_update_byFilter<$PrismaModel>
    _max?: NestedEnumorder_table_last_update_byFilter<$PrismaModel>
  }

  export type MeterReadingsCreateWithoutFirst_reading_userInput = {
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meter: metersCreateNestedOneWithoutMeter_readingsInput
    afternoon_reading_user?: usersCreateNestedOneWithoutAfternoon_meter_readingsInput
    last_reading_user?: usersCreateNestedOneWithoutLast_meter_readingsInput
  }

  export type MeterReadingsUncheckedCreateWithoutFirst_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateOrConnectWithoutFirst_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    create: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput>
  }

  export type MeterReadingsCreateManyFirst_reading_userInputEnvelope = {
    data: MeterReadingsCreateManyFirst_reading_userInput | MeterReadingsCreateManyFirst_reading_userInput[]
    skipDuplicates?: boolean
  }

  export type MeterReadingsCreateWithoutAfternoon_reading_userInput = {
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meter: metersCreateNestedOneWithoutMeter_readingsInput
    first_reading_user?: usersCreateNestedOneWithoutFirst_meter_readingsInput
    last_reading_user?: usersCreateNestedOneWithoutLast_meter_readingsInput
  }

  export type MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateOrConnectWithoutAfternoon_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    create: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput>
  }

  export type MeterReadingsCreateManyAfternoon_reading_userInputEnvelope = {
    data: MeterReadingsCreateManyAfternoon_reading_userInput | MeterReadingsCreateManyAfternoon_reading_userInput[]
    skipDuplicates?: boolean
  }

  export type MeterReadingsCreateWithoutLast_reading_userInput = {
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meter: metersCreateNestedOneWithoutMeter_readingsInput
    first_reading_user?: usersCreateNestedOneWithoutFirst_meter_readingsInput
    afternoon_reading_user?: usersCreateNestedOneWithoutAfternoon_meter_readingsInput
  }

  export type MeterReadingsUncheckedCreateWithoutLast_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateOrConnectWithoutLast_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    create: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput>
  }

  export type MeterReadingsCreateManyLast_reading_userInputEnvelope = {
    data: MeterReadingsCreateManyLast_reading_userInput | MeterReadingsCreateManyLast_reading_userInput[]
    skipDuplicates?: boolean
  }

  export type MeterReadingsUpsertWithWhereUniqueWithoutFirst_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    update: XOR<MeterReadingsUpdateWithoutFirst_reading_userInput, MeterReadingsUncheckedUpdateWithoutFirst_reading_userInput>
    create: XOR<MeterReadingsCreateWithoutFirst_reading_userInput, MeterReadingsUncheckedCreateWithoutFirst_reading_userInput>
  }

  export type MeterReadingsUpdateWithWhereUniqueWithoutFirst_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    data: XOR<MeterReadingsUpdateWithoutFirst_reading_userInput, MeterReadingsUncheckedUpdateWithoutFirst_reading_userInput>
  }

  export type MeterReadingsUpdateManyWithWhereWithoutFirst_reading_userInput = {
    where: MeterReadingsScalarWhereInput
    data: XOR<MeterReadingsUpdateManyMutationInput, MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userInput>
  }

  export type MeterReadingsScalarWhereInput = {
    AND?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
    OR?: MeterReadingsScalarWhereInput[]
    NOT?: MeterReadingsScalarWhereInput | MeterReadingsScalarWhereInput[]
    id?: IntFilter<"MeterReadings"> | number
    meterId?: IntFilter<"MeterReadings"> | number
    reading_date?: DateTimeFilter<"MeterReadings"> | Date | string
    first_reading?: StringNullableFilter<"MeterReadings"> | string | null
    first_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    first_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    afternoon_reading?: StringNullableFilter<"MeterReadings"> | string | null
    afternoon_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    afternoon_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    last_reading?: StringNullableFilter<"MeterReadings"> | string | null
    last_reading_user_id?: IntNullableFilter<"MeterReadings"> | number | null
    last_reading_at?: DateTimeNullableFilter<"MeterReadings"> | Date | string | null
    createdAt?: DateTimeFilter<"MeterReadings"> | Date | string
    updatedAt?: DateTimeFilter<"MeterReadings"> | Date | string
  }

  export type MeterReadingsUpsertWithWhereUniqueWithoutAfternoon_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    update: XOR<MeterReadingsUpdateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedUpdateWithoutAfternoon_reading_userInput>
    create: XOR<MeterReadingsCreateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedCreateWithoutAfternoon_reading_userInput>
  }

  export type MeterReadingsUpdateWithWhereUniqueWithoutAfternoon_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    data: XOR<MeterReadingsUpdateWithoutAfternoon_reading_userInput, MeterReadingsUncheckedUpdateWithoutAfternoon_reading_userInput>
  }

  export type MeterReadingsUpdateManyWithWhereWithoutAfternoon_reading_userInput = {
    where: MeterReadingsScalarWhereInput
    data: XOR<MeterReadingsUpdateManyMutationInput, MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userInput>
  }

  export type MeterReadingsUpsertWithWhereUniqueWithoutLast_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    update: XOR<MeterReadingsUpdateWithoutLast_reading_userInput, MeterReadingsUncheckedUpdateWithoutLast_reading_userInput>
    create: XOR<MeterReadingsCreateWithoutLast_reading_userInput, MeterReadingsUncheckedCreateWithoutLast_reading_userInput>
  }

  export type MeterReadingsUpdateWithWhereUniqueWithoutLast_reading_userInput = {
    where: MeterReadingsWhereUniqueInput
    data: XOR<MeterReadingsUpdateWithoutLast_reading_userInput, MeterReadingsUncheckedUpdateWithoutLast_reading_userInput>
  }

  export type MeterReadingsUpdateManyWithWhereWithoutLast_reading_userInput = {
    where: MeterReadingsScalarWhereInput
    data: XOR<MeterReadingsUpdateManyMutationInput, MeterReadingsUncheckedUpdateManyWithoutLast_reading_userInput>
  }

  export type MeterReadingsCreateWithoutMeterInput = {
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    first_reading_user?: usersCreateNestedOneWithoutFirst_meter_readingsInput
    afternoon_reading_user?: usersCreateNestedOneWithoutAfternoon_meter_readingsInput
    last_reading_user?: usersCreateNestedOneWithoutLast_meter_readingsInput
  }

  export type MeterReadingsUncheckedCreateWithoutMeterInput = {
    id?: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateOrConnectWithoutMeterInput = {
    where: MeterReadingsWhereUniqueInput
    create: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput>
  }

  export type MeterReadingsCreateManyMeterInputEnvelope = {
    data: MeterReadingsCreateManyMeterInput | MeterReadingsCreateManyMeterInput[]
    skipDuplicates?: boolean
  }

  export type MeterReadingsUpsertWithWhereUniqueWithoutMeterInput = {
    where: MeterReadingsWhereUniqueInput
    update: XOR<MeterReadingsUpdateWithoutMeterInput, MeterReadingsUncheckedUpdateWithoutMeterInput>
    create: XOR<MeterReadingsCreateWithoutMeterInput, MeterReadingsUncheckedCreateWithoutMeterInput>
  }

  export type MeterReadingsUpdateWithWhereUniqueWithoutMeterInput = {
    where: MeterReadingsWhereUniqueInput
    data: XOR<MeterReadingsUpdateWithoutMeterInput, MeterReadingsUncheckedUpdateWithoutMeterInput>
  }

  export type MeterReadingsUpdateManyWithWhereWithoutMeterInput = {
    where: MeterReadingsScalarWhereInput
    data: XOR<MeterReadingsUpdateManyMutationInput, MeterReadingsUncheckedUpdateManyWithoutMeterInput>
  }

  export type metersCreateWithoutMeter_readingsInput = {
    m_account_number?: string | null
    m_unique_id: string
    m_for?: string
    m_assigned?: string
    m_assigned_to?: string | null
    m_assigned_name?: string | null
    m_assigned_phone?: string | null
    m_assigned_address?: string | null
    m_area?: string | null
    m_status?: string
    m_valve_state?: string
    m_water_unit_price?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type metersUncheckedCreateWithoutMeter_readingsInput = {
    meterid?: number
    m_account_number?: string | null
    m_unique_id: string
    m_for?: string
    m_assigned?: string
    m_assigned_to?: string | null
    m_assigned_name?: string | null
    m_assigned_phone?: string | null
    m_assigned_address?: string | null
    m_area?: string | null
    m_status?: string
    m_valve_state?: string
    m_water_unit_price?: number
    createdAt: Date | string
    updatedAt?: Date | string
  }

  export type metersCreateOrConnectWithoutMeter_readingsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
  }

  export type usersCreateWithoutFirst_meter_readingsInput = {
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    afternoon_meter_readings?: MeterReadingsCreateNestedManyWithoutAfternoon_reading_userInput
    last_meter_readings?: MeterReadingsCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersUncheckedCreateWithoutFirst_meter_readingsInput = {
    id?: number
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    afternoon_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutAfternoon_reading_userInput
    last_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersCreateOrConnectWithoutFirst_meter_readingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFirst_meter_readingsInput, usersUncheckedCreateWithoutFirst_meter_readingsInput>
  }

  export type usersCreateWithoutAfternoon_meter_readingsInput = {
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsCreateNestedManyWithoutFirst_reading_userInput
    last_meter_readings?: MeterReadingsCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersUncheckedCreateWithoutAfternoon_meter_readingsInput = {
    id?: number
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutFirst_reading_userInput
    last_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutLast_reading_userInput
  }

  export type usersCreateOrConnectWithoutAfternoon_meter_readingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAfternoon_meter_readingsInput, usersUncheckedCreateWithoutAfternoon_meter_readingsInput>
  }

  export type usersCreateWithoutLast_meter_readingsInput = {
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsCreateNestedManyWithoutFirst_reading_userInput
    afternoon_meter_readings?: MeterReadingsCreateNestedManyWithoutAfternoon_reading_userInput
  }

  export type usersUncheckedCreateWithoutLast_meter_readingsInput = {
    id?: number
    uuid?: string | null
    fleetid?: number | null
    name: string
    first_name?: string | null
    last_name?: string | null
    username: string
    email: string
    password: string
    phone?: string | null
    dob?: string | null
    subscription_plan?: string
    subscription_end?: Date | string | null
    address?: string | null
    area?: string | null
    areagroup?: string | null
    residencestate?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    role: string
    user_type?: string | null
    expotoken?: string | null
    photo?: string | null
    identification?: string | null
    identification_back?: string | null
    drv_license?: string | null
    drv_license_back?: string | null
    drv_vehicle_license_plate_no?: string | null
    drv_vehicle_capacity?: string | null
    drv_vehicle_make?: string | null
    drv_vehicle_meterid?: string | null
    drv_account_name?: string | null
    drv_account_no?: string | null
    drv_bank?: string | null
    psv_customer_name?: string | null
    psv_account_name?: string | null
    psv_account_number?: string | null
    psv_bank?: string | null
    isverified?: boolean | null
    verifiedby?: string | null
    isavailable?: boolean | null
    isavailable_by?: string | null
    isavailable_reason?: string | null
    commissions_outstanding?: number | null
    commission_payment_ref?: string | null
    isactive?: boolean | null
    isadmin?: boolean | null
    terms?: boolean | null
    enable2fa?: string
    code2fa?: string | null
    expiry2fa?: string | null
    signupotp?: string | null
    wm_wait_list?: number
    views?: number
    createdAt: Date | string
    updatedAt?: Date | string
    first_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutFirst_reading_userInput
    afternoon_meter_readings?: MeterReadingsUncheckedCreateNestedManyWithoutAfternoon_reading_userInput
  }

  export type usersCreateOrConnectWithoutLast_meter_readingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLast_meter_readingsInput, usersUncheckedCreateWithoutLast_meter_readingsInput>
  }

  export type metersUpsertWithoutMeter_readingsInput = {
    update: XOR<metersUpdateWithoutMeter_readingsInput, metersUncheckedUpdateWithoutMeter_readingsInput>
    create: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutMeter_readingsInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutMeter_readingsInput, metersUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type metersUpdateWithoutMeter_readingsInput = {
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersUncheckedUpdateWithoutMeter_readingsInput = {
    meterid?: IntFieldUpdateOperationsInput | number
    m_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    m_unique_id?: StringFieldUpdateOperationsInput | string
    m_for?: StringFieldUpdateOperationsInput | string
    m_assigned?: StringFieldUpdateOperationsInput | string
    m_assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_name?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_phone?: NullableStringFieldUpdateOperationsInput | string | null
    m_assigned_address?: NullableStringFieldUpdateOperationsInput | string | null
    m_area?: NullableStringFieldUpdateOperationsInput | string | null
    m_status?: StringFieldUpdateOperationsInput | string
    m_valve_state?: StringFieldUpdateOperationsInput | string
    m_water_unit_price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutFirst_meter_readingsInput = {
    update: XOR<usersUpdateWithoutFirst_meter_readingsInput, usersUncheckedUpdateWithoutFirst_meter_readingsInput>
    create: XOR<usersCreateWithoutFirst_meter_readingsInput, usersUncheckedCreateWithoutFirst_meter_readingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFirst_meter_readingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFirst_meter_readingsInput, usersUncheckedUpdateWithoutFirst_meter_readingsInput>
  }

  export type usersUpdateWithoutFirst_meter_readingsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    afternoon_meter_readings?: MeterReadingsUpdateManyWithoutAfternoon_reading_userNestedInput
    last_meter_readings?: MeterReadingsUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersUncheckedUpdateWithoutFirst_meter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    afternoon_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userNestedInput
    last_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersUpsertWithoutAfternoon_meter_readingsInput = {
    update: XOR<usersUpdateWithoutAfternoon_meter_readingsInput, usersUncheckedUpdateWithoutAfternoon_meter_readingsInput>
    create: XOR<usersCreateWithoutAfternoon_meter_readingsInput, usersUncheckedCreateWithoutAfternoon_meter_readingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAfternoon_meter_readingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAfternoon_meter_readingsInput, usersUncheckedUpdateWithoutAfternoon_meter_readingsInput>
  }

  export type usersUpdateWithoutAfternoon_meter_readingsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUpdateManyWithoutFirst_reading_userNestedInput
    last_meter_readings?: MeterReadingsUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersUncheckedUpdateWithoutAfternoon_meter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userNestedInput
    last_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutLast_reading_userNestedInput
  }

  export type usersUpsertWithoutLast_meter_readingsInput = {
    update: XOR<usersUpdateWithoutLast_meter_readingsInput, usersUncheckedUpdateWithoutLast_meter_readingsInput>
    create: XOR<usersCreateWithoutLast_meter_readingsInput, usersUncheckedCreateWithoutLast_meter_readingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLast_meter_readingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLast_meter_readingsInput, usersUncheckedUpdateWithoutLast_meter_readingsInput>
  }

  export type usersUpdateWithoutLast_meter_readingsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUpdateManyWithoutFirst_reading_userNestedInput
    afternoon_meter_readings?: MeterReadingsUpdateManyWithoutAfternoon_reading_userNestedInput
  }

  export type usersUncheckedUpdateWithoutLast_meter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    fleetid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_plan?: StringFieldUpdateOperationsInput | string
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    areagroup?: NullableStringFieldUpdateOperationsInput | string | null
    residencestate?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    role?: StringFieldUpdateOperationsInput | string
    user_type?: NullableStringFieldUpdateOperationsInput | string | null
    expotoken?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    identification_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license?: NullableStringFieldUpdateOperationsInput | string | null
    drv_license_back?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_license_plate_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_capacity?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_make?: NullableStringFieldUpdateOperationsInput | string | null
    drv_vehicle_meterid?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    drv_account_no?: NullableStringFieldUpdateOperationsInput | string | null
    drv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    psv_customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_name?: NullableStringFieldUpdateOperationsInput | string | null
    psv_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    psv_bank?: NullableStringFieldUpdateOperationsInput | string | null
    isverified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedby?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isavailable_by?: NullableStringFieldUpdateOperationsInput | string | null
    isavailable_reason?: NullableStringFieldUpdateOperationsInput | string | null
    commissions_outstanding?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_payment_ref?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isadmin?: NullableBoolFieldUpdateOperationsInput | boolean | null
    terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable2fa?: StringFieldUpdateOperationsInput | string
    code2fa?: NullableStringFieldUpdateOperationsInput | string | null
    expiry2fa?: NullableStringFieldUpdateOperationsInput | string | null
    signupotp?: NullableStringFieldUpdateOperationsInput | string | null
    wm_wait_list?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userNestedInput
    afternoon_meter_readings?: MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userNestedInput
  }

  export type MeterReadingsCreateManyFirst_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateManyAfternoon_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsCreateManyLast_reading_userInput = {
    id?: number
    meterId: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsUpdateWithoutFirst_reading_userInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    afternoon_reading_user?: usersUpdateOneWithoutAfternoon_meter_readingsNestedInput
    last_reading_user?: usersUpdateOneWithoutLast_meter_readingsNestedInput
  }

  export type MeterReadingsUncheckedUpdateWithoutFirst_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUncheckedUpdateManyWithoutFirst_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUpdateWithoutAfternoon_reading_userInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    first_reading_user?: usersUpdateOneWithoutFirst_meter_readingsNestedInput
    last_reading_user?: usersUpdateOneWithoutLast_meter_readingsNestedInput
  }

  export type MeterReadingsUncheckedUpdateWithoutAfternoon_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUncheckedUpdateManyWithoutAfternoon_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUpdateWithoutLast_reading_userInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    first_reading_user?: usersUpdateOneWithoutFirst_meter_readingsNestedInput
    afternoon_reading_user?: usersUpdateOneWithoutAfternoon_meter_readingsNestedInput
  }

  export type MeterReadingsUncheckedUpdateWithoutLast_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUncheckedUpdateManyWithoutLast_reading_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsCreateManyMeterInput = {
    id?: number
    reading_date: Date | string
    first_reading?: string | null
    first_reading_user_id?: number | null
    first_reading_at?: Date | string | null
    afternoon_reading?: string | null
    afternoon_reading_user_id?: number | null
    afternoon_reading_at?: Date | string | null
    last_reading?: string | null
    last_reading_user_id?: number | null
    last_reading_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeterReadingsUpdateWithoutMeterInput = {
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading_user?: usersUpdateOneWithoutFirst_meter_readingsNestedInput
    afternoon_reading_user?: usersUpdateOneWithoutAfternoon_meter_readingsNestedInput
    last_reading_user?: usersUpdateOneWithoutLast_meter_readingsNestedInput
  }

  export type MeterReadingsUncheckedUpdateWithoutMeterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeterReadingsUncheckedUpdateManyWithoutMeterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reading_date?: DateTimeFieldUpdateOperationsInput | Date | string
    first_reading?: NullableStringFieldUpdateOperationsInput | string | null
    first_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    afternoon_reading?: NullableStringFieldUpdateOperationsInput | string | null
    afternoon_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    afternoon_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_reading?: NullableStringFieldUpdateOperationsInput | string | null
    last_reading_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    last_reading_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}